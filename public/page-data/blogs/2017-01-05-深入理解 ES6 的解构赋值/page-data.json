{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2017-01-05-深入理解 ES6 的解构赋值/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"627b6ae4-4ca2-55c5-b370-1a259bee3f28","html":"<p class=\"para\">解构赋值（destructuring assignment）语法是一个Javascript表达式，这种语法能够更方便的提取出 Object 或者 Array 中的数据。这种语法可以在接受提取的数据的地方使用，比如一个表达式的左边。有明确的语法模式来告诉我们如何使用这种语法提取需要的数据值。</p>\n<!--more-->\n<h3 class=\"heading\" id=\"Object-的解构\" style=\"position:relative;\"><a href=\"#Object-%E7%9A%84%E8%A7%A3%E6%9E%84\" aria-label=\"Object 的解构 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object 的解构</h3>\n<p class=\"para\">解构 Object:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const obj = { first: &#39;Jane&#39;, last: &#39;Doe&#39; };\nconst {first: f, last: l} = obj;\n// f = &#39;Jane&#39;; l = &#39;Doe&#39;\n\n// {prop} is short for {prop: prop}\nconst {first, last} = obj;\n// first = &#39;Jane&#39;; last = &#39;Doe&#39;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">解构能帮助更好地处理方法返回的对象：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const obj = { foo: 123 };\n\nconst {writable, configurable} = Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;);\n\nconsole.log(writable, configurable); // true true</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"Array-的解构\" style=\"position:relative;\"><a href=\"#Array-%E7%9A%84%E8%A7%A3%E6%9E%84\" aria-label=\"Array 的解构 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array 的解构</h3>\n<p class=\"para\">解构数组，对所有可遍历的值有效。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let foo = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];\n\nlet [one, two, three] = foo;\nconsole.log(one); // &quot;one&quot;\nconsole.log(two); // &quot;two&quot;\nconsole.log(three); // &quot;three&quot;\n\nconst iterable = [&#39;a&#39;, &#39;b&#39;];\nconst [x, y] = iterable;\n// x = &#39;a&#39;; y = &#39;b&#39;\n\n[x, y] = iterable;\n\n// window.x = &#39;a&#39;; window.y = &#39;b&#39;;\n</code>\n        </deckgo-highlight-code>\n<p class=\"para\">同样的，解构数组也能帮助我们更好地处理函数返回值:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [all, year, month, day] =\n    /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\n    .exec(&#39;2999-12-31&#39;);\n</code>\n        </deckgo-highlight-code>\n<p class=\"para\">而且，你也可以忽略你不感兴趣的返回值：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function f() {\n  return [1, 2, 3];\n}\n\nlet [a, , b] = f();\nconsole.log(a); // 1\nconsole.log(b); // 3</code>\n        </deckgo-highlight-code>\n<p class=\"para\">你也可以忽略全部返回值，不过似乎没啥用：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">[,,] = f();</code>\n        </deckgo-highlight-code>\n<p class=\"para\">当解构一个数组时，可以使用剩余模式（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator\" class=\"link-underline\">拓展语句，Spread operator</a>），将数组剩余部分赋值给一个变量。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let [a, ...b] = [1, 2, 3];\nconsole.log(a); // 1\nconsole.log(b); // [2, 3]</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"在什么地方可以使用解构\" style=\"position:relative;\"><a href=\"#%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%84\" aria-label=\"在什么地方可以使用解构 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>在什么地方可以使用解构</h3>\n<p class=\"para\">解构可以在下面这些情景中使用，只展现了数组模式的演示，对象模式也是如此。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 变量声明:\nconst [x] = [&#39;a&#39;];\nlet [x] = [&#39;a&#39;];\nvar [x] = [&#39;a&#39;];\n\n// 赋值: 下面这种情况将会在全局变量上添加一个 x 属性，值为‘a‘\n[x] = [&#39;a&#39;]; \n\n// 参数的定义:\nfunction userId({id}) {\n  return id;\n}\n\nfunction whois({displayName: displayName, fullName: {firstName: name}}){\n  console.log(displayName + &quot; is &quot; + name);\n}\n\nvar user = { \n  id: 42, \n  displayName: &quot;jdoe&quot;,\n  fullName: { \n      firstName: &quot;John&quot;,\n      lastName: &quot;Doe&quot;\n  }\n};\n\nconsole.log(&quot;userId: &quot; + userId(user)); // &quot;userId: 42&quot;\nwhois(user); // &quot;jdoe is John&quot;\n\nfunction f([x]) { ··· }\nf([&#39;a&#39;]);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">也可以在 for-of 循环中使用：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const arr = [&#39;a&#39;, &#39;b&#39;];\nfor (const [index, element] of arr.entries()) {\n    console.log(index, element);\n}\n// Output:\n// 0 a\n// 1 b</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"解构赋值的模型-patterns\" style=\"position:relative;\"><a href=\"#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E6%A8%A1%E5%9E%8B-patterns\" aria-label=\"解构赋值的模型 patterns permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>解构赋值的模型 patterns</h3>\n<p class=\"para\">在解构中，有下面两部分参与：</p>\n<ul>\n<li><strong>Destructuring source:</strong> 解构的源，将要被解构的数据，比如解构赋值表达式的右边部分。</li>\n<li><strong>Destructuring target:</strong> 解构的目标，比如解构复制表达式的左边部分。</li>\n</ul>\n<p class=\"para\">解构的目标可以是下面三个的任意一个：</p>\n<ul>\n<li>赋值对象，Assigment Patterns。例如 x\n<ul>\n<li>赋值对象通常来说是一个变量。但是在解构赋值中，你有更多的选择，稍后会讲到。</li>\n</ul>\n</li>\n<li>对象模型，Object Patterns。比如：<code>{ first: «pattern», last: «pattern» }</code></li>\n<li>数组模型，Object Patterns。比如：<code>[ «pattern», «pattern» ]</code></li>\n</ul>\n<p class=\"para\">可以任意嵌套模型，而且是可以非常任性的嵌套。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const obj = { a: [{ foo: 123, bar: &#39;abc&#39; }, {}], b: true };\nconst { a: [{foo: f}] } = obj; // f = 123</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"解构的-patterns-如何访问到值的内部结构\" style=\"position:relative;\"><a href=\"#%E8%A7%A3%E6%9E%84%E7%9A%84-patterns-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%88%B0%E5%80%BC%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84\" aria-label=\"解构的 patterns 如何访问到值的内部结构 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>解构的 patterns 如何访问到值的内部结构？</h3>\n<p class=\"para\">在一个表达式<code>pattern = someValue</code>中，<code>pattern</code>是如何访问<code>someValue</code>的呢？</p>\n<h3 class=\"heading\" id=\"Object-patterns-将-value-转换成-Object\" style=\"position:relative;\"><a href=\"#Object-patterns-%E5%B0%86-value-%E8%BD%AC%E6%8D%A2%E6%88%90-Object\" aria-label=\"Object patterns 将 value 转换成 Object permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object patterns 将 value 转换成 Object</h3>\n<p class=\"para\">在访问属性之前，object pattern 将解构的源数据（destructuing source）转换成对象。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const {length : len} = &#39;abc&#39;; // len = 3\nconst {toString: s} = 123; // s = Number.prototype.toString</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"使用对象解构的缺点\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E7%9A%84%E7%BC%BA%E7%82%B9\" aria-label=\"使用对象解构的缺点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用“对象解构”的缺点</h4>\n<p class=\"para\">在这个过程中，强制转换成对象的过程不是通过<code>Object()</code>方法，而是通过内置的操作方法<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-toobject\" class=\"link-underline\">toObject()</a>。这两个操作处理<code>undefined</code>和<code>null</code>的方式不太一样。</p>\n<p class=\"para\">Object()方法将原始类型值转换成包装类型对象（wrapper object），原来的值原封不动。</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&gt; typeof Object(&#39;abc&#39;)\n&#39;object&#39;\n\n&gt; var obj = {};\n&gt; Object(obj) === obj\ntrue</code>\n        </deckgo-highlight-code>\n<p class=\"para\">也会将<code>undefined</code> 和 <code>null</code> 转换成一个空的对象。</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&gt; Object(undefined)\n{}\n&gt; Object(null)\n{}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">对比之下，当遇到<code>undefined</code>和<code>null</code>的时候，toObject()方法则会抛出一个错误。所以下面的解构是失败的：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const { prop: x } = undefined; // TypeError\nconst { prop: y } = null; // TypeError</code>\n        </deckgo-highlight-code>\n<p class=\"para\">因此，你可以使用空对象模型{}来检查一个值是否被强制转换成了一个对象。正如前面提到的规则，<code>undefined</code>和<code>null</code>将会抛出错误</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">({} = [true, false]); // OK, Arrays are coercible to objects\n({} = &#39;abc&#39;); // OK, strings are coercible to objects\n\n({} = undefined); // TypeError\n({} = null); // TypeError</code>\n        </deckgo-highlight-code>\n<p class=\"para\">表达式两边的括号是必须的，因为在 JavaScript 中，声明不能以花括号开始。</p>\n<h3 class=\"heading\" id=\"在可遍历的量中使用数组模型\" style=\"position:relative;\"><a href=\"#%E5%9C%A8%E5%8F%AF%E9%81%8D%E5%8E%86%E7%9A%84%E9%87%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E5%9E%8B\" aria-label=\"在可遍历的量中使用数组模型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>在可遍历的量中使用数组模型</h3>\n<p class=\"para\">数组解构使用一个迭代器来获取数据源中的元素。因此，你可以对任何可以遍历的值使用数组解构。</p>\n<p class=\"para\">字符串是可遍历的：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [x, ...y] = &#39;abc&#39;; // x=&#39;a&#39;; y=[&#39;b&#39;, &#39;c&#39;]</code>\n        </deckgo-highlight-code>\n<p class=\"para\">我们无法通过索引访问 Set中的元素，但是可以通过迭代器。所以，数组解构能够在 Sets上工作：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [x,y] = new Set([&#39;a&#39;, &#39;b&#39;]); // x=&#39;a&#39;; y=&#39;b’;</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><code>Set</code>的迭代器总是按照元素插入的顺序将元素返回，所以上述的解构返回的结果总是相同的。</p>\n<h4 class=\"heading\" id=\"使用数组解构的缺点\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E7%9A%84%E7%BC%BA%E7%82%B9\" aria-label=\"使用数组解构的缺点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用“数组解构”的缺点</h4>\n<p class=\"para\">如果一个值有一个 key 为<code>Symbol.iterator</code>的方法，这个方法返回的是一个对象，那么这个值是可以遍历的。如果被解构的值不能遍历的，那么“数组解构”会抛出一个<code>TypeError</code>错误。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let x;\n[x] = [true, false]; // OK, Arrays are iterable\n[x] = &#39;abc&#39;; // OK, strings are iterable\n[x] = { * [Symbol.iterator]() { yield 1 } }; // OK, iterable\n\n[x] = {}; // TypeError, empty objects are not iterable\n[x] = undefined; // TypeError, not iterable\n[x] = null; // TypeError, not iterable</code>\n        </deckgo-highlight-code>\n<p class=\"para\">可以用一个空的数组模型[]来检查值是不是可遍历的:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">[] = {}; // TypeError, empty objects are not iterable\n[] = undefined; // TypeError, not iterable\n[] = null; // TypeError, not iterable</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"默认值\" style=\"position:relative;\"><a href=\"#%E9%BB%98%E8%AE%A4%E5%80%BC\" aria-label=\"默认值 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>默认值</h3>\n<p class=\"para\">默认值是可选的，在数据源中找不到对应的值时，如果设置了默认值，则匹配这个默认值作为匹配结果，否则返回 undefined。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [x=3, y] = []; // x = 3; y = undefined。\nconst {foo: x=3, bar: y} = {}; // x = 3; y = undefined</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"undefined-也会触发默认值\" style=\"position:relative;\"><a href=\"#undefined-%E4%B9%9F%E4%BC%9A%E8%A7%A6%E5%8F%91%E9%BB%98%E8%AE%A4%E5%80%BC\" aria-label=\"undefined 也会触发默认值 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>undefined 也会触发默认值</h4>\n<p class=\"para\">当解构模式有匹配结果，且匹配结果是 undefined 时，也会使用默认值作为返回结果：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [x=1] = [undefined]; // x = 1\nconst {prop: y=2} = {prop: undefined}; // y = 2</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"默认值是根据需要计算出来的\" style=\"position:relative;\"><a href=\"#%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%E6%A0%B9%E6%8D%AE%E9%9C%80%E8%A6%81%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9D%A5%E7%9A%84\" aria-label=\"默认值是根据需要计算出来的 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>默认值是根据需要计算出来的</h4>\n<p class=\"para\">也就是说下面的解构：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const {prop: y=someFunc()} = someValue;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">相当于：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let y;\nif (someValue.prop === undefined) {\n    y = someFunc();\n} else {\n    y = someValue.prop;\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">使用<code>console.log()</code>可以观察到：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&gt; function log(x) { console.log(x); return &#39;YES&#39; }\n&gt; const [a=log(&#39;hello&#39;)] = [];\n&gt; a\n&#39;YES&#39;\n&gt; const [b=log(&#39;hello&#39;)] = [123];\n&gt; b\n123</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在第二个解构中，默认值没有触发，并且<code>log()</code>没有被调用。</p>\n<h4 class=\"heading\" id=\"默认值可以引用模式中的其他变量\" style=\"position:relative;\"><a href=\"#%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E5%8F%98%E9%87%8F\" aria-label=\"默认值可以引用模式中的其他变量 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>默认值可以引用模式中的其他变量</h4>\n<p class=\"para\">默认值可以引用模式中的任何变量，包括相同模式中的其他变量：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [x=3, y=x] = [];     // x=3; y=3\nconst [x=3, y=x] = [7];    // x=7; y=7\nconst [x=3, y=x] = [7, 2]; // x=7; y=2</code>\n        </deckgo-highlight-code>\n<p class=\"para\">但是，变量的顺序很关键，从左到右，先声明的变量不能引用后声明的变量，也就是左边的不能引用右边的。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [x=y, y=3] = []; // ReferenceError</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"patterns-的默认值\" style=\"position:relative;\"><a href=\"#patterns-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC\" aria-label=\"patterns 的默认值 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>patterns 的默认值</h3>\n<p class=\"para\">到目前为止，我们所看到的都是模式中变量的默认值，我们也可以为模式设置默认值。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [{prop: x} = {}] = [];</code>\n        </deckgo-highlight-code>\n<p class=\"para\">如果整个模式没有匹配结果，则使用<code>{}</code>作为数据源来匹配。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const { prop: x } = {}; // x = undefined</code>\n        </deckgo-highlight-code>\n<p class=\"para\">上面的例子中，x 为 undefined 可能还是不够直观。看下面这个例子：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [{prop: x} = {props: &#39;abc&#39;}] = []; // x=abc</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"对象解构的更多特性\" style=\"position:relative;\"><a href=\"#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%89%B9%E6%80%A7\" aria-label=\"对象解构的更多特性 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>对象解构的更多特性</h3>\n<h4 class=\"heading\" id=\"属性属性值的简写\" style=\"position:relative;\"><a href=\"#%E5%B1%9E%E6%80%A7%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E7%AE%80%E5%86%99\" aria-label=\"属性属性值的简写 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>属性，属性值的简写</h4>\n<p class=\"para\">如果属性值是一个变量，和属性的 key相同，就可以忽略这个 key:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const { x, y } = { x: 11, y: 8 }; // x = 11; y = 8\n\n// 等价于\nconst { x: x, y: y } = { x: 11, y: 8 };</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"计算后的属性的键\" style=\"position:relative;\"><a href=\"#%E8%AE%A1%E7%AE%97%E5%90%8E%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9A%84%E9%94%AE\" aria-label=\"计算后的属性的键 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>计算后的属性的键</h4>\n<p class=\"para\">如果把表达式放入方括号中，可以用这个表达式声明属性的键：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const FOO = &#39;foo&#39;;\nconst { [FOO]: f} = {fooL 123}; // f = 123</code>\n        </deckgo-highlight-code>\n<p class=\"para\">这也使得可以使用 symbols 来做属性的键：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// Create and destructure a property whose key is a symbol\nconst KEY = Symbol();\nconst obj = { [KEY]: &#39;abc&#39; };\nconst { [KEY]: x } = obj; // x = &#39;abc&#39;\n\n// Extract Array.prototype[Symbol.iterator]\nconst { [Symbol.iterator]: func } = [];\nconsole.log(typeof func); // function</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"数组解构的更多特性\" style=\"position:relative;\"><a href=\"#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%89%B9%E6%80%A7\" aria-label=\"数组解构的更多特性 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>数组解构的更多特性</h3>\n<h4 class=\"heading\" id=\"省略\" style=\"position:relative;\"><a href=\"#%E7%9C%81%E7%95%A5\" aria-label=\"省略 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>省略</h4>\n<p class=\"para\">在解构的过程中可以跳过一些元素：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [,,x,y] = [1,2,3,4]; // x= 3 y = 4;</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"剩余运算符-Rest-operator-\" style=\"position:relative;\"><a href=\"#%E5%89%A9%E4%BD%99%E8%BF%90%E7%AE%97%E7%AC%A6-Rest-operator-\" aria-label=\"剩余运算符 Rest operator  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>剩余运算符 Rest operator (…)</h4>\n<p class=\"para\">剩余运算符可以将一个可遍历对象中剩余的元素提取到一个数组中。如果这个运算符在数组模式中使用，运算符必须放在最后：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [x, ...y] = [1,2,3,4]; // x=1; y=[2,3,4];</code>\n        </deckgo-highlight-code>\n<p class=\"para\">要注意的时，拓展运算符（spread operator）与剩余操作符有着相同的语法-三个点。但是它们之间有区别：前者将数组变成多个元素；后者则用来解构和提取数据，多个元素压缩成一个元素。</p>\n<p class=\"para\">如果运算符找不到任何元素，将会匹配一个空的数组，永远不会返回undefined 或者 null。例如：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [x, y, ...z] = [&#39;a&#39;]; // x=&#39;a&#39;; y=undefined; z</code>\n        </deckgo-highlight-code>\n<p class=\"para\">操作符不一定非要是一个变量，也可以使用模式：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [x, ...[y, z]] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; // x = &#39;a&#39;; y = &#39;b&#39;; z = &#39;c&#39;</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"解构的陷阱\" style=\"position:relative;\"><a href=\"#%E8%A7%A3%E6%9E%84%E7%9A%84%E9%99%B7%E9%98%B1\" aria-label=\"解构的陷阱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>解构的陷阱</h3>\n<p class=\"para\">在使用解构的时候，有两点要考虑清楚：</p>\n<ol>\n<li>不能使用大括号作为声明语句的开头；</li>\n<li>在解构的过程中，可以申明变量或者分配给变量，但是不能同时这么做；</li>\n</ol>\n<h3 class=\"heading\" id=\"解构的几个例子\" style=\"position:relative;\"><a href=\"#%E8%A7%A3%E6%9E%84%E7%9A%84%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90\" aria-label=\"解构的几个例子 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>解构的几个例子</h3>\n<p class=\"para\">在 for-of 中使用解构：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const map = new Map().set(false, &#39;no&#39;).set(true, &#39;yes&#39;);\nfor (const [key, value] of map) {\n  console.log(key + &#39; is &#39; + value);\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">使用解构交换两个变量的值：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">[a, b] = [b, a];</code>\n        </deckgo-highlight-code>\n<p class=\"para\">或者：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">[a, b, c] = [c, a, b];</code>\n        </deckgo-highlight-code>\n<p class=\"para\">还可以分割数据：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [first, ...rest] = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; // first = &#39;a&#39;; rest = [&#39;b&#39;, &#39;c&#39;]</code>\n        </deckgo-highlight-code>\n<p class=\"para\">处理方法返回的数组更加方便：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [all, year, month, day] = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/.exec(&#39;2999-12-31&#39;);\n\nconst cells = &#39;Jane\\tDoe\\tCTO&#39;\nconst [firstName, lastName, title] = cells.split(&#39;\\t&#39;);\nconsole.log(firstName, lastName, title);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">要注意的一点是：exec等一些方法可能会返回 null，导致程序抛出错误<code>TypeError</code>，此时需要添加一个默认值：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const [, year, month, day] = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/.exec(someStr) || [];</code>\n        </deckgo-highlight-code>\n<p class=\"para\">参考资料：</p>\n<ol>\n<li><a href=\"http://exploringjs.com/es6/ch_destructuring.html\" class=\"link-underline\">Exploringjs Destructuring</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" class=\"link-underline\">MDN Destructing assignment</a></li>\n</ol>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#object-%E7%9A%84%E8%A7%A3%E6%9E%84\">Object 的解构</a></p>\n</li>\n<li>\n<p><a href=\"#array-%E7%9A%84%E8%A7%A3%E6%9E%84\">Array 的解构</a></p>\n</li>\n<li>\n<p><a href=\"#%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E8%A7%A3%E6%9E%84\">在什么地方可以使用解构</a></p>\n</li>\n<li>\n<p><a href=\"#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E6%A8%A1%E5%9E%8B-patterns\">解构赋值的模型 patterns</a></p>\n</li>\n<li>\n<p><a href=\"#%E8%A7%A3%E6%9E%84%E7%9A%84-patterns-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%88%B0%E5%80%BC%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84\">解构的 patterns 如何访问到值的内部结构？</a></p>\n</li>\n<li>\n<p><a href=\"#object-patterns-%E5%B0%86-value-%E8%BD%AC%E6%8D%A2%E6%88%90-object\">Object patterns 将 value 转换成 Object</a></p>\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E7%9A%84%E7%BC%BA%E7%82%B9\">使用“对象解构”的缺点</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E5%9C%A8%E5%8F%AF%E9%81%8D%E5%8E%86%E7%9A%84%E9%87%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E5%9E%8B\">在可遍历的量中使用数组模型</a></p>\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E7%9A%84%E7%BC%BA%E7%82%B9\">使用“数组解构”的缺点</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E9%BB%98%E8%AE%A4%E5%80%BC\">默认值</a></p>\n<ul>\n<li><a href=\"#undefined-%E4%B9%9F%E4%BC%9A%E8%A7%A6%E5%8F%91%E9%BB%98%E8%AE%A4%E5%80%BC\">undefined 也会触发默认值</a></li>\n<li><a href=\"#%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%E6%A0%B9%E6%8D%AE%E9%9C%80%E8%A6%81%E8%AE%A1%E7%AE%97%E5%87%BA%E6%9D%A5%E7%9A%84\">默认值是根据需要计算出来的</a></li>\n<li><a href=\"#%E9%BB%98%E8%AE%A4%E5%80%BC%E5%8F%AF%E4%BB%A5%E5%BC%95%E7%94%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E5%8F%98%E9%87%8F\">默认值可以引用模式中的其他变量</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#patterns-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC\">patterns 的默认值</a></p>\n</li>\n<li>\n<p><a href=\"#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%89%B9%E6%80%A7\">对象解构的更多特性</a></p>\n<ul>\n<li><a href=\"#%E5%B1%9E%E6%80%A7%E5%B1%9E%E6%80%A7%E5%80%BC%E7%9A%84%E7%AE%80%E5%86%99\">属性，属性值的简写</a></li>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E5%90%8E%E7%9A%84%E5%B1%9E%E6%80%A7%E7%9A%84%E9%94%AE\">计算后的属性的键</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%89%B9%E6%80%A7\">数组解构的更多特性</a></p>\n<ul>\n<li><a href=\"#%E7%9C%81%E7%95%A5\">省略</a></li>\n<li><a href=\"#%E5%89%A9%E4%BD%99%E8%BF%90%E7%AE%97%E7%AC%A6-rest-operator-\">剩余运算符 Rest operator (…)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E8%A7%A3%E6%9E%84%E7%9A%84%E9%99%B7%E9%98%B1\">解构的陷阱</a></p>\n</li>\n<li>\n<p><a href=\"#%E8%A7%A3%E6%9E%84%E7%9A%84%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90\">解构的几个例子</a></p>\n</li>\n</ul>","headings":[{"id":"Object-的解构","depth":3,"value":"Object 的解构"},{"id":"Array-的解构","depth":3,"value":"Array 的解构"},{"id":"在什么地方可以使用解构","depth":3,"value":"在什么地方可以使用解构"},{"id":"解构赋值的模型-patterns","depth":3,"value":"解构赋值的模型 patterns"},{"id":"解构的-patterns-如何访问到值的内部结构","depth":3,"value":"解构的 patterns 如何访问到值的内部结构？"},{"id":"Object-patterns-将-value-转换成-Object","depth":3,"value":"Object patterns 将 value 转换成 Object"},{"id":"使用对象解构的缺点","depth":4,"value":"使用“对象解构”的缺点"},{"id":"在可遍历的量中使用数组模型","depth":3,"value":"在可遍历的量中使用数组模型"},{"id":"使用数组解构的缺点","depth":4,"value":"使用“数组解构”的缺点"},{"id":"默认值","depth":3,"value":"默认值"},{"id":"undefined-也会触发默认值","depth":4,"value":"undefined 也会触发默认值"},{"id":"默认值是根据需要计算出来的","depth":4,"value":"默认值是根据需要计算出来的"},{"id":"默认值可以引用模式中的其他变量","depth":4,"value":"默认值可以引用模式中的其他变量"},{"id":"patterns-的默认值","depth":3,"value":"patterns 的默认值"},{"id":"对象解构的更多特性","depth":3,"value":"对象解构的更多特性"},{"id":"属性属性值的简写","depth":4,"value":"属性，属性值的简写"},{"id":"计算后的属性的键","depth":4,"value":"计算后的属性的键"},{"id":"数组解构的更多特性","depth":3,"value":"数组解构的更多特性"},{"id":"省略","depth":4,"value":"省略"},{"id":"剩余运算符-Rest-operator-","depth":4,"value":"剩余运算符 Rest operator (…)"},{"id":"解构的陷阱","depth":3,"value":"解构的陷阱"},{"id":"解构的几个例子","depth":3,"value":"解构的几个例子"}],"frontmatter":{"title":"深入理解 ES6 的解构赋值","date":"2017-01-05","cover":null,"description":null,"categories":["前端"],"tags":["JavaScript"]}},"previous":{"fields":{"slug":"/blogs/2017-01-11-JavaScrip-模块系统详解/"},"frontmatter":{"title":"JavaScrip模块系统详解"}},"next":{"fields":{"slug":"/blogs/2016-12-24-使用Firebase构建云端应用-数据库的管理/"},"frontmatter":{"title":"使用Firebase构建云端应用-数据库的管理","tags":["React","JavaScript"],"categories":["前端"],"status":null}}},"pageContext":{"id":"627b6ae4-4ca2-55c5-b370-1a259bee3f28","previousPostId":"9859446f-1ab1-59c5-9ac8-3b78ae64ff3c","nextPostId":"4b4c9489-7057-5d1a-bb0c-7524e588219b"}},
    "staticQueryHashes": ["2841359383"]}