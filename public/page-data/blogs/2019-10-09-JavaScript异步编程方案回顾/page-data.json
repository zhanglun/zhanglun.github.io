{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2019-10-09-JavaScript异步编程方案回顾/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"f06adf32-8be0-5302-9ef5-1934d9f7b5ad","html":"<p class=\"para\">如标题所述，本文主要是重新梳理JavaScript的异步编程方案，部分内容来自网络</p>\n<h2 class=\"heading subtitle heading\" id=\"同步\" style=\"position:relative;\"><a href=\"#%E5%90%8C%E6%AD%A5\" aria-label=\"同步 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>同步</h2>\n<p class=\"para\">在开始之前，先简单说说JavaScript中的同步。先来个两个简单的例子：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const btn = document.querySelector(&#39;button&#39;);\nbtn.addEventListener(&#39;click&#39;, () =&gt; {\n  alert(&#39;危!&#39;);\n\n  let pElem = document.createElement(&#39;p&#39;);\n  pElem.textContent = &#39;哈哈哈&#39;;\n  document.body.appendChild(pElem);\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">这段代码, 一行一行的顺序执行：</p>\n<ol>\n<li>先取得一个在DOM里面的 &#x3C;button> 引用。</li>\n<li>点击按钮的时候，添加一个 click 事件监听器:</li>\n<li>alert() 消息出现。</li>\n<li>一旦alert 结束，创建一个 &#x3C;p> 元素。</li>\n<li>给它的文本内容赋值。</li>\n<li>最后，把这个段落放进网页。</li>\n</ol>\n<p class=\"para\">再比如，模拟一个现实中网页可能遇到的情况：因为渲染UI而阻塞用户的互动，这个例子有2个按钮:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function expensiveOperation() {\n  for(let i = 0; i &lt; 1000000; i++) {\n    ctx.fillStyle = &#39;rgba(0,0,255, 0.2)&#39;;\n    ctx.beginPath();\n    ctx.arc(random(0, canvas.width), random(0, canvas.height), 10, degToRad(0), degToRad(360), false);\n    ctx.fill()\n  }\n}\n\nfillBtn.addEventListener(&#39;click&#39;, expensiveOperation);\n\nalertBtn.addEventListener(&#39;click&#39;, () =&gt;\n  alert(&#39;You clicked me!&#39;)\n);</code>\n        </deckgo-highlight-code>\n<ol>\n<li>点击的时候用1百万个蓝色的圆填满整个&#x3C;canvas></li>\n<li>点击显示 alert 消息</li>\n</ol>\n<p class=\"para\">在浏览器中只有一个主线程(main thread)能够任务，也就是我们常说的<code>JavaScript是单线程的（single threaded）</code>。在一个线程中，任务只能one by one 执行，这也就是所谓的“同步阻塞”。</p>\n<p class=\"para\">但是在实际场景中，只是同步无法满足日常需求，比如用户代理(User Agent)提供了一些API特性，特别是从外部的设备上获取资源，譬如，从网络获取文件，访问数据库，从网络摄像头获得视频流等等，这些都是耗时操作。同步则一定导致阻塞，在用户使用的角度上来说，感受不够友好。</p>\n<p class=\"para\">接下来回顾一下JavaScript中异步解决方案</p>\n<h2 class=\"heading subtitle heading\" id=\"老派Callback\" style=\"position:relative;\"><a href=\"#%E8%80%81%E6%B4%BECallback\" aria-label=\"老派Callback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>老派Callback</h2>\n<p class=\"para\">以DOM事件和XMLHttpRequest为代表</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">btn.addEventListener(&#39;click&#39;, () =&gt; {\n  alert(&#39;You clicked me!&#39;);\n\n  let pElem = document.createElement(&#39;p&#39;);\n  pElem.textContent = &#39;This is a newly-added paragraph.&#39;;\n  document.body.appendChild(pElem);\n});\n</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function loadAsset(url, type, callback) {\n  let xhr = new XMLHttpRequest();\n  xhr.open(&#39;GET&#39;, url);\n  xhr.responseType = type;\n\n  xhr.onload = function() {\n    callback(xhr.response);\n  };\n\n  xhr.send();\n}\n\nfunction displayImage(blob) {\n  let objectURL = URL.createObjectURL(blob);\n\n  let image = document.createElement(&#39;img&#39;);\n  image.src = objectURL;\n  document.body.appendChild(image);\n}\n\nloadAsset(&#39;coffee.jpg&#39;, &#39;blob&#39;, displayImage);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">上述两个例子中，都会将callback注册到EventLoop的任务队列中，这两类都属于宏任务。在 <code>main thread</code> 空闲时执行。</p>\n<p class=\"para\">传统的callback处理方式容易陷入<code>回调地域</code></p>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a9f3a15f626aa58191c6ac45c4b149db/1982c/5d5b4b180001a9f311761290.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 109.57446808510637%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAWABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAH3NZHRBAUH/8QAFxAAAwEAAAAAAAAAAAAAAAAAARARAP/aAAgBAQABBQJzAuL/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AR//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAUEAEAAAAAAAAAAAAAAAAAAAAw/9oACAEBAAY/Ah//xAAaEAACAwEBAAAAAAAAAAAAAAABEQAQITGx/9oACAEBAAE/ISGc9ga2jhjtg5Er/9oADAMBAAIAAwAAABBwzzz/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EB//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/EB//xAAfEAEAAgEDBQAAAAAAAAAAAAABABEhEEFhMVFxkbH/2gAIAQEAAT8Qplg7x2m+NLiWB7lWNvmjseJYuOvMCif/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"5d5b4b180001a9f311761290.jpeg\"\n        title=\"5d5b4b180001a9f311761290.jpeg\"\n        src=\"/static/a9f3a15f626aa58191c6ac45c4b149db/acb04/5d5b4b180001a9f311761290.jpg\"\n        srcset=\"/static/a9f3a15f626aa58191c6ac45c4b149db/bc01b/5d5b4b180001a9f311761290.jpg 188w,\n/static/a9f3a15f626aa58191c6ac45c4b149db/bf173/5d5b4b180001a9f311761290.jpg 375w,\n/static/a9f3a15f626aa58191c6ac45c4b149db/acb04/5d5b4b180001a9f311761290.jpg 750w,\n/static/a9f3a15f626aa58191c6ac45c4b149db/ec605/5d5b4b180001a9f311761290.jpg 1125w,\n/static/a9f3a15f626aa58191c6ac45c4b149db/1982c/5d5b4b180001a9f311761290.jpg 1176w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span>。</p>\n<h2 class=\"heading subtitle heading\" id=\"Promise\" style=\"position:relative;\"><a href=\"#Promise\" aria-label=\"Promise permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise</h2>\n<blockquote class=\"quote\">\n<p class=\"para\">A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation</p>\n</blockquote>\n<p class=\"para\">Promise 对象本质上表示的是一系列操作的中间状态，或者说是未来某时刻一个操作完成或失败后返回的结果。Promise并不保证操作在何时完成并返回结果，但是保证在当前操作成功后执行您对操作结果的处理代码，或在操作失败后，优雅地处理操作失败的情况。</p>\n<p class=\"para\">早在 1980 年代，早期的 promise 和 future（类似/相关概念） 实现开始出现。单词 “promise” 的使用由 Barbara Liskov 和 Liuba Shrira 在 1988 年创造 <a href=\"https://en.wikipedia.org/wiki/Futures_and_promises\" class=\"link-underline\">wiki：Future and promises</a>。Liuba的<a href=\"https://heather.miller.am/teaching/cs7680/pdfs/liskov1988.pdf\" class=\"link-underline\">论文pdf版本</a></p>\n<p class=\"para\">CommonJS组织提出了 <a href=\"http://wiki.commonjs.org/wiki/Promises/A\" class=\"link-underline\">Promises/A</a> 制定异步模式编程规范，最早的时间可以追溯到2010年。比较出名的实现有： <a href=\"https://github.com/kriskowal/q\" class=\"link-underline\">Q</a>， <a href=\"https://api.jquery.com/category/deferred-object/\" class=\"link-underline\">jQuery</a> 。</p>\n<p class=\"para\">我第一次在 JavaScript 中听说 promise 时，在2015年实习阶段使用Angular的时候。在此之前也稍微接触了jQuery的<code>Defferd对象</code>。典型的案例就是使用jQuery提供的ajax方法，举个例子：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var jqxhr = $.ajax( &quot;example.php&quot; )\n  .done(function() {\n    alert( &quot;success&quot; );\n  })\n  .fail(function() {\n    alert( &quot;error&quot; );\n  })\n  .always(function() {\n    alert( &quot;complete&quot; );\n  });\n \njqxhr.always(function() {\n  alert( &quot;second complete&quot; );\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">由于在那段时间 jQuery 极其流行，它迅速成为了使用最广泛的 promise 实现。jQuery 正式使得 JavaScript promise 成为主流。一些更好的独立 promise 库如 Q、When、Bulebird 开始流行。jQuery 的一些不一致的实现驱使 Promise 标准做了一些重要的阐明，重写并更名为 <a href=\"https://promisesaplus.com/\" class=\"link-underline\">Promises/A+</a>。</p>\n<p class=\"para\">历史在发展，时代在进步。经过一段时间各种Libary的锤炼，ES6\n中也新增了<a href=\"https://tc39.es/ecma262/#sec-promise-objects\" class=\"link-underline\">Promise</a>。不过要注意一点。ES6中的Promise规范完全覆盖了的Promise/A+规范。Promise/A+规范设计成最小规范。ES6的Promise规范完全兼容A+，同时又包含诸如<code>catch</code>,<code>finially</code>等特性</p>\n<p class=\"para\">关于Promise的使用本文不再赘述，网上已经有很丰富的资料内容了。</p>\n<h2 class=\"heading subtitle heading\" id=\"Generator\" style=\"position:relative;\"><a href=\"#Generator\" aria-label=\"Generator permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generator</h2>\n<p class=\"para\">类似的，<code>Generator</code>的概念也是计算机科学中普遍存在的概念之一</p>\n<blockquote class=\"quote\">\n<p class=\"para\">In computer science, a generator is a routine that can be used to control the iteration behaviour of a loop.</p>\n</blockquote>\n<p class=\"para\">其本质是一个可以控制一个循环迭代行为的子程序(routine)。可以理解就是函数。可以简单的认为它是一个返回数组的函数。在ES6中，也把它翻译成<code>生成器函数</code>。讨论Generator必然离不开<code>协程</code>。协程又称微线程，纤程，英文名 <code>Coroutine</code>。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行.</p>\n<p class=\"para\">协程由于由程序主动控制切换，没有线程切换的开销，所以执行效率极高。对于IO密集型任务非常适用。我们也正是利用协程随时切换的特性来实现异步编程。</p>\n<p class=\"para\">在真正使用Generator来实现异步编程时，你还得先搞清楚什么是<code>Iterator Protocal</code>，什么是<code>Iteratable Protocal</code>。同样本文也不再赘述。虽然从根本上来说<code>Generator</code>诞生之初并不是为了解决异步任务，但是不妨碍广大前端朋友的机智创新。举个简单例子：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let fs = require(&#39;fs&#39;)\nfunction read(file) {\n  return new Promise(function(resolve, reject) {\n    fs.readFile(file, &#39;utf8&#39;, function(err, data) {\n      if (err) reject(err)\n      resolve(data)\n    })\n  })\n}\nfunction* r() {\n  let r1 = yield read(&#39;./1.txt&#39;)\n  let r2 = yield read(r1)\n  let r3 = yield read(r2)\n  console.log(r1)\n  console.log(r2)\n  console.log(r3)\n}\nlet it = r()\nlet { value, done } = it.next()\nvalue.then(function(data) { // value是个promise\n  console.log(data) //data=&gt;2.txt\n  let { value, done } = it.next(data)\n  value.then(function(data) {\n    console.log(data) //data=&gt;3.txt\n    let { value, done } = it.next(data)\n    value.then(function(data) {\n      console.log(data) //data=&gt;结束\n    })\n  })\n})\n\n// 2.txt=&gt;3.txt=&gt;结束</code>\n        </deckgo-highlight-code>\n<p class=\"para\">可以看到手动迭代 Generator 函数很麻烦。</p>\n<h2 class=\"heading subtitle heading\" id=\"AsyncAwait\" style=\"position:relative;\"><a href=\"#AsyncAwait\" aria-label=\"AsyncAwait permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Async/Await</h2>\n<p class=\"para\">简单的说async函数就相当于自执行的Generator函数，在await的部分等待返回，返回后自动执行下一步。而且相较于Promise，async的优越性就是把每次异步返回的结果从then中拿到最外层的方法中，不需要链式调用，只要用同步的写法就可以了。更加直观而且，更适合处理并发调用的问题。但是async必须以一个Promise对象开始 ，所以async通常是和Promise结合使用的。babel和typescript的<code>async/await</code>是用<code>yield/generator</code>实现的\n如下所示同样的代码中</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">async function a () {\n\treturn 1\n}\nasync function b () {\n\tawait a()\n}\n\nb()</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在[babel repl]中设置<code>presets</code>中勾选<code>es2016</code>和<code>es2017</code>时，编译后的结果中使用了 <code>Promise</code> 和 <code>Generaotr</code>。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { \n  try { \n    var info = gen[key](arg); \n    var value = info.value; \n  } catch (error) { \n    reject(error); return; \n  } \n  \n  if (info.done) {\n    resolve(value); \n  } else { \n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) { \n  return function () { \n    var self = this, \n    args = arguments; \n    return new Promise(function (resolve, reject) { \n      var gen = fn.apply(self, args); \n      function _next(value) { \n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;next&quot;, value); \n      } \n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, &quot;throw&quot;, err); \n      } \n      \n      _next(undefined);\n    }); \n  }; \n}\n\nfunction a() {\n  return _a.apply(this, arguments);\n}\n\nfunction _a() {\n  _a = _asyncToGenerator(function* () {\n    return 1;\n  });\n  return _a.apply(this, arguments);\n}\n\nfunction b() {\n  return _b.apply(this, arguments);\n}\n\nfunction _b() {\n  _b = _asyncToGenerator(function* () {\n    yield a();\n  });\n  return _b.apply(this, arguments);\n}\n\nb();</code>\n        </deckgo-highlight-code>\n<p class=\"para\">当输出的js版本修改为更低版本时，编译后的代码将会包含使用<a href=\"https://github.com/facebook/regenerator\" class=\"link-underline\">regenerator</a>提供的<code>regeneratorRuntime</code>来实现 generator 函数</p>\n<p class=\"para\">在<a href=\"https://www.typescriptlang.org/play?target=2#code/IYZwngdgxgBAZgV2gFwJYHsI2DAFAShgG8AoASACcBTZBCrARhIF8TRJZEUMsAjPQqTLAA7sFTJsBFiRK9pJIA\" class=\"link-underline\">Typescript Repl</a>中将<code>Target</code>设置为<code>es2015</code>，可以看到编译结果中同样也以后<code>Promise</code>和<code>Generator</code>的身影</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&quot;use strict&quot;;\nvar __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction a() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return 1;\n    });\n}\nfunction b() {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield a();\n    });\n}\nb();</code>\n        </deckgo-highlight-code>\n<p class=\"para\">将输出版本修改为<code>ES5</code>时，可以看到些许差别。Typesciprt编译的结果中包含generator的实现</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&quot;use strict&quot;;\nvar __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[&quot;throw&quot;](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this &amp;&amp; this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] &amp; 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), &quot;throw&quot;: verb(1), &quot;return&quot;: verb(2) }, typeof Symbol === &quot;function&quot; &amp;&amp; (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(&quot;Generator is already executing.&quot;);\n        while (_) try {\n            if (f = 1, y &amp;&amp; (t = op[0] &amp; 2 ? y[&quot;return&quot;] : op[0] ? y[&quot;throw&quot;] || ((t = y[&quot;return&quot;]) &amp;&amp; t.call(y), 0) : y.next) &amp;&amp; !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] &amp; 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length &gt; 0 &amp;&amp; t[t.length - 1]) &amp;&amp; (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 &amp;&amp; (!t || (op[1] &gt; t[0] &amp;&amp; op[1] &lt; t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 &amp;&amp; _.label &lt; t[1]) { _.label = t[1]; t = op; break; }\n                    if (t &amp;&amp; _.label &lt; t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] &amp; 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nfunction a() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            return [2 /*return*/, 1];\n        });\n    });\n}\nfunction b() {\n    return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, a()];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nb();</code>\n        </deckgo-highlight-code>\n<p class=\"para\">所以现阶段可以这么认为：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">Async/Await = Generaotr + Promise</code>\n        </deckgo-highlight-code>","tableOfContents":"<ul>\n<li><a href=\"#%E5%90%8C%E6%AD%A5\">同步</a></li>\n<li><a href=\"#%E8%80%81%E6%B4%BEcallback\">老派Callback</a></li>\n<li><a href=\"#promise\">Promise</a></li>\n<li><a href=\"#generator\">Generator</a></li>\n<li><a href=\"#asyncawait\">Async/Await</a></li>\n</ul>","headings":[{"id":"同步","depth":2,"value":"同步"},{"id":"老派Callback","depth":2,"value":"老派Callback"},{"id":"Promise","depth":2,"value":"Promise"},{"id":"Generator","depth":2,"value":"Generator"},{"id":"AsyncAwait","depth":2,"value":"Async/Await"}],"frontmatter":{"title":"JavaScript异步编程方案回顾","date":"2019-10-09","cover":null,"description":null,"categories":["技术学习"],"tags":["JavaScrtipt"]}},"previous":{"fields":{"slug":"/blogs/浅谈TreeShaking在前端中的应用/"},"frontmatter":{"title":"浅谈TreeShaking在前端中的应用 - Rollup VS Webpack"}},"next":{"fields":{"slug":"/blogs/再谈EventLoop/"},"frontmatter":{"title":"再谈EventLoop","tags":[],"categories":[],"status":null}}},"pageContext":{"id":"f06adf32-8be0-5302-9ef5-1934d9f7b5ad","previousPostId":"851e2188-4c4b-5a9f-8e22-e734f76b7404","nextPostId":"8b41650b-72bc-55f9-a2f0-aa17ee0251c0"}},
    "staticQueryHashes": ["2841359383"]}