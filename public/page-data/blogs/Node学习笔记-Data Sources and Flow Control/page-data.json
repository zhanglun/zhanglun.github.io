{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/Node学习笔记-Data Sources and Flow Control/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"f1d9670a-36de-599d-962c-35d000d9401a","html":"<blockquote class=\"quote\">\n<p class=\"para\">额在之前的笔记中，提到了使用middleware，设置路由，发送数据，处理请求，渲染模板等。但是这些都不足以完成一个Web应用程序，动态数据交互需要和数据库联系在一起。当用户向服务器发送一个请求，响应的服务器可能就需要向数据库发送请求，此时，之后当数据库将数据返回给服务器，服务端才能够将响应给用户。好的，在这里就涉及到了服务端的流控制（server-side flow control）</p>\n</blockquote>\n<h2 class=\"heading subtitle heading\" id=\"Connecting-to-Database\" style=\"position:relative;\"><a href=\"#Connecting-to-Database\" aria-label=\"Connecting to Database permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Connecting to Database</h2>\n<p class=\"para\">在Node中没有的提供默认的链接数据的方法，同时又有很多类型的数据库都支持在Node中使用。至于如何选择还是要看具体情况具体分析。书上用的例子是Redis，这是一个很轻量级的数据，具体的我也不太懂。这里是它的<a href=\"http://redis.io/\" class=\"link-underline\">官网</a>，由于没有官方的window版本，我决定先试试用SQLite。</p>\n<p class=\"para\">之前有过一个sqlite的数据文件，里面是在豆瓣电影上抓取的一点点东西，正好可以用上。</p>\n<p class=\"para\">Node的包实在是太多了，往往有时候陷入选择困难症……。我选用的是叫做<code>sqlite3</code>的modules，NPM上提供的详细资料在<a href=\"https://www.npmjs.org/package/sqlite3\" class=\"link-underline\">这里</a>，<a href=\"https://github.com/mapbox/node-sqlite3/wiki/\" class=\"link-underline\">这里</a>还有其API文档。</p>\n<p class=\"para\">在server.js的目录下新建<code>db</code>文件夹，里面放着待会儿要用的db文件。在Node中使用sqlite时，也要先引用它对应的module。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var sqlite3 = require(&#39;sqlite3&#39;).verbose();\r\nvar db = new sqlite3.Database(&#39;./db/douban.rdb&#39;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">路由的设置和之前的一样，采用<code>connect-route</code>，从数据库读取到数据完成之后，调用回调函数，回调函数中的参数<code>row</code>包含每一行的数据，</p>\n<deckgo-highlight-code language=\"html\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;!--movie.html template--&gt;\r\n&lt;h1&gt;豆瓣电影&lt;/h1&gt;\r\n&lt;dl&gt;\r\n    &lt;dt&gt;{{name}}&lt;/dt&gt;\r\n    &lt;dd&gt;&lt;img src=&quot;{{img}}&quot; alt=&quot;{{name}}&quot;&gt;&lt;/dd&gt;\r\n    &lt;dd&gt;&lt;a href=&quot;{{href}}&quot;&gt;{{name}}&lt;/a&gt;&lt;/dd&gt;\r\n    &lt;dd&gt;&lt;span&gt;{{type}}&lt;/span&gt; &amp;nbsp;&amp;nbsp;&lt;span&gt;&lt;/span&gt;&lt;/dd&gt;\r\n&lt;/dl&gt;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// server.js\r\n// 忽略外部函数，只显示核心代码\r\nrouter.get(&#39;/movie&#39;, function(req, res, next){\r\n    var search = db.each(&quot;select * from MOVIE&quot;, function(err, row){\r\n        console.log(row);\r\n        var movie={\r\n            name:row.name,\r\n            href:row.href,\r\n            img:row.post_url,\r\n            type:row.type\r\n        };\r\n        var readable = mu.compileAndRender(&#39;movie.html&#39;, movie);\r\n        readable.pipe(res);\r\n    });\r\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">这应该算的上是Node中操作数据库最简单的例子，执行select语句读取数据，然后将数据渲染到模板中，呈现给用户。觉得还是有必要把sqlite3的API稍微翻译下做个笔记，不然每次都去查有点子麻烦。</p>\n<h2 class=\"heading subtitle heading\" id=\"Storing-Data-in-Files\" style=\"position:relative;\"><a href=\"#Storing-Data-in-Files\" aria-label=\"Storing Data in Files permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Storing Data in Files</h2>\n<p class=\"para\">上面讲的是从数据库中取数据，现在来说说如何存储数据。其实我觉得这些问题，只要搞明白了一个，其他的也就不怎么困难了。取数据的时候我们是先访问数据库，然后查找，找到自己需要的数据之后返回就行，大体上就是这么个过程，那么反过来存储数据就是 先准备好打算存储的数据，然后访问数据库，将要存储的数据存入数据库就行了。整个过程都依赖相应数据库modules的API，看懂了API结合着操作几次，差不多就熟练了。我觉得这也没什么好说的。</p>\n<h2 class=\"heading subtitle heading\" id=\"node-sqlite3-简单的操作\" style=\"position:relative;\"><a href=\"#node-sqlite3-%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C\" aria-label=\"node sqlite3 简单的操作 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>node-sqlite3 简单的操作</h2>\n<blockquote class=\"quote\">\n<p class=\"para\">来自<a href=\"https://github.com/mapbox/node-sqlite3/wiki/API\" class=\"link-underline\">node sqlite3 wiki api</a></p>\n</blockquote>\n<h3 class=\"heading\" id=\"new-sqlite3Databasefilename-mode-callback\" style=\"position:relative;\"><a href=\"#new-sqlite3Databasefilename-mode-callback\" aria-label=\"new sqlite3Databasefilename mode callback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>new sqlite3.Database(filename, [mode], [callback])</h3>\n<p class=\"para\">返回一个新的Database对象，并且自动打开这个数据库。没有其他间接的方法来打开数据库。</p>\n<ul>\n<li><code>filename</code>： 正确的值是文件名，如果是“:memory:”，则在内存中创建一个匿名的数据库，匿名数据库不持久，关闭数据库程序之后内容就会消失。</li>\n<li><code>mode</code>：可选参数，可以是<code>sqlite3.OPEN_READONLY</code>, <code>sqlite3.OPEN_READWRITE</code> 和 <code>sqlite3.OPEN_CREATE</code>中的一个或者多个。默认值是 <code>OPEN_READWRITE | OPEN_CREATE</code>。</li>\n<li><code>callback</code>：可选参数，数据库成功打开或者打开时遇到错误调用，回调函数的第一个参数是一个err对象。当err对象为<code>null</code>时，数据库打开成功，此时触发一个没有参数的<code>open</code>事件，无论回调函数是否存在。</li>\n</ul>\n<h3 class=\"heading\" id=\"sqlite3verbose\" style=\"position:relative;\"><a href=\"#sqlite3verbose\" aria-label=\"sqlite3verbose permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>sqlite3.verbose()</h3>\n<p class=\"para\">设置执行模式。See the wiki page on <a href=\"https://github.com/developmentseed/node-sqlite3/wiki/Debugging\" class=\"link-underline\">debugging</a> for more information.</p>\n<h3 class=\"heading\" id=\"Databaseclosecallback\" style=\"position:relative;\"><a href=\"#Databaseclosecallback\" aria-label=\"Databaseclosecallback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Database#close([callback])</h3>\n<p class=\"para\">关闭数据库</p>\n<ul>\n<li><code>callback</code>：可选参数。当数据库成功关闭或者关闭时遇到错误调用。回调函数的第一个参数是一个err对象。当err对象为<code>null</code>时，数据库关闭成功，此时触发一个没有参数的<code>open</code>事件，无论回调函数是否存在。</li>\n</ul>\n<h2 class=\"heading subtitle heading\" id=\"Databaserunsql-param--callback\" style=\"position:relative;\"><a href=\"#Databaserunsql-param--callback\" aria-label=\"Databaserunsql param  callback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Database#run(sql, [param, …], [callback])</h2>\n<p class=\"para\">执行SQL语句，然后调用回调函数。返回的是一个Database对象，可以链式调用。</p>\n<ul>\n<li>\n<p class=\"para\"><code>sql</code>：执行的SQL语句。如果SQL语句无效，同时run方法有一个回调函数。回调函数将被调用，参数是一个包含错误信息的err对象。如果没有回调函数来处理错误，一个<code>error</code>事件会在影响到后面的数据库相关语句，导致其无法正常工作。</p>\n</li>\n<li>\n<p class=\"para\"><code>param, ...</code>：可选参数。当SQL语句包含占位符的时候，可以将参数在这里写出。在执行前，参数会被添加到语句中。有三种方式传递参数：直接作为函数的参数列举出来；以数组的形式；或者一个json对象。</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">      // Directly in the function arguments.\r\n      db.run(&quot;UPDATE tbl SET name = ? WHERE id = ?&quot;, &quot;bar&quot;, 2);\r\n\r\n      // As an array.\r\n      db.run(&quot;UPDATE tbl SET name = ? WHERE id = ?&quot;, [ &quot;bar&quot;, 2 ]);\r\n\r\n      // As an object with named parameters.\r\n      db.run(&quot;UPDATE tbl SET name = $name WHERE id = $id&quot;, {\r\n          $id: 2,\r\n          $name: &quot;bar&quot;\r\n      });</code>\n        </deckgo-highlight-code>\n<p class=\"para\">参数的键可以这么书写 <code>:name</code>, <code>@name</code> and <code>$name</code>. 建议使用 <code>$name</code>因为JS中允许使用$来声明变量。</p>\n<ul>\n<li><code>callback</code> ：可选参数。在语句执行的任何一个步骤出错和查询执行后都会调用这个函数。遇到错误时，第一个（只有一个）参数是一个包含错误信息的err对象。如果执行成功，第一个参数是<code>null</code>。函数的上下文（this）指向的是statement对象。在第一次运行之后无妨再次运行这个statement，因为在第一次运行之后它被自动销毁了。\r\n如果执行成功，this对象将包含两个属性：<code>lastID</code>和<code>changes</code>，这两个属性包含这最后插入的行的ID和这条语句影响的行数（如果它们都不是undefined的话）。执行INSERT才会有lastID，执行UPDATE和DELETE才会有changes。其他情况下，这两个属性的都是不准确的，不应该被使用。\r\n在查询方法总，只有<code>.run()</code>的回调函数才有这两个值，其他的比如<code>.all()</code>，<code>.get()</code>等都没有这些值。</li>\n</ul>\n<p class=\"para\">更多详情请戳<a href=\"https://github.com/mapbox/node-sqlite3/wiki/API\" class=\"link-underline\">这里</a></p>\n<p class=\"para\">Bye~下次再来……</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#connecting-to-database\">Connecting to Database</a></p>\n</li>\n<li>\n<p><a href=\"#storing-data-in-files\">Storing Data in Files</a></p>\n</li>\n<li>\n<p><a href=\"#node-sqlite3-%E7%AE%80%E5%8D%95%E7%9A%84%E6%93%8D%E4%BD%9C\">node-sqlite3 简单的操作</a></p>\n<ul>\n<li><a href=\"#new-sqlite3databasefilename-mode-callback\">new sqlite3.Database(filename, [mode], [callback])</a></li>\n<li><a href=\"#sqlite3verbose\">sqlite3.verbose()</a></li>\n<li><a href=\"#databaseclosecallback\">Database#close([callback])</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#databaserunsql-param--callback\">Database#run(sql, [param, …], [callback])</a></p>\n</li>\n</ul>","headings":[{"id":"Connecting-to-Database","depth":2,"value":"Connecting to Database"},{"id":"Storing-Data-in-Files","depth":2,"value":"Storing Data in Files"},{"id":"node-sqlite3-简单的操作","depth":2,"value":"node-sqlite3 简单的操作"},{"id":"new-sqlite3Databasefilename-mode-callback","depth":3,"value":"new sqlite3.Database(filename, [mode], [callback])"},{"id":"sqlite3verbose","depth":3,"value":"sqlite3.verbose()"},{"id":"Databaseclosecallback","depth":3,"value":"Database#close([callback])"},{"id":"Databaserunsql-param--callback","depth":2,"value":"Database#run(sql, [param, …], [callback])"}],"frontmatter":{"title":"Node学习笔记-Data Sources and Flow Control","date":"2014-11-06","cover":null,"description":null,"categories":["Node.js"],"tags":["笔记","Node.js"]}},"previous":{"fields":{"slug":"/blogs/Node学习笔记-Wrangling the File System/"},"frontmatter":{"title":"Node学习笔记-Wrangling the File System"}},"next":{"fields":{"slug":"/blogs/Node学习笔记-Server-Side Templates/"},"frontmatter":{"title":"Node学习笔记-Server-Side Templates","tags":["笔记","Node.js"],"categories":["Node.js"],"status":null}}},"pageContext":{"id":"f1d9670a-36de-599d-962c-35d000d9401a","previousPostId":"d757b860-334b-547e-9fb8-66da22479a1e","nextPostId":"6efe7f95-18fa-5e94-ab80-c16fa076dfa0"}},
    "staticQueryHashes": ["2841359383"]}