{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/浅谈TreeShaking在前端中的应用/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"851e2188-4c4b-5a9f-8e22-e734f76b7404","html":"<h2 class=\"heading subtitle heading\" id=\"前言\" style=\"position:relative;\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-label=\"前言 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>前言</h2>\n<p class=\"para\"><code>Tree Shaking</code>是一种死码清除(dead code elimination)技术，通常用于在ECMAScript方言比如Dart，JavaScript或者TypeScript打包成一个文件时，移除未使用的代码以此来优化代码。</p>\n<p class=\"para\">在动态语言中实现 <code>Dead code elimination</code> 要比在静态语言中实现难的多。<code>treeshaker</code> 这个概念最早在起源于1990年，来自LISP语言。这个技术主要核心点是，将程序中所有可能执行到的流用一个树形结构的函数调用来表示，这样那些从来不会调用的函数就可以清理</p>\n<p class=\"para\">在2012年的时候，Google 的 Bob Nystrom 开发的 closure compiler 就实现了这个算法，并应用在 Dart 的 dart2js compiler中。在Dart代码编译成JavaScript的过程中，编译器会做<code>tree shaking</code>。在JavaScript中，有时候就算你只使用了库中的一个函数，你也不得不将整个库引入到项目中，最后输出的文件会包含很多用不上的代码，体积大很多。而<code>tree shaking</code>技术就可以让输出的代码只包含你需要的函数。</p>\n<p class=\"para\">2015年的时候 Rollup推出了 <code>Tree Shaking</code> 功能，将这个概念真正带到了前端圈子中，随后 Webpack2 跟进也实现了 <code>Tree Shaking</code>，并在Webpack4中升级改进了方案</p>\n<h2 class=\"heading subtitle heading\" id=\"TreeShaking-的基本原理\" style=\"position:relative;\"><a href=\"#TreeShaking-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\" aria-label=\"TreeShaking 的基本原理 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TreeShaking 的基本原理</h2>\n<p class=\"para\">在编译器原理中，死码消除（Dead code elimination）是一种编译最佳化（Optimizing compiler）技术，它的用途是移除对程序执行结果没有任何影响的代码。移除这类代码可以减少程序的大小，避免执行过程中出现程序出现不相关的运算行为。无法执行的代码(unreachable code)， 执行结果不会被使用的代码和只会影响死变量（只写不读）的代码都属于 <code>Dead code</code>。</p>\n<p class=\"para\">对于JavaScript这种动态语言来说，TreeShaking的实现原本是一件相对较困难的事情。为何从Rollup开始能把这种技术带去前端圈子呢？因为ES6的模块特性。较早提出的CommonJS, AMD等规范都是动态的，模块的导入导出可以在运行时动态的变化。同时对于模块来说都是一个个对象，无论他们导出什么，都可以通过属性的方式来访问，比如:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const a = require(`./${file}.js/`) // 可以动态加载模块\nconst { stat, exists, readFile } = require(&#39;fs&#39;) // 解构导出的对象\nvar my_lib;\nif (Math.random()) {\n    my_lib = require(&#39;foo&#39;);\n} else {\n    my_lib = require(&#39;bar&#39;);\n}\n\nif (Math.random()) {\n    exports.baz = ···;\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">而ES6中的模块特性不同，它实现静态模块结构。在编译时就要确定导入和导出的内容，不允许在运行时发生变化。而正是这静态类型的特性，与 <code>Treeshaking</code> 无比契合。传统编译型的语言中，都是由编译器将 <code>Dead Code</code> 从 AST（抽象语法树）中删除。而在JavaScript中使用 <code>Rollup</code> 和 <code>Webpack</code> 都可以完成了这个任务。</p>\n<h2 class=\"heading subtitle heading\" id=\"Rollup\" style=\"position:relative;\"><a href=\"#Rollup\" aria-label=\"Rollup permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rollup</h2>\n<p class=\"para\">在 Rollup 中默认是启用treeshaking的。配置项中的 <code>treeshake</code> 默认为 <code>true</code>。包含其他一些选项，可按需配置。</p>\n<deckgo-highlight-code language=\"ts\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// src/rollup/typed.d.ts\nexport interface NormalizedInputOptions {\n  acorn: Object;\n  acornInjectPlugins: Function[];\n  cache: false | undefined | RollupCache;\n  context: string;\n  experimentalCacheExpiry: number;\n  external: IsExternal;\n  /** @deprecated Use the &quot;inlineDynamicImports&quot; output option instead. */\n  inlineDynamicImports: boolean | undefined;\n  input: string[] | { [entryAlias: string]: string };\n  /** @deprecated Use the &quot;manualChunks&quot; output option instead. */\n  manualChunks: ManualChunksOption | undefined;\n  moduleContext: (id: string) =&gt; string;\n  onwarn: WarningHandler;\n  perf: boolean;\n  plugins: Plugin[];\n  preserveEntrySignatures: PreserveEntrySignaturesOption;\n  /** @deprecated Use the &quot;preserveModules&quot; output option instead. */\n  preserveModules: boolean | undefined;\n  preserveSymlinks: boolean;\n  shimMissingExports: boolean;\n  strictDeprecations: boolean;\n  treeshake: false | NormalizedTreeshakingOptions;\n}\n\nexport interface NormalizedTreeshakingOptions {\n  annotations: boolean;\n  moduleSideEffects: HasModuleSideEffects;\n  propertyReadSideEffects: boolean;\n  tryCatchDeoptimization: boolean;\n  unknownGlobalSideEffects: boolean;\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><code>tresshake</code>这个参数主要影响两个地方：</p>\n<ol>\n<li>编译启动阶段<code>Graph</code>执行<code>build</code>方法时，过滤掉相应的Module，为剩余的Module创建AST的上下文</li>\n<li>编译过程会将<code>Module</code>中<code>getDependenciesToBeIncluded</code>方法返回的模块用作后续的chunk</li>\n</ol>\n<p class=\"para\">在Rollup的源码：<code>src/Graph.ts</code>中有一个<code>includeStatements</code>方法。</p>\n<p class=\"para\"><strong>src/Graph.ts</strong></p>\n<deckgo-highlight-code language=\"ts\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export default class Graph {\n  ...\n  async build(): Promise&lt;void&gt; {\n    timeStart(&#39;generate module graph&#39;, 2);\n    await this.generateModuleGraph();\n    timeEnd(&#39;generate module graph&#39;, 2);\n\n    timeStart(&#39;sort modules&#39;, 2);\n    this.phase = BuildPhase.ANALYSE;\n    this.sortModules();\n    timeEnd(&#39;sort modules&#39;, 2);\n\n    timeStart(&#39;mark included statements&#39;, 2);\n    this.includeStatements();\n    timeEnd(&#39;mark included statements&#39;, 2);\n\n    this.phase = BuildPhase.GENERATE;\n  }\n  ...\n  private includeStatements() {\n    for (const module of [...this.entryModules, ...this.implicitEntryModules]) {\n      if (module.preserveSignature !== false) {\n        module.includeAllExports();\n      } else {\n        markModuleAndImpureDependenciesAsExecuted(module);\n      }\n    }\n    if (this.options.treeshake) {\n      let treeshakingPass = 1;\n      do {\n        timeStart(`treeshaking pass ${treeshakingPass}`, 3);\n        this.needsTreeshakingPass = false;\n        for (const module of this.modules) {\n          if (module.isExecuted) module.include();\n        }\n        timeEnd(`treeshaking pass ${treeshakingPass++}`, 3);\n      } while (this.needsTreeshakingPass);\n    } else {\n      for (const module of this.modules) module.includeAllInBundle();\n    }\n    for (const externalModule of this.externalModules) externalModule.warnUnusedImports();\n    for (const module of this.implicitEntryModules) {\n      for (const dependant of module.implicitlyLoadedAfter) {\n        if (!(dependant.isEntryPoint || dependant.isIncluded())) {\n          error(errImplicitDependantIsNotIncluded(dependant));\n        }\n      }\n    }\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在 <code>if</code> 代码块中的 <code>module.include()</code> 和 <code>module.includeAllInBundle()</code> 做的事情很简单，就是</p>\n<deckgo-highlight-code language=\"ts\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export default class Module {\n  ...\n  includeAllInBundle() {\n  this.ast.include(createInclusionContext(), true);\n  }\n  ...\n  include(): void {\n  const context = createInclusionContext();\n  if (this.ast.shouldBeIncluded(context)) this.ast.include(context, false);\n  }\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在Rollup的源码：<code>src/Module.ts</code>中有一个<code>getDependenciesToBeIncluded</code>方法，这个方法返回最后code split 时需要使用的 module。</p>\n<p class=\"para\"><strong>src/Module.ts</strong></p>\n<deckgo-highlight-code language=\"ts\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export default class Module {\n  ...\n  getDependenciesToBeIncluded(): Set&lt;Module | ExternalModule&gt; {\n    if (this.relevantDependencies) return this.relevantDependencies;\n    const relevantDependencies = new Set&lt;Module | ExternalModule&gt;();\n    const additionalSideEffectModules = new Set&lt;Module&gt;();\n    const possibleDependencies = new Set(this.dependencies);\n    let dependencyVariables = this.imports;\n    if (this.isEntryPoint || this.includedDynamicImporters.length &gt; 0 || this.namespace.included) {\n      dependencyVariables = new Set(dependencyVariables);\n      for (const exportName of [...this.getReexports(), ...this.getExports()]) {\n        dependencyVariables.add(this.getVariableForExportName(exportName));\n      }\n    }\n    for (let variable of dependencyVariables) {\n      if (variable instanceof SyntheticNamedExportVariable) {\n        variable = variable.getBaseVariable();\n      } else if (variable instanceof ExportDefaultVariable) {\n        const { modules, original } = variable.getOriginalVariableAndDeclarationModules();\n        variable = original;\n        for (const module of modules) {\n          additionalSideEffectModules.add(module);\n          possibleDependencies.add(module);\n        }\n      }\n      relevantDependencies.add(variable.module!);\n    }\n    if (this.options.treeshake) {\n      for (const dependency of possibleDependencies) {\n        if (\n          !(\n            dependency.moduleSideEffects || additionalSideEffectModules.has(dependency as Module)\n          ) ||\n          relevantDependencies.has(dependency)\n        ) {\n          continue;\n        }\n        if (dependency instanceof ExternalModule || dependency.hasEffects()) {\n          relevantDependencies.add(dependency);\n        } else {\n          for (const transitiveDependency of dependency.dependencies) {\n            possibleDependencies.add(transitiveDependency);\n          }\n        }\n      }\n    } else {\n      for (const dependency of this.dependencies) {\n        relevantDependencies.add(dependency);\n      }\n    }\n    return (this.relevantDependencies = relevantDependencies);\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"Webpack\" style=\"position:relative;\"><a href=\"#Webpack\" aria-label=\"Webpack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Webpack</h2>\n<p class=\"para\">如果在Webpack想要对代码进行 tree-shaking，需要满足以下几项：</p>\n<ol>\n<li>你必须处于生产模式。Webpack 只有在压缩代码的时候会 tree-shaking</li>\n<li>必须将优化选项 <code>usedExports</code> 设置为 <code>true</code>。告诉 Webpack 识别出它认为没有被使用的代码，并在最初的打包步骤中给它做标记。</li>\n<li>最后使用一个支持删除死代码的压缩器。这种压缩器将识别出 Webpack 是如何标记它认为没有被使用的代码，并将其剥离。<code>TerserPlugin</code> 支持这个功能</li>\n</ol>\n<p class=\"para\">下面是 Webpack 开启  tree-shaking 的基本配置：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// Base Webpack Config for Tree Shaking\nconst config = {\n  mode: &#39;production&#39;,\n  optimization: {\n    usedExports: true,\n    minimizer: [\n      new TerserPlugin({...})\n    ]\n  }\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\">以webpack官网文档中的demo为例，当开始生产环境模式时，打包输出的内容会包含<code>unused harmony export</code>，以此来标记没有被使用的代码</p>\n<p class=\"para\"><strong>src/index.js</strong></p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">import _ from &#39;lodash&#39;;\nimport { cube } from &#39;./math.js&#39;;\n\nfunction component() {\n  const element = document.createElement(&#39;div&#39;);\n  const element = document.createElement(&#39;pre&#39;);\n\n  // Lodash, now imported by this script\n  element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);\n  element.innerHTML = [\n    &#39;Hello webpack!&#39;,\n    &#39;5 cubed is equal to &#39; + cube(5)\n  ].join(&#39;\\n\\n&#39;);\n\n  return element;\n}\n\ndocument.body.appendChild(component());</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><strong>dist/bundle.js</strong></p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n  &#39;use strict&#39;;\n  /* unused harmony export square */\n  /* harmony export (immutable) */ __webpack_exports__[&#39;a&#39;] = cube;\n  function square(x) {\n    return x * x;\n  }\n\n  function cube(x) {\n    return x * x * x;\n  }\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">然后再通过 <code>Terser-Webpack-Plugin</code> 压缩代码，将标记为未使用的代码删除。接下来我们看看这两个过程具体的代码实现。</p>\n<p class=\"para\">在源码的 <code>lib/optimize.js</code>中，会先定义一个Set，保存所有暴露出来的未使用的exports</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// Set with all root exposed unused exports\n/** @type {Set&lt;string&gt;} */\nconst unusedExports = new Set();</code>\n        </deckgo-highlight-code>\n<p class=\"para\">接下来遍历保存在<code>rootModule</code>中的所有<code>HarmonyExportSpecifierDependency</code>依赖，将没有使用的依赖名称保存到 <code>unusedExports</code></p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">for (const dep of this.rootModule.dependencies) {\n  if (dep instanceof HarmonyExportSpecifierDependency) {\n    const used = /** @type {string | false } */ (this.rootModule.getUsedName(\n      moduleGraph,\n      dep.name\n    ));\n    if (used) {\n      const info = moduleToInfoMap.get(this.rootModule);\n      if (!exportsMap.has(used)) {\n        exportsMap.set(\n          used,\n          () =&gt; `/* binding */ ${info.internalNames.get(dep.id)}`\n        );\n      }\n    } else {\n      unusedExports.add(dep.name || &quot;namespace&quot;);\n    }\n  } else if (dep instanceof HarmonyExportExpressionDependency) {\n    const used = /** @type {string | false } */ (this.rootModule.getUsedName(\n      moduleGraph,\n      &quot;default&quot;\n    ));\n    if (used) {\n      const info = moduleToInfoMap.get(this.rootModule);\n      if (!exportsMap.has(used)) {\n        exportsMap.set(\n          used,\n          () =&gt;\n            `/* default */ ${info.internalNames.get(\n              typeof dep.declarationId === &quot;string&quot;\n                ? dep.declarationId\n                : &quot;__WEBPACK_MODULE_DEFAULT_EXPORT__&quot;\n            )}`\n        );\n      }\n    } else {\n      unusedExports.add(&quot;default&quot;);\n    }\n  } else if (dep instanceof HarmonyExportImportedSpecifierDependency) {\n    const exportDefs = getHarmonyExportImportedSpecifierDependencyExports(\n      dep,\n      moduleGraph\n    );\n    for (const def of exportDefs) {\n      const importedModule = moduleGraph.getModule(dep);\n      const info = moduleToInfoMap.get(importedModule);\n      const used = /** @type {string | false } */ (this.rootModule.getUsedName(\n        moduleGraph,\n        def.name\n      ));\n      if (used) {\n        if (!exportsMap.has(used)) {\n          exportsMap.set(used, requestShortener =&gt; {\n            const finalName = getFinalName(\n              moduleGraph,\n              info,\n              def.ids,\n              moduleToInfoMap,\n              requestShortener,\n              runtimeTemplate,\n              false,\n              false,\n              this.rootModule.buildMeta.strictHarmonyModule,\n              true\n            );\n            return `/* reexport */ ${finalName}`;\n          });\n        }\n      } else {\n        unusedExports.add(def.name);\n      }\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在 <code>lib/dependencies/HarmonyExportInitFragment.js</code> 和 <code>lib/dependencies/HarmonyExportExpressionDependency.js</code> 都有打标记的操作</p>\n<p class=\"para\"><strong>lib/dependencies/HarmonyExportInitFragment.js</strong></p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">/**\n * @param {GenerateContext} generateContext context for generate\n * @returns {string|Source} the source code that will be included as initialization code\n */\ngetContent({ runtimeTemplate, runtimeRequirements }) {\n  runtimeRequirements.add(RuntimeGlobals.exports);\n  runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);\n\n  const unusedPart =\n    this.unusedExports.size &gt; 1\n      ? `/* unused harmony exports ${joinIterableWithComma(\n        this.unusedExports\n      )} */\\n`\n      : this.unusedExports.size &gt; 0\n        ? `/* unused harmony export ${\n        this.unusedExports.values().next().value\n        } */\\n`\n        : &quot;&quot;;\n  const definitions = [];\n  for (const [key, value] of this.exportMap) {\n    definitions.push(\n      `\\n/* harmony export */   ${JSON.stringify(\n        key\n      )}: ${runtimeTemplate.returningFunction(value)}`\n    );\n  }\n  const definePart =\n    this.exportMap.size &gt; 0\n      ? `/* harmony export */ ${RuntimeGlobals.definePropertyGetters}(${\n      this.exportsArgument\n      }, {${definitions.join(&quot;,&quot;)}\\n/* harmony export */ });\\n`\n      : &quot;&quot;;\n  return `${definePart}${unusedPart}`;\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><strong>lib/dependencies/HarmonyExportExpressionDependency.js</strong></p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">\nHarmonyExportExpressionDependency.Template = class HarmonyExportDependencyTemplate extends NullDependency.Template {\n  /**\n   * @param {Dependency} dependency the dependency for which the template should be applied\n   * @param {ReplaceSource} source the current replace source which can be modified\n   * @param {DependencyTemplateContext} templateContext the context object\n   * @returns {void}\n   */\n  apply(\n    dependency,\n    source,\n    { module, moduleGraph, runtimeTemplate, runtimeRequirements, initFragments }\n  ) {\n    const dep = /** @type {HarmonyExportExpressionDependency} */ (dependency);\n    const used = module.getUsedName(moduleGraph, &quot;default&quot;);\n    const { declarationId } = dep;\n    const exportsName = module.exportsArgument;\n    if (declarationId) {\n      let name;\n      if (typeof declarationId === &quot;string&quot;) {\n        name = declarationId;\n      } else {\n        name = &quot;__WEBPACK_DEFAULT_EXPORT__&quot;;\n        source.replace(\n          declarationId.range[0],\n          declarationId.range[1] - 1,\n          `${declarationId.prefix}${name}${declarationId.suffix}`\n        );\n      }\n\n      if (used) {\n        const map = new Map();\n        map.set(used, `/* export default binding */ ${name}`);\n        initFragments.push(new HarmonyExportInitFragment(exportsName, map));\n      }\n\n      source.replace(\n        dep.rangeStatement[0],\n        dep.range[0] - 1,\n        `/* harmony default export */ ${dep.prefix}`\n      );\n    } else {\n      let content;\n      if (used) {\n        runtimeRequirements.add(RuntimeGlobals.exports);\n        if (runtimeTemplate.supportsConst()) {\n          const name = &quot;__WEBPACK_DEFAULT_EXPORT__&quot;;\n          content = `/* harmony default export */ const ${name} = `;\n          const map = new Map();\n          map.set(used, name);\n          initFragments.push(new HarmonyExportInitFragment(exportsName, map));\n        } else {\n          // This is a little bit incorrect as TDZ is not correct, but we can&#39;t use const.\n          content = `/* harmony default export */ ${exportsName}[${JSON.stringify(\n            used\n          )}] = `;\n        }\n      } else {\n        content =\n          &quot;/* unused harmony default export */ var _unused_webpack_default_export = &quot;;\n      }\n\n      if (dep.range) {\n        source.replace(\n          dep.rangeStatement[0],\n          dep.range[0] - 1,\n          content + &quot;(&quot; + dep.prefix\n        );\n        source.replace(dep.range[1], dep.rangeStatement[1] - 0.5, &quot;);&quot;);\n        return;\n      }\n\n      source.replace(dep.rangeStatement[0], dep.rangeStatement[1] - 1, content);\n    }\n  }\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><code>Terser-Webpack-plugin</code> 和 <code>Terser</code> 还未找到相关剔除代码的标记</p>\n<h2 class=\"heading subtitle heading\" id=\"总结\" style=\"position:relative;\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-label=\"总结 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h2>\n<p class=\"para\">虽然还没有完全理清楚Webpack中treeshaking在代码层面的具体逻辑，但是对比可以看到。Rollup采用的是先分析，然后找到需要的代码，最后再打包。而webpack则是先打标记，最后再剔除，比较符合标准的DCE的操作</p>","tableOfContents":"<ul>\n<li><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></li>\n<li><a href=\"#treeshaking-%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\">TreeShaking 的基本原理</a></li>\n<li><a href=\"#rollup\">Rollup</a></li>\n<li><a href=\"#webpack\">Webpack</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n</ul>","headings":[{"id":"前言","depth":2,"value":"前言"},{"id":"TreeShaking-的基本原理","depth":2,"value":"TreeShaking 的基本原理"},{"id":"Rollup","depth":2,"value":"Rollup"},{"id":"Webpack","depth":2,"value":"Webpack"},{"id":"总结","depth":2,"value":"总结"}],"frontmatter":{"title":"浅谈TreeShaking在前端中的应用 - Rollup VS Webpack","date":"2019-11-14","cover":null,"description":null,"categories":[],"tags":[]}},"previous":{"fields":{"slug":"/blogs/2020-01-16-为Promise增加abort方法/"},"frontmatter":{"title":"为Promise增加abort方法"}},"next":{"fields":{"slug":"/blogs/2019-10-09-JavaScript异步编程方案回顾/"},"frontmatter":{"title":"JavaScript异步编程方案回顾","tags":["JavaScrtipt"],"categories":["技术学习"],"status":null}}},"pageContext":{"id":"851e2188-4c4b-5a9f-8e22-e734f76b7404","previousPostId":"f8fdb2ed-e1d8-5fd3-ad61-01d72a338c44","nextPostId":"f06adf32-8be0-5302-9ef5-1934d9f7b5ad"}},
    "staticQueryHashes": ["2841359383"]}