{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/Node学习笔记-Serving the content/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"f1cda0b7-0c5c-5abb-8d56-12a49068aa58","html":"<h2 class=\"heading subtitle heading\" id=\"Node中的MiddleWare\" style=\"position:relative;\"><a href=\"#Node%E4%B8%AD%E7%9A%84MiddleWare\" aria-label=\"Node中的MiddleWare permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node中的MiddleWare</h2>\n<blockquote class=\"quote\">\n<p class=\"para\">In the context of a web server, middleware is a layer between the guts</p>\n</blockquote>\n<p class=\"para\">of the server and the code you’re writing to run on it that provides a set\r\nof abstractions anyone writing code for the platform will be likely to\r\nneed. It differs from other modules you might pull into your application\r\nin that it exists as a buffer between Node and your app, not a utility used\r\nwithin your app.</p>\n<p class=\"para\">在一个Web服务器的上下文中，中间件是服务器和你写在其上运行的代码的中间一层，为那些编写代码的人提供一组抽象（a set of abstractions）。它不同于其他那些引入到你的应用中的模块，middleware作为一个缓存区存在于Node与你的应用之间，</p>\n<p class=\"para\">Connect 是最受欢迎的Node中间件框架，为其他的web 框架比如Express提供了基础。Connect提供的工具之一就是 static 模块，用于处理静态文件，如果我们添加了Connect，对静态文件的引用可以酱紫：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var connect = require(&#39;connect&#39;);\r\nvar app = connect();\r\n\r\napp.use(function middleware1(req, res, next) {\r\n  // middleware 1\r\n  next();\r\n});\r\n\r\napp.use(function middleware2(req, res, next) {\r\n  // middleware 2\r\n  next();\r\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><a href=\"https://github.com/senchalabs/connect\" class=\"link-underline\">Github:</a></p>\n<h2 class=\"heading subtitle heading\" id=\"Receiving-Data-from-the-Querystring\" style=\"position:relative;\"><a href=\"#Receiving-Data-from-the-Querystring\" aria-label=\"Receiving Data from the Querystring permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Receiving Data from the Querystring</h2>\n<p class=\"para\">向服务端传送数据最简单的办法就是在url中添加querystring，这种方式不需要在客户端做太多操作。</p>\n<p class=\"para\">Node官方提供了一个叫做<code>querystring</code>的模块，我们不需要做太多的工作就能够很轻松的解析出querystring中的数据，我们要做的一件事请就是“trim the querystring”，因为querystring模块提供了解析querystring字段的方法<code>parse()</code>,当时没有已经将querystring从URl中分离出来。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var http = require(&quot;http&quot;),\r\nquerystring = require(&quot;querystring&quot;);\r\nhttp.createServer(function(req, res) {\r\n    // parse everything after the &quot;?&quot; into key/value pairs\r\n    var qs = querystring.parse(req.url.split(&quot;?&quot;)[1]),\r\n    // property names are the same as in the querystring\r\n    userName = qs.firstName + &quot; &quot; + qs.lastName,\r\n    html = &quot;&lt;!doctype html&gt;&quot; +\r\n    &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello &quot; + userName + &quot;&lt;/title&gt;&lt;/head&gt;&quot; +\r\n    &quot;&lt;body&gt;&lt;h1&gt;Hello, &quot; + userName + &quot;!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;;\r\n    res.end(html);\r\n}).listen(8000);</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"Routing-and-Receiving-Data-from-a-Path\" style=\"position:relative;\"><a href=\"#Routing-and-Receiving-Data-from-a-Path\" aria-label=\"Routing and Receiving Data from a Path permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Routing and Receiving Data from a Path</h2>\n<p class=\"para\"><code>Routing</code>是中间件提供的另一个功能，但是自己实现起来也不是很复杂。Routing可以让我们解析出除了querystring之外的URL路径中的数据。一个最简单的route包含三个部分：一个request方法；一个route匹配的模式（正则表达式）和一个请求匹配成功时调用的回调函数。</p>\n<p class=\"para\">要解析URL，必须引入URL模块</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var url = require(&quot;url&quot;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">前面讲到的使用querystring的例子，可以修改成Route版，通过检查URL来寻找信息。假设我们的路径是“sayhello/firstname/lastname”</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var http = require(&quot;http&quot;),\r\n    url = require(&quot;url&quot;);\r\nhttp.createServer(function(req, res) {\r\n    // split out parts of the path\r\n    var path = url.parse(req.url).pathname.split(&quot;/&quot;);\r\n    // handle GET requests to /sayHello/\r\n\r\n    if (req.method == &quot;GET&quot; &amp;&amp; path[1] == &quot;sayHello&quot;) {\r\n        var userName = path[2] + &quot; &quot; + path[3],\r\n        html = &quot;&lt;!doctype html&gt;&quot; +\r\n        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello &quot; + userName + &quot;&lt;/title&gt;&lt;/head&gt;&quot; +\r\n        &quot;&lt;body&gt;&lt;h1&gt;Hello, &quot; + userName + &quot;!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;;\r\n        res.end(html);\r\n    }\r\n}).listen(8000);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">但是可以看到这样的代码是多么的不健壮，根本没有拓展性可言。我们可以使用Connect来提高代码的可用性。</p>\n<h2 class=\"heading subtitle heading\" id=\"Receiving-Data-from-a-POST\" style=\"position:relative;\"><a href=\"#Receiving-Data-from-a-POST\" aria-label=\"Receiving Data from a POST permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Receiving Data from a POST</h2>\n<p class=\"para\">最传统的获取用户数据的方式就是接受来自表单的一个POST请求，这可能不是你使用Node时做的第一件事，但是这个还是一件很必要的事情。亲自尝试使用Node处理POST请求时，可以很好的感受到Node与其他服务端开发的不同之处。<code>ServerRequest</code> 对象（回调函数中的req参数）的属性，没有包含POST传递过来的参数，但是它是一个<code>EventEmitter</code>-事件发射器。它是Node中的一个基本的对象，其作用就像它的名字一样-发射事件。我们不是去检查req的属性是否含有传递过来的数据，而是添加一个事件监听器来监听请求。</p>\n<p class=\"para\">所有的事件发射器的监听器，包括<code>ServerRequest</code>的监听器，都通过 on() 创建，这个方法至少需要一个事件的类型和一个回调函数作为参数（addListener()方法也是一样）。请求的数据将会出现在chunk中，我们不用等待接收完所有的数据就可执行后面的代码。现在，创建一个监听器，用于数据的接受，请求的结束和保存所有的数据块。但是只有在请求完成之后才能显示数据。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var http = require(&quot;http&quot;),\r\n    fs = require(&quot;fs&quot;),\r\n    querystring = require(&quot;querystring&quot;);\r\n    http.createServer(function(req, res) {\r\n    var data = &quot;&quot;;\r\n    // serve static form\r\n    if (req.method == &quot;GET&quot;) {\r\n        getFile(__dirname + &quot;/public/simpleForm.html&quot;, res);\r\n    }\r\n    // handle form post\r\n    if (req.method == &quot;POST&quot;) {\r\n        req.on(&quot;data&quot;, function(chunk) {\r\n            // append received data\r\n            data += chunk;\r\n        });\r\n        req.on(&quot;end&quot;, function() {\r\n            // get key/value pairs from received data\r\n            var params = querystring.parse(data),\r\n            userName = params.firstName + &quot; &quot; + params.lastName,\r\n            html = &quot;&lt;!doctype html&gt;&quot; +\r\n            &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello &quot; + userName + &quot;&lt;/title&gt;&lt;/head&gt;&quot; +\r\n            &quot;&lt;body&gt;&lt;h1&gt;Hello, &quot; + userName + &quot;!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;;\r\n            res.end(html);\r\n        });\r\n    }\r\n}).listen(8000);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">同样的我们也可以利用中间件来完成，可以使用 <code>bodyParse</code>。</p>","tableOfContents":"<ul>\n<li><a href=\"#node%E4%B8%AD%E7%9A%84middleware\">Node中的MiddleWare</a></li>\n<li><a href=\"#receiving-data-from-the-querystring\">Receiving Data from the Querystring</a></li>\n<li><a href=\"#routing-and-receiving-data-from-a-path\">Routing and Receiving Data from a Path</a></li>\n<li><a href=\"#receiving-data-from-a-post\">Receiving Data from a POST</a></li>\n</ul>","headings":[{"id":"Node中的MiddleWare","depth":2,"value":"Node中的MiddleWare"},{"id":"Receiving-Data-from-the-Querystring","depth":2,"value":"Receiving Data from the Querystring"},{"id":"Routing-and-Receiving-Data-from-a-Path","depth":2,"value":"Routing and Receiving Data from a Path"},{"id":"Receiving-Data-from-a-POST","depth":2,"value":"Receiving Data from a POST"}],"frontmatter":{"title":"Node学习笔记-Serving the content","date":"2014-10-28","cover":null,"description":null,"categories":["Node.js"],"tags":["笔记","Node.js"]}},"previous":{"fields":{"slug":"/blogs/Node学习笔记-Server-Side Templates/"},"frontmatter":{"title":"Node学习笔记-Server-Side Templates"}},"next":{"fields":{"slug":"/blogs/规范之路-重新认识了Float/"},"frontmatter":{"title":"规范之路-重新认识了Float","tags":["CSS","笔记"],"categories":["重构"],"status":null}}},"pageContext":{"id":"f1cda0b7-0c5c-5abb-8d56-12a49068aa58","previousPostId":"6efe7f95-18fa-5e94-ab80-c16fa076dfa0","nextPostId":"fce9dcca-84b1-5a5c-8ca2-c95cb04054e3"}},
    "staticQueryHashes": ["2841359383"]}