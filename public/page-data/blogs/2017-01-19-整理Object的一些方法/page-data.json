{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2017-01-19-整理Object的一些方法/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"b6062132-dfe5-546f-ada7-2301582a1586","html":"<p class=\"para\">ES5 和 ES6 中 Object 添加了很多新的方法，现在很多开源代码中有用到了这些，今天来整理一番。</p>\n<!--more-->\n<h3 class=\"heading\" id=\"Objectassign\" style=\"position:relative;\"><a href=\"#Objectassign\" aria-label=\"Objectassign permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.assign()</h3>\n<p class=\"para\">这是ES6新添加的方法，<code>Object.assign()</code>用来复制源对象的所有可枚举属性复制到目标对象中，方法返回目标对象。语法如下：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">Object.assign(target, ...source);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">source对象可以有很多个，比如：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let target = {name: &#39;target&#39;};\nlet source1 = {age: 23};\nlet source2 = {email: &#39;zhanglun1410@gmail.com&#39;};\n// ...\n// let sourceN ={.....};\ntraget = Object.assign(target, source1, source2);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">如果源对象和目标对象的属性的key相同，目标对象的属性将会被源对象中的属性覆盖。对于多个源对象来说，如果有相同的key，右边的属性将覆盖左边的属性。这个方法只能将源对象的可枚举对象和自己的属性复制给目标对象。</p>\n<blockquote class=\"quote\">\n<p class=\"para\">什么是可枚举对象（）？\n可枚举属性是指那些内部 “可枚举” 标志设置为true的属性，对于通过直接的赋值和属性初始化的属性，该标识值默认为即为true，对于通过Object.defineProperty等定义的属性，该标识值默认为false。可枚举的属性可以通过 for…in 循环进行遍历（除非该属性名是一个 Symbol）。</p>\n</blockquote>\n<p class=\"para\">对于源对象，Object.assign使用[[Get]]，而在目标对象上使用[[Set]]，也就是说，使用这个方法会源对象的getter和目标对象的setters。所以其本质就是定义或者复制一个新的属性。如果等待合并的源对象包含了getters，那就不太适合用来将源对象合并到原型中。假如复制的属性到原型里，包括它们的可枚举属性，那么应该使用 Object.getOwnPropertyDescriptor() 和 Object.defineProperty() 。String 和 Symbol 属性都是会被复制的。</p>\n<p class=\"para\">如果遇到了一个错误，比如目标对象的某个属性是不可修改的，会抛出一个TypeError的错误吗，目标对象保持不变</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var foo = {}\nObject.defineProperty(foo, &#39;name&#39;, {\n  writable: false,\n  value: &#39;zhanglun&#39;\n});\nObject.assign(foo, {name: &#39;zhangxiaolun&#39;}); // TypeError: Cannot assign to read only property &#39;1&#39; of object &#39;#&lt;Object&gt;&#39;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">如果源对象是null或者undefined，Object.assign()不会抛出错误：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var foo = {name: &#39;zhanglun&#39;};\nObject.assign(foo, null, undefined);\nconsole.log(foo); // foo: {name: &#39;zhanglun&#39;}</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"Objectcreate\" style=\"position:relative;\"><a href=\"#Objectcreate\" aria-label=\"Objectcreate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.create()</h3>\n<p class=\"para\">通过指定的原型对象和属性，创建一个新的对象。语法如下：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">Object.create(proto, [,. propertiesObject]);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">第一个参数是一个对象，可以是一个普通的对象，比如：<code>{name: 'zhanglun'}</code>，也可以是一个新创建的对象的原型（prototype），比如：new Array().prototype。无论是那种，都是 JavaScript 中的 Object，其属性都被添加到返回的对象原型中；第二个参数是可选的，但是不能是<code>undefined</code>，该对象自身拥有的可枚举属性会被添加到新创建的对象上，其原型链上的属性是无效的。如果第一个参数不是null或者一个对象值，将会抛出TypeError异常。</p>\n<p class=\"para\">Object.create()最直接的作用是基于一个对象创建新的对象，更多时候用在了原型链继承上，先来看看 JavaScript\n中创建对象的几种方法：</p>\n<ul>\n<li>对象字面量</li>\n</ul>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var o = {a: 1};\n\n// o这个对象继承了Object.prototype上面的所有属性\n// 所以可以这样使用 o.hasOwnProperty(&#39;a&#39;).\n// hasOwnProperty 是Object.prototype的自身属性。\n// Object.prototype的原型为null。\n// 原型链如下:\n// o ---&gt; Object.prototype ---&gt; null\n\nvar a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;];\n\n// 数组都继承于Array.prototype \n// (indexOf, forEach等方法都是从它继承而来).\n// 原型链如下:\n// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null\n\nfunction f(){\n  return 2;\n}\n\n// 函数都继承于Function.prototype\n// (call, bind等方法都是从它继承而来):\n// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</code>\n        </deckgo-highlight-code>\n<ul>\n<li>构造函数</li>\n</ul>\n<p class=\"para\">在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。如果没有 new 关键字而是直接调用的话，相当于是在当前作用域上调用，此时函数中如果有 this 的话，this 指向的是当前作用域。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function Graph() {\n  this.vertexes = [];\n  this.edges = [];\n}\n\nGraph.prototype = {\n  addVertex: function(v){\n    this.vertexes.push(v);\n  }\n};\n\nvar g = new Graph();\n// g是生成的对象,他的自身属性有&#39;vertices&#39;和&#39;edges&#39;.\n// 在g被实例化时,g.[[Prototype]]指向了Graph.prototype.\nGraph();\nconsole.log(window.vertexes); // 在全局作用域中调用，意外地增加了全局变量</code>\n        </deckgo-highlight-code>\n<ul>\n<li>使用 Object.create()</li>\n</ul>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var a = {a: 1}; \n// a ---&gt; Object.prototype ---&gt; null\n\nvar b = Object.create(a);\n// b ---&gt; a ---&gt; Object.prototype ---&gt; null\nconsole.log(b.a); // 1 (继承而来)\n\nvar c = Object.create(b);\n// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null\n\nvar d = Object.create(null);\n// d ---&gt; null\nconsole.log(d.hasOwnProperty); // undefined, 因为d没有继承Object.prototype</code>\n        </deckgo-highlight-code>\n<ul>\n<li>ES6 中的 Class 关键字</li>\n</ul>\n<p class=\"para\">ES6 引入了一套新的关键字用来实现 class。这是一个语法糖，其本质还是基于原型的。这些新的关键字包括 class, constructor, static, extends, 和 super。关于 Class的使用，回头再开一篇文章深入学习。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&quot;use strict&quot;;\n\nclass Polygon {\n  constructor(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nclass Square extends Polygon {\n  constructor(sideLength) {\n    super(sideLength, sideLength);\n  }\n  get area() {\n    return this.height * this.width;\n  }\n  set sideLength(newLength) {\n    this.height = newLength;\n    this.width = newLength;\n  }\n}\n\nvar square = new Square(2);</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"使用-Objectcreate-实现继承\" style=\"position:relative;\"><a href=\"#%E4%BD%BF%E7%94%A8-Objectcreate-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF\" aria-label=\"使用 Objectcreate 实现继承 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>使用 Object.create() 实现继承</h4>\n<p class=\"para\">下面是一个使用 Object.create()实现类的继承的例子。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\n// 父类的原型方法\nShape.prototype.move = function(x, y) {\n  this.x += x;\n  this.y += y;\n  console.info(&#39;Shape moved.&#39;);\n};\n\n// 子类\nfunction Rectangle() {\n  Shape.call(this); // 调用构造函数\n}\n\n// 子类继承父类\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n\nvar rect = new Rectangle();\n\nconsole.log(&#39;Is rect an instance of Rectangle?&#39;, rect instanceof Rectangle);// true\nconsole.log(&#39;Is rect an instance of Shape?&#39;, rect instanceof Shape);// true\nrect.move(1, 1); // Outputs, &#39;Shape moved.&#39;</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"Objectcreate-VS-new\" style=\"position:relative;\"><a href=\"#Objectcreate-VS-new\" aria-label=\"Objectcreate VS new permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.create VS new</h4>\n<p class=\"para\">前面说到的，Object.create实际上是将第一个参数（无论是原型对象还是普通对象）的属性添加到新创建对象的原型中，这也就意味着，通过<code>new Function()</code>中定义的属性和方法是无法通过 create()方法添加到新创建对象中的。</p>\n<p class=\"para\">Object.create创建一个新的对象，这个对象“继承”了第一个参数。构造函数新创建的对象“继承”构造函数的prototype。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let o = new SomeConstructor();  // o 直接继承自`SomeConstructor.prototype`。</code>\n        </deckgo-highlight-code>\n<p class=\"para\">两者的最明显的不同之处在于：如果 Object.create()的第一个参数是<code>null</code>，新创建的对象不会“继承”自任何地方，没有原型，也没有往上追溯的原型；在使用构造函数时，如果将其原型设置为 null，<code>SomeConstructor.prototype = null;</code>，新创建的对象将会“继承”自 Object 的 prototype。</p>\n<h3 class=\"heading\" id=\"Objectfreeze\" style=\"position:relative;\"><a href=\"#Objectfreeze\" aria-label=\"Objectfreeze permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.freeze()</h3>\n<p class=\"para\">字面意思就是将一个 object“冻住”：不能添加新的属性；不能删除现有的属性；不能修改现有属性，包括属性的enumerability, configurability和 writability。这个方法返回一个不可修改的对象，使用语法：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">Object.freeze(obj)</code>\n        </deckgo-highlight-code>\n<p class=\"para\">任何尝试修改该对象的操作都会失败，可能是静默失败，也可能会抛出异常。在严格模式中会抛出异常（本地测试下来严格模式也不会报错）。数据属性的值不可更改，访问器属性（有getter和setter）也同样，但由于是函数调用，给人一种修改了这个属性的错觉。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let foo = {\n  name: &#39;zhanglun&#39;,\n  age: 23,\n}\n\nconsole.log(foo.name); // &#39;zhanglun&#39;\nconsole.log(foo.age); // 23\n\nfoo.name = &#39;zhanglun1410&#39;;\nfoo.age = 24;\n\nconsole.log(foo.name); // &#39;zhanglun1410&#39;\nconsole.log(foo.age); // 24\n\nObject.freeze(foo);\n\nfoo.name = &#39;zzzz&#39;; // 静默失败\nconsole.log(foo.name); // &#39;zhanglun1410&#39;\n\n&#39;use strict&#39;;\nfoo.name = &#39;zzzz&#39;; // TypeError 或者 静默失败\nconsole.log(foo.name); // &#39;zhanglun1410&#39;</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"Objectfreeze-VS-const\" style=\"position:relative;\"><a href=\"#Objectfreeze-VS-const\" aria-label=\"Objectfreeze VS const permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.freeze VS const</h4>\n<p class=\"para\">被冻结的对象是不可改变的。但是它不一定是常量。对常量而言，它的所有引用，无论是直接的还是间接的都是引用的不可改变的对象。string，number，和 boolean 总是不可变的（当你把一个变量从字符串 A 修改到字符串 B时，A 和 B 都是不可变的，A 还是 A，B 也还是 B，只不过变量的之前指向的是 A,修改之后指向了 B）。通常来说，一般不会创建一个对象常量，也不存在freezeAll()这样的方法。</p>\n<p class=\"para\">const 用于声明常量，将变量绑定到一个不可修改的对象，常量最终指向的是一个不可修改的对象，比如一个被冻结的对象，而 Object.freeze 作用在对象的值上，将一个对象变成不可修改的对象。</p>\n<h4 class=\"heading\" id=\"深度冻结对象\" style=\"position:relative;\"><a href=\"#%E6%B7%B1%E5%BA%A6%E5%86%BB%E7%BB%93%E5%AF%B9%E8%B1%A1\" aria-label=\"深度冻结对象 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>深度冻结对象</h4>\n<p class=\"para\">前面提到的，Object.freeze作用在对象的属性上，使对象的属性不可修改。而如果属性值也是一个对象的话，依然能够修改，除非这个对象也被冻结了。因此，可以把 Object.freeze 理解成是“浅冻结”。可以编写额外的代码来实现“深冻结”：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">obj1 = {\n  internal: {}\n};\n\nObject.freeze(obj1);\nobj1.internal.a = &#39;aValue&#39;;\n\nobj1.internal.a // &#39;aValue&#39;\n\n// 深度冻结\nfunction deepFreeze(obj) {\n\n  // 获取到对象的属性的名字\n  var propNames = Object.getOwnPropertyNames(obj);\n\n  // 先冻结内部的对象\n  propNames.forEach(function(name) {\n    var prop = obj[name];\n\n    // Freeze prop if it is an object\n    if (typeof prop == &#39;object&#39; &amp;&amp; prop !== null)\n      deepFreeze(prop);\n  });\n\n  // 冻结 obj\n  return Object.freeze(obj);\n}\n\nobj2 = {\n  internal: {}\n};\n\ndeepFreeze(obj2);\nobj2.internal.a = &#39;anotherValue&#39;;\nobj2.internal.a; // undefined</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"Objectfreeze-的注意事项\" style=\"position:relative;\"><a href=\"#Objectfreeze-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\" aria-label=\"Objectfreeze 的注意事项 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.freeze 的注意事项</h4>\n<p class=\"para\">在 ES5 中，如果参数不是一个对象，是一个原始数据类型，会抛出 TypeError。在 ES6 中，不是对象的参数的会被当做是一个已经被冻结的普通对象，只是返回这个参数。</p>\n<h3 class=\"heading\" id=\"ObjectdefineProperty\" style=\"position:relative;\"><a href=\"#ObjectdefineProperty\" aria-label=\"ObjectdefineProperty permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.defineProperty()</h3>\n<p class=\"para\">Object.defineProperty是ES5新增的一个方法，可以给对象的属性增加更多的控制。语法如下：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">Object.defineProperty(obj, prop, descriptor)</code>\n        </deckgo-highlight-code>\n<p class=\"para\">前面两个参数很简单，修改的对象和修改或者新增的属性，着重介绍一下第三个参数：属性描述符。</p>\n<p class=\"para\">ES5 中定义了一个名叫“属性描述符”的对象，用于描述了的各种特征，它本身是一个 Object。属性描述符对象有4个属性：</p>\n<ul>\n<li>configurable：可配置性，控制着其描述的属性的修改，表示能否修改属性的特性，能否把属性修改为访问器属性，或者能否通过delete删除属性从而重新定义属性。默认值为true。</li>\n<li>enumerable：可枚举性，表示能否通过for-in遍历得到属性。默认值为true。</li>\n<li>writable：可写性，表示能否修改属性的值。默认值为true。</li>\n<li>value：数据属性，表示属性的值。默认值为undefined。</li>\n</ul>\n<p class=\"para\">和两个存取器属性，分别是get和set，可以代替value和writable。</p>\n<ul>\n<li>get：在读取属性时调用的函数。只指定get则表示属性为只读属性。默认值为undefined。</li>\n<li>set：在写入属性时调用的函数。只指定set则表示属性为只写属性。默认值为undefined。</li>\n</ul>\n<p class=\"para\">属性描述符只能在<code>Object.defineProperty</code>或<code>Object.defineProperties</code>中使用。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var o = {}; // Creates a new object\n\n// Example of an object property added with defineProperty with a data property descriptor\n// 添加属性 a,值为37，并设置属性描述符\nObject.defineProperty(o, &#39;a&#39;, {\n  value: 37,\n  writable: true,\n  enumerable: true,\n  configurable: true\n});\n\n\nvar bValue = 38;\nObject.defineProperty(o, &#39;b&#39;, {\n  get: function() { return bValue; },\n  set: function(newValue) { bValue = newValue; },\n  enumerable: true,\n  configurable: true\n});\no.b; // 38\n// o 对象中存在属性 b，他的值为38；\n// 只要 o.b没有重新定义，它的值永远都是38\n\n// 访问器不能和 value或者 writable混在一起用\nObject.defineProperty(o, &#39;conflict&#39;, {\n  value: 0x9f91102,\n  get: function() { return 0xdeadbeef; }\n});\n// 抛出一个错误 Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #&lt;Object&gt;</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"ObjectdefineProperties\" style=\"position:relative;\"><a href=\"#ObjectdefineProperties\" aria-label=\"ObjectdefineProperties permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object.defineProperties()</h3>\n<p class=\"para\">相比 Object.defineProperty， Object.defineProperties可以说是前者的升级版，可以一次同时定义多个属性，语法略有不同：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let obj = {};\nObject.defineProperties(obj, {\n  &quot;property1&quot;: {\n    value: true,\n    writable: true\n  },\n  &quot;property2&quot;: {\n    value: &quot;Hello&quot;,\n    writable: false\n  },\n  &quot;property3&quot;: {\n    get: function() {\n      return &#39;Hello, Object.defineProperties&#39;;\n    },\n    set:function() {\n      this.property2 = &#39;xxxxxx&#39;;\n    }\n  }\n  // etc. etc.\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">参考资料：</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" class=\"link-underline\">https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" class=\"link-underline\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties\" class=\"link-underline\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\" class=\"link-underline\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" class=\"link-underline\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze</a></li>\n<li><a href=\"http://stackoverflow.com/a/17952160\" class=\"link-underline\">http://stackoverflow.com/a/17952160</a></li>\n</ol>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#objectassign\">Object.assign()</a></p>\n</li>\n<li>\n<p><a href=\"#objectcreate\">Object.create()</a></p>\n<ul>\n<li><a href=\"#%E4%BD%BF%E7%94%A8-objectcreate-%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF\">使用 Object.create() 实现继承</a></li>\n<li><a href=\"#objectcreate-vs-new\">Object.create VS new</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#objectfreeze\">Object.freeze()</a></p>\n<ul>\n<li><a href=\"#objectfreeze-vs-const\">Object.freeze VS const</a></li>\n<li><a href=\"#%E6%B7%B1%E5%BA%A6%E5%86%BB%E7%BB%93%E5%AF%B9%E8%B1%A1\">深度冻结对象</a></li>\n<li><a href=\"#objectfreeze-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">Object.freeze 的注意事项</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#objectdefineproperty\">Object.defineProperty()</a></p>\n</li>\n<li>\n<p><a href=\"#objectdefineproperties\">Object.defineProperties()</a></p>\n</li>\n</ul>","headings":[{"id":"Objectassign","depth":3,"value":"Object.assign()"},{"id":"Objectcreate","depth":3,"value":"Object.create()"},{"id":"使用-Objectcreate-实现继承","depth":4,"value":"使用 Object.create() 实现继承"},{"id":"Objectcreate-VS-new","depth":4,"value":"Object.create VS new"},{"id":"Objectfreeze","depth":3,"value":"Object.freeze()"},{"id":"Objectfreeze-VS-const","depth":4,"value":"Object.freeze VS const"},{"id":"深度冻结对象","depth":4,"value":"深度冻结对象"},{"id":"Objectfreeze-的注意事项","depth":4,"value":"Object.freeze 的注意事项"},{"id":"ObjectdefineProperty","depth":3,"value":"Object.defineProperty()"},{"id":"ObjectdefineProperties","depth":3,"value":"Object.defineProperties()"}],"frontmatter":{"title":"整理Object的一些方法","date":"2017-01-19","cover":null,"description":null,"categories":["前端"],"tags":["JavaScript"]}},"previous":{"fields":{"slug":"/blogs/2017-02-16-最近几次面试的小小总结/"},"frontmatter":{"title":"最近几次面试的小总结"}},"next":{"fields":{"slug":"/blogs/2017-01-11-JavaScrip-模块系统详解/"},"frontmatter":{"title":"JavaScrip模块系统详解","tags":["JavaScript"],"categories":["前端"],"status":null}}},"pageContext":{"id":"b6062132-dfe5-546f-ada7-2301582a1586","previousPostId":"c5fee728-7225-53fc-adc1-9cdbf7f4de93","nextPostId":"9859446f-1ab1-59c5-9ac8-3b78ae64ff3c"}},
    "staticQueryHashes": ["2841359383"]}