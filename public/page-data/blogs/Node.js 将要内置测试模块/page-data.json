{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/Node.js 将要内置测试模块/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"45620d32-c613-5c21-bdda-19d5d290d233","html":"<p class=\"para\">前两天上网冲浪时，在Node的Github仓库中，有这么一个Pull Request <a href=\"https://github.com/nodejs/node/pull/42325\" class=\"link-underline\">test: add initial test module #42325</a> ，顺着这个PR，可以找到一个<a href=\"https://github.com/nodejs/node/issues/40954\" class=\"link-underline\">提案：Proposal: Adding a built-in test runner</a> 。</p>\n<p class=\"para\">原来关于Node.js内置测试模块的提案，而网友也提交了相关的实现。Node社区正在向Node核心添加一个内置的测试模块。它将以新的node:test模块的形式出现，暴露了一个用于创建和执行JavaScript测试的API。测试执行的结果将使用标准的 <a href=\"https://testanything.org/\" class=\"link-underline\">TAP 格式</a> 输出。</p>\n<h2 class=\"heading subtitle heading\" id=\"为什么要内置测试模块呢\" style=\"position:relative;\"><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E7%BD%AE%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9D%97%E5%91%A2\" aria-label=\"为什么要内置测试模块呢 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>为什么要内置测试模块呢？</h2>\n<p class=\"para\">测试在软件开发过程中，从来都是最关键的一环。JavaScript作为一门动态语言，在测试阶段更加需要保证所有代码都被覆盖。</p>\n<p class=\"para\">目前，在JavaScript生态中，还没有一个开箱即用的测试工具。正因为如此，想Mocha、Jest等第三方测试框架才有机会流行。但是使用这些三方框架，会让你的项目配置和工作流程变得复杂，也增加了维护成本。</p>\n<p class=\"para\">还有一个JavaScript生态的通病就是，某一类问题的解决方案总是会有多种选择。你要是想弄清楚不同工具的使用，时常会让自己头疼。不同团队的选型会不一样，即使是相同的框架，最后在实践过程中也五花八门。原因在于缺乏强大的社区力量来帮忙解决这些问题。</p>\n<p class=\"para\">所以，如果官方社区能够站出来，提供一个标准化的、通用性强的方案就至关重要。通过添加内置的测试模块，以轻量级的方式实现绝大多数测试框架提供的功能子集。这样以来，用户可以从一开就快速入门，社区也将出现标准化的测试方案。</p>\n<h2 class=\"heading subtitle heading\" id=\"它是如何工作的\" style=\"position:relative;\"><a href=\"#%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\" aria-label=\"它是如何工作的 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>它是如何工作的？</h2>\n<p class=\"para\">按照PR上给到的信息可以看出，将会增加一个叫做 <code>node:test</code> 的核心模块。目前的版本中还只是支持执行单个测试文件，但最后预期的效果是可以通过 <code>—test</code> 标志来自动执行配置中定义的所有测试。</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const test = require(&#39;node:test&#39;);\nconst assert = require(&#39;assert&#39;);\n\ntest(&#39;synchronous passing test&#39;, (t) =&gt; {\n  assert.strictEqual(1, 1);\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">实际使用的方法相当简单，<code>test([name][, options][, fn])</code>。测试完成后返回一个Pormise。在目前的实现中，有一些突出的设计考虑：</p>\n<ul>\n<li>\n<p class=\"para\">当使用 —test 标志启动时，Node将执行所有包含测试模块的文件。</p>\n</li>\n<li>\n<p class=\"para\">测试文件将在隔离状态下运行</p>\n</li>\n<li>\n<p class=\"para\">一个文件的测试可以是同步的，也可以是异步的</p>\n<ul>\n<li>\n<p class=\"para\">同步测试如果没有抛出异常，将被视为通过</p>\n</li>\n<li>\n<p class=\"para\">异步测试将返回一个Promise，如果返回的Promise没有拒绝，将被视为通过</p>\n</li>\n</ul>\n</li>\n<li>\n<p class=\"para\">测试上下文的test()方法允许创建子测试，每个子测试的执行情况与顶级测试功能完全相同</p>\n</li>\n<li>\n<p class=\"para\">通过想测试传递跳过选项或调用测试上下文的skip()方法可以跳过单个测试。</p>\n</li>\n</ul>\n<p class=\"para\">比如，你可以跳过测试：</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">test(&#39;skip option with message&#39;, { skip: &#39;this is skipped&#39; }, (t) =&gt; {\n  // 这里的代码将不会执行\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">你也可以创建子测试：</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">test(&#39;top level test&#39;, async (t) =&gt; {\n  await t.test(&#39;subtest 1&#39;, (t) =&gt; {\n    assert.strictEqual(1, 1);\n  });\n\n  await t.test(&#39;subtest 2&#39;, (t) =&gt; {\n    assert.strictEqual(2, 2);\n  });\n\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">对于一个函数来说，测试模块提供的test方法相当简单易懂，下面列出了不同参数的信息：</p>\n<ul>\n<li>\n<p class=\"para\">name - 输出到报告的名称</p>\n</li>\n<li>\n<p class=\"para\">options - 该测试的配置参数，目前支持三个</p>\n<ul>\n<li>\n<p class=\"para\">concurrency { number } - 定义多少个测试并行运行</p>\n</li>\n<li>\n<p class=\"para\">skip { boolean | string } - 如果为真则跳过测试。如果是string类型，跳过之后会在输出报告中打印对应的字符串</p>\n</li>\n<li>\n<p class=\"para\">todo{ boolean | string } - 如果为真，将测试标记为todo。如果是string类型，跳过之后会在输出报告中打印对应的字符串</p>\n</li>\n<li>\n<p class=\"para\">fn - 实际的测试函数本身，它将接受一个 TestContext 对象作为参数。传递给 fn 参数的 TestContext 对象可用于执行一些操作，如跳过测试，添加额外的 TAP 诊断信息，或创建子测试。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 class=\"heading subtitle heading\" id=\"什么时候可以使用\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8\" aria-label=\"什么时候可以使用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么时候可以使用</h2>\n<p class=\"para\">目前还处于早期开发阶段，未来可能有变化，感兴趣的话可以关注上面提到的PR。如果想抢先体验，可以现在后续的<a href=\"https://nodejs.org/download/nightly/v18.0.0-nightly20220324094b2ae9ba/\" class=\"link-underline\"><strong>nightly build</strong></a> 版本中使用。</p>\n<h2 class=\"heading subtitle heading\" id=\"结束语\" style=\"position:relative;\"><a href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD\" aria-label=\"结束语 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>结束语</h2>\n<p class=\"para\">Node在今年2月份正式添加了Fetch模块。在此之前，<a href=\"https://www.npmjs.com/package/request\" class=\"link-underline\">request module</a> 是Node中进行HTTP请求的最流行方法。但是，整个JavaScript生态系统迅速发展，新引入的模式使request过时了：一个重要例子是async/await。request API中没有这方面的规定，而且由于这些限制，该项目后来被废弃了。虽然后来有 Axios等优秀新生代出现，但谁知道会不会出现第二个request模块呢？</p>\n<p class=\"para\">社区将 Fetch 纳入内置模块是不是也是一种标准化的体现呢？而现在又开始支持内置的测试模块，进一步将生态推向标准化。Node的未来应该会越来越好吧?</p>","tableOfContents":"<ul>\n<li><a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%86%85%E7%BD%AE%E6%B5%8B%E8%AF%95%E6%A8%A1%E5%9D%97%E5%91%A2\">为什么要内置测试模块呢？</a></li>\n<li><a href=\"#%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84\">它是如何工作的？</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8\">什么时候可以使用</a></li>\n<li><a href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD\">结束语</a></li>\n</ul>","headings":[{"id":"为什么要内置测试模块呢","depth":2,"value":"为什么要内置测试模块呢？"},{"id":"它是如何工作的","depth":2,"value":"它是如何工作的？"},{"id":"什么时候可以使用","depth":2,"value":"什么时候可以使用"},{"id":"结束语","depth":2,"value":"结束语"}],"frontmatter":{"title":"Node.js 将要内置测试模块","date":"2022-03-30","cover":"https://images.unsplash.com/photo-1528459801416-a9e53bbf4e17?ixlib=rb-1.2.1&q=85&fm=jpg&crop=entropy&cs=srgb","description":null,"categories":["技术研究"],"tags":["Node.js"]}},"previous":{"fields":{"slug":"/blogs/Storybook 使用手册——组件命名和结构层次/"},"frontmatter":{"title":"Storybook 使用手册——组件命名和结构层次"}},"next":{"fields":{"slug":"/blogs/Storybook 使用手册——基本概念/"},"frontmatter":{"title":"Storybook 使用手册——基本概念","tags":["CSS","Storybook","JavaScrtipt"],"categories":["技术研究"],"status":"publish"}}},"pageContext":{"id":"45620d32-c613-5c21-bdda-19d5d290d233","previousPostId":"01835df8-a91c-5747-b00c-3ffb42601ae4","nextPostId":"ff9caad0-e896-5bf4-8b65-3ebb8e5aeb59"}},
    "staticQueryHashes": ["2841359383"]}