{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/高性能网站优化-无阻塞加载脚本/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"af036023-daf0-5718-b898-614ae3795ee1","html":"<blockquote class=\"quote\">\n<p class=\"para\">《高性能网站建设进阶指南》</p>\n</blockquote>\n<!--more-->\n<p class=\"para\">按理来说，JavaScript在浏览器中的性能问题是开发人员面对的最重要的可用性问题。但由于JavaScript天生的阻塞性质，问题变得复杂。大多数浏览器在下载或者执行脚本的同时不会下载其他内容，使用单线程处理JavaScript的解析和UI的更新。当遇到这种情况时，希望以不阻塞其他内容下载的方式来加载JavaScript。有些技术可以做到这点，使页面加载更快。</p>\n<p class=\"para\">##头疼的脚本阻塞并行下载\r\n在介绍JavaScript加载优化技术之前，先看看浏览器默认的方式。&#x3C;script> 标签可以放在 &#x3C;head> 或者 &#x3C;body> 里面的任意位置。一般来说都将 &#x3C;script> 和 &#x3C;link> 标签一起放在 &#x3C;head> 中，这样一来页面加载的时候会先加载它们，页面的样式和行为看起来正常。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">\t&lt;html&gt;\t\r\n\t\t&lt;head&gt;\r\n\t    &lt;meta charset=&quot;UTF-8&quot;&gt;\r\n\t    &lt;title&gt;Demo&lt;/title&gt;\r\n\t    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/base.css&quot;&gt;\r\n\t    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/base2.css&quot;&gt;\r\n\t    &lt;script src=&quot;scripts/file1.js&quot;&gt;&lt;/script&gt;\r\n\t    &lt;script src=&quot;scripts/file2.js&quot;&gt;&lt;/script&gt;\r\n\t    &lt;script src=&quot;scripts/file3.js&quot;&gt;&lt;/script&gt;\r\n\t&lt;/head&gt;\r\n\t&lt;body&gt;\r\n\t    &lt;p&gt;Hello,CrispElte&lt;/p&gt;\r\n\t&lt;/body&gt;\r\n\t&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">尽管这端代码开始来无伤大雅，但实际上存在几个性能问题：有三个脚本文件，每个文件在下载和执行时候都会阻塞页面的加载。只有脚本执行完成之后，才会继续加载其他资源，比如，图片，CSS文件，iframe等。\r\n我们可以将 &#x3C;script> 标签放在页面的底部，即 &#x3C;/body>标签之前。尽管脚本文件的加载会阻塞页面，但是页面在脚本呢加载之前已经加载完成，所以不用担心阻塞。\r\n脚本应该顺序执行，但是没有必要顺序下载。IE8第一次实现了脚本的并行下载，但是在脚本下载并执行完毕之前依旧阻塞了后面的资源。<br>\n最终的目的时让脚本与其他资源并行下载，并且希望兼容所有的浏览器。</p>\n<p class=\"para\">##让脚本运行得更美好\r\n有几种动态加载外部脚本的技术可以使页面不会被脚本的阻塞行为所影响。\r\n###XHR Eval\r\n通过XMLHttpRequest从服务端获取脚本，然后通过eval命令执行内容</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var xhrObj=new XMLHttpRequest();\r\nxhrObj.onreadystatechange=function(){\r\n\tif(xhrObj.readyState == 4 &amp;&amp; xhrObj.status == 200){\r\n\t\teval(xhrObj.responseText);\r\n\t}\r\n}\r\nxhrObj.open(&quot;GET&quot;,&quot;file1.js&quot;,true);\r\nxhrObj.send(null);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">这个方法的主要缺陷是，动态加载的脚本必须是同域的。</p>\n<p class=\"para\">###XHR注入\r\n与XHR Eval类似，同样是通过 XMLHttpRequest 对象来获取脚本，不同之处在于，这个方法时不是用 eval 而是创建一个 script 的 DOM 元素，然后将 XMLHttpRequest 的响应写入script标签中来执行JavaScript。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var xhrObj=new XMLHttpRequest();\r\nxhrObj.onreadystatechange=function(){\r\n\tif(xhrObj.readyState == 4 &amp;&amp; xhrObj.status == 200){\r\n\t\tvar script=document.createElement(&quot;script&quot;);\r\n\t\tdocument.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);\r\n\t\tscript.text=xhrObj.responseText;\r\n\t}\r\n}\r\nxhrObj.open(&quot;GET&quot;,&quot;file1.js&quot;,true);\r\nxhrObj.send(null);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">和 XHR Eval 方法一样，加载的脚本必须是同域的。</p>\n<p class=\"para\">###Script in Iframe\r\n在页面中 iframe 与其他资源是并行下载的，可以利用iframe无阻塞加载JavaScript。\r\n由于 iframe 认为返回的是 HTML 文档，所以将src设置成一个 HTML 文件而不是 js 文件。\r\n而我们要做的就是在 HTML 文档中将外部脚本转换成行内脚本。</p>\n<p class=\"para\">与 XHR Eval 和 XHR 注入这两种方法类似，这个方法要求 iframe URL 和主页同域。满足同域要求之后，我们需要修改 JavaScript 来创建他们之间的关联，其本质就是获得引用 iframe 的 JavaScript 标示符。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//使用 &quot;iframes&quot; 中访问主页上的 iframe\r\nwindow.frames[0].somefunction();\r\n//使用 &quot;getElementById&quot; 访问主页上的iframe\r\ndocument.getElementById(&quot;myIframe&quot;).contentWindow.someFunction();</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><strong>可以在iframe中使用parent变量引用父页面</strong></p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function changeBg(){\r\n\tvar body=parent.document.body;\r\n\tbody.className=&quot;red&quot;;\r\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">概括一下：主页面中添加一个 iframe 标签，其 src 指向一个 HTML 文档，在这个 HTML 文档中编写行内 JavaScript 代码，也可以引用外部的 JavaScript 文件</p>\n<p class=\"para\">###Script DOM Element\r\n创建一个script标签并设置其src，代码很简单。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var script=document.createElement(&quot;script&quot;);\r\nscript.src=&quot;demo2.js&quot;;\r\ndocument.getElementsByTagName(&quot;head&quot;)[0].appendCHild(script);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">下载过程中用这种方式创建脚本不会阻塞其他的资源，同时这种方法允许跨域。</p>\n<p class=\"para\">###defer还是async\r\n在最新的标准中，script标签定义了defer属性和async属性，都是让脚本并行下载，但是defer下脚本按照顺序执行，而async不按顺序执行脚本。</p>\n<p class=\"para\">###document.write Script Tag\r\n最后一种技术是使用 document.write 把 HTML 标签 script 写入页面中。这种技术只在IE中是并行加载脚本的。虽然多个脚本可以并行下载，但在下载脚本时，浏览器仍然阻塞其他类型的资源。</p>","tableOfContents":"","headings":[],"frontmatter":{"title":"高性能网站优化-无阻塞加载脚本","date":"2014-03-30","cover":null,"description":null,"categories":["前端"],"tags":["web优化"]}},"previous":{"fields":{"slug":"/blogs/JavaScript中的事件处理程序/"},"frontmatter":{"title":"JavaScript中的事件处理程序"}},"next":{"fields":{"slug":"/blogs/高性能网站优化-创建快速响应的web/"},"frontmatter":{"title":"高性能网站优化-创建快速响应的Web","tags":["web优化"],"categories":["前端"],"status":null}}},"pageContext":{"id":"af036023-daf0-5718-b898-614ae3795ee1","previousPostId":"f80ca7f0-313e-5813-a8f3-23cfb73f59f8","nextPostId":"9a21001a-7549-5923-b6a3-81627d512d5b"}},
    "staticQueryHashes": ["2841359383"]}