{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2016-09-25-实现一个稍微复杂的simplelist/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"c9476842-70de-5256-b70d-39c555374739","html":"<p class=\"para\">使用过一些清单类的应用程序，像 WunderList, Google Keep等，用来记录一些计划和安排，也试着将自己的计划安排同笔记一起整理在 Evernote 中，但是无论哪种方式用起来总觉得少了点什么，如果两者的一些功能能够结合起来，就很完美了。</p>\n<!--more-->\n<p class=\"para\">“todo”和“note”之间的关系本来就很微妙，一个“todo”写得详细点不就成了“note”吗？于是自己写了一个稍微复杂一点的清单程序，今天将项目总结整理在此。</p>\n<p class=\"para\">我试着将 todo和 note 结合，可以像 WunderList 一样记录计划，又可以 Evernote 一样管理笔记。在开发过程中，反复调整和修改，最终发现：其实我只是做了一个支持 markdown 的 简易版WunderList :(。不管怎么样，能坚持下来就是值得鼓励的。整个工程前后端分离，后端实现不在此介绍</p>\n<p class=\"para\"><a href=\"https://github.com/zhanglun/bluerobin\" class=\"link-underline\">前端代码地址</a>，\n<a href=\"https://github.com/zhanglun/dockersite\" class=\"link-underline\">后端代码地址</a>，\n<a href=\"http://zhanglun.github.io/bluerobin/\" class=\"link-underline\">在线预览</a>。</p>\n<p class=\"para\">接下来，我简单介绍一下 simplelist 的前端实现过程。<strong>注意，下面介绍的一些过程不是一蹴而就，是反复修改和整理得出的，比如技术选择和组件的划分。</strong></p>\n<h3 class=\"heading\" id=\"编写代码的前期准备工作\" style=\"position:relative;\"><a href=\"#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\" aria-label=\"编写代码的前期准备工作 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>编写代码的前期准备工作</h3>\n<p class=\"para\">有三点</p>\n<ol>\n<li>确定需要实现的功能</li>\n<li>确定界面</li>\n<li>确定技术实现的方案</li>\n</ol>\n<p class=\"para\">功能和界面先放一边，介绍一下采用的技术方案。其实也没啥可介绍的，前端老司机花样多，但是主流的套路也就那么几种，我选择“套路のVue”。Vue+ Vuex+ Vue-Router，其他配件像 Less，Webpack等大家也应该都清楚。用户登陆注册及接口的实现不在本文章的讨论中，下次再讲。</p>\n<h3 class=\"heading\" id=\"组件划分很关键\" style=\"position:relative;\"><a href=\"#%E7%BB%84%E4%BB%B6%E5%88%92%E5%88%86%E5%BE%88%E5%85%B3%E9%94%AE\" aria-label=\"组件划分很关键 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>组件划分很关键</h3>\n<p class=\"para\">在 React 的组件化的划分方式中，将组件分成两种：Container Components和Presentational Components，容器组件和 UI组件。<strong>容器组件负责数据和业务逻辑的处理，携带相关的内部状态，与数据有频繁的交互， UI组件只负责 UI 的呈现，没有任何的数据和逻辑的处理，组件的数据从容器组件传递进来（在 React中数据由 this.props 提供）</strong>。如果一个组件既有 UI 又有业务逻辑，可以试着将它拆分成两个：一个容器组件，包着一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。</p>\n<p class=\"para\">个人比较喜欢这种方式，组件变得纯粹。不过似乎在 Vue 生态圈中没有设计这方面的介绍，在后面我打算尝试使用这种方式，不过现在还是使用相对粗暴一点的方式来划分。</p>\n<!--![clipboard.png](http://7xnrrd.com1.z0.glb.clouddn.com/69e6d8817e6736eca54a1c4de7605c6a.png) -->\n<p class=\"para\">这是 WunderList 的界面，简单的分析之后，可以将其划分成如下形式，再详细一点的话可以看下图，如果坚持容器组件和 UI组件的形式开发的话，相对较复杂一点，而我选择先从简单的入手。想必你应该看过<a href=\"http://todomvc.com/\" class=\"link-underline\">TodoMVC</a>，而这样也是simplelist 的最简单也是最核心的功能。所以在实际操作过程中，我先将输入框和单个任务这两个组件实现。</p>\n<!--![clipboard.png](http://7xnrrd.com1.z0.glb.clouddn.com/523fa36927e62c3405235fec5e256b2b.png) -->\n<h3 class=\"heading\" id=\"Vuex\" style=\"position:relative;\"><a href=\"#Vuex\" aria-label=\"Vuex permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Vuex</h3>\n<p class=\"para\">Vuex 是一个专门为 Vue.js 应用所设计的集中式状态管理架构。它借鉴了 Flux 和 Redux 的设计思想，但简化了概念，并且采用了一种为能更好发挥 Vue.js 数据响应机制而专门设计的实现。</p>\n<p class=\"para\">在单独使用 Vue.js 的时候，通常会把状态储存在组件的内部。整个应用的数据和状态都是散落在各个组件。这样并没有有什么问题，组件的数据组建自己管理。有时候状态的一部分需要共享给其他的组件，此时使用事件系统，让一个组件把一些状态“发送”到其他组件，但是当项目一步步扩大时，事件流将变得繁杂，不利于调试和维护。此时 Vuex 可以帮助我们实现状态的管理。</p>\n<p class=\"para\">Vuex 的四个核心概念分别是：</p>\n<ol>\n<li>The state tree：Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态，作为一个『唯一数据源(SSOT)』而存在。每个应用将仅仅包含一个 store 实例。单状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。数据流都是单向的。</li>\n<li>Getters：用来从 store 获取 Vue 组件数据。</li>\n<li>Mutators：事件处理器用来驱动状态的变化，只有 mutation 可以改变状态。</li>\n<li>Actions：可以给组件使用的函数，用来派发 Mutation。</li>\n</ol>\n<p class=\"para\">Vuex 规定，属于应用层级的状态只能通过 Mutation 中的方法来修改，而派发 Mutation 中的事件只能通过 action。从组件出发，组件中调用 action，在 action 这一层级我们可以和后台数据交互，比如获取初始化的数据源，或者中间数据的过滤等。然后在 action 中去派发 Mutation。Mutation 去触发状态的改变，状态的改变，将触发视图的更新。</p>\n<!--![clipboard.png](http://7xnrrd.com1.z0.glb.clouddn.com/6c8f34ec28ec5c0492af7c23fafe7b58.png) -->\n<p class=\"para\">配合 Vuex 这样的数据管理架构，我只需要关心组件的状态变化，数据的变化和流通全部交给 Vuex。我需要维护一个数组，数组中每一个元素代表一个任务，输入框和任务上的编辑删除等操作，本质上都是对一个数组的操作。</p>\n<h3 class=\"heading\" id=\"给任务加上分类\" style=\"position:relative;\"><a href=\"#%E7%BB%99%E4%BB%BB%E5%8A%A1%E5%8A%A0%E4%B8%8A%E5%88%86%E7%B1%BB\" aria-label=\"给任务加上分类 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>给任务加上分类</h3>\n<p class=\"para\">我已经说过了，我要做的是复杂的 simplelist。所以，在完成了最简单的增删改的功能之后，要加上任务的自己的归属了。每个任务都归属于一个清单，有唯一的清单 id（list_id）。就像 WunderList 一样，左侧清单列表，右侧任务列表。这时候需要用到单页引用中必不可少的路由装置了。</p>\n<p class=\"para\">从简单的开始，除了登录和注册（目前整合在应用中，更好的做法应该是登录注册作为两个单独的页面，这里只是个人 demo，暂不考虑），暂且只有一种路由状态，用来指向对应的清单，例如：<code>/lists/:id</code>。<strong>下面是伪代码</strong></p>\n<deckgo-highlight-code language=\"html\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;div id=&quot;app&quot;&gt;\n  &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const ListItem =  {\n  template: `&lt;div class=&quot;item&quot;&gt;{{item.title}}&lt;/div&gt;`,\n\tprops: [&#39;item&#39;],\n}\nconst ListContainer = {\n  template: `&lt;div class=&quot;list&quot;&gt;\n      &lt;h2&gt;List {{ $route.params.id }}&lt;/h2&gt;\n\t\t&lt;div class=&quot;item-list&quot;&gt;\n\t\t\t&lt;list-item v-for=&quot;item in list&quot; :item=&#39;item&#39;&gt;&lt;/list-item&gt; \n\t\t&lt;/div&gt;\n    &lt;/div&gt;`,\n\tcomponents: {\n\t\t&#39;list-item&#39;: ListItem,\n\t},\n}\n\nconst router = new VueRouter({\n  routes: [\n    { path: &#39;/lists/:id&#39;, component: ListContainer }\n  ]\n})</code>\n        </deckgo-highlight-code>\n<p class=\"para\">然后绑定好 <code>&#x3C;router-link></code>，路由切换就算完成了。但是光这样还不行，最关键的清单数据管理还没有加上。其实清单的数据状态管理与任务的管理大同小异，就不在此复述，你可以试着捋一捋。</p>\n<h3 class=\"heading\" id=\"弹层组件的管理\" style=\"position:relative;\"><a href=\"#%E5%BC%B9%E5%B1%82%E7%BB%84%E4%BB%B6%E7%9A%84%E7%AE%A1%E7%90%86\" aria-label=\"弹层组件的管理 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>弹层组件的管理</h3>\n<p class=\"para\">在创建和编辑清单的时候，需要弹出一个 modal 来方便操作（参照 WunderList）。这个时候就涉及到一个问题：这种定位不是很清晰的模块，该怎么来管理？</p>\n<p class=\"para\">在我看来，这种类型模块大致有两类，一类是全局共享，可能在很多不同的组件中都需要调用，这种全局的我认为可以单独拿出来放在同一个地方供应用调用。另一类是只属于某一个组件，只会在固定的组件中被调用，这类模块推荐直接写在组件中，方便管理，最好是写在顶级组件中，避免一些全七八糟的样式冲突（目前我遇到的主要还是层叠顺序的问题）。</p>\n<p class=\"para\">思路清晰之后，可以很顺利的完成清单的创建和编辑功能。</p>\n<p class=\"para\">说到这，一个复杂的 simplelist 的基本结构和功能已经出现了。那么问题来了，你学到了吗？</p>","tableOfContents":"<ul>\n<li><a href=\"#%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\">编写代码的前期准备工作</a></li>\n<li><a href=\"#%E7%BB%84%E4%BB%B6%E5%88%92%E5%88%86%E5%BE%88%E5%85%B3%E9%94%AE\">组件划分很关键</a></li>\n<li><a href=\"#vuex\">Vuex</a></li>\n<li><a href=\"#%E7%BB%99%E4%BB%BB%E5%8A%A1%E5%8A%A0%E4%B8%8A%E5%88%86%E7%B1%BB\">给任务加上分类</a></li>\n<li><a href=\"#%E5%BC%B9%E5%B1%82%E7%BB%84%E4%BB%B6%E7%9A%84%E7%AE%A1%E7%90%86\">弹层组件的管理</a></li>\n</ul>","headings":[{"id":"编写代码的前期准备工作","depth":3,"value":"编写代码的前期准备工作"},{"id":"组件划分很关键","depth":3,"value":"组件划分很关键"},{"id":"Vuex","depth":3,"value":"Vuex"},{"id":"给任务加上分类","depth":3,"value":"给任务加上分类"},{"id":"弹层组件的管理","depth":3,"value":"弹层组件的管理"}],"frontmatter":{"title":"实现一个稍微复杂的simplelist","date":"2016-09-25","cover":null,"description":null,"categories":["技术学习"],"tags":["前端"]}},"previous":{"fields":{"slug":"/blogs/2016-10-30-使用-React-Router-创建单页应用/"},"frontmatter":{"title":"使用 React-Router 创建单页应用"}},"next":{"fields":{"slug":"/blogs/2016-08-13-输入框插入表情的实现/"},"frontmatter":{"title":"输入框插入表情的实现","tags":["JavaScript"],"categories":["前端"],"status":null}}},"pageContext":{"id":"c9476842-70de-5256-b70d-39c555374739","previousPostId":"6a4ace5b-58e9-5bf6-af6d-ac89fbaf66c3","nextPostId":"074202c8-ea93-5b02-bab6-cf5c58269207"}},
    "staticQueryHashes": ["2841359383"]}