{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2016-08-05-Electron 开发的 gulp 配置/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"555f9de2-fc40-5a78-a55c-2e52ce59ad80","html":"<p class=\"para\">源自 Atom-shell 的 Electron 目前是一个很火的项目。已经有很多开发者基于 Electron 开发出了各种各样的桌面程序。在我看来，对于广大前端开发者来说，最为耳熟能详的应该是 Atom 和 VS Code。在 <a href=\"http://electron.atom.io/apps/\" class=\"link-underline\">Electron 的官网</a>上能够看到更多有意思的项目。</p>\n<p class=\"para\">之前提到过，我的计划之一就是玩一下 Electron，打造一个桌面工具。上个星期经过几次摸索和调研确定了这个项目的可行性之后，开始着手打造。近几天慢慢的构建出基础的项目前端结构。</p>\n<p class=\"para\">对于前端的技术选型已经没有之前那么纠结了，思考过后决定了：React。原因很简单，之前的一个小项目用的是 Vuejs 的一套体系，这次想换换口味。虽然之前我一直很不喜欢 React 那种模板和逻辑混合在一起的方式，但是很喜欢 Redux 的处理方式，所以忍不住试试看，到底是用 React 爽还是 Vue 爽。</p>\n<p class=\"para\">了解过 Electron 的应该都知道它的 main process 和 renderer process。main process 使用 BroswerWindow 实例创建 web page，每个 BroswerWindow 实例在它自己的 renderer process 中运行 web page，每当 BroswerWindow 实例被销毁时，其对应的 renderer process 也会被终止。main process 管理所有的 web  page 及其对应的 renderer process 。</p>\n<p class=\"para\">我觉得可以这么简单地理解的：如果将 renderer process 负责管理渲染的 web 页面所做的事情和浏览器类似，那么 main process 则是包裹着这个“浏览器”的外壳，将“浏览器”中的代码与系统底层联系在一起。</p>\n<p class=\"para\">在实践过程中，我发现 main process 的文件不能使用 import（应该说是无法使用 ES6 语法），可以使用 babel 将使用 ES6 语法的代码编译成可执行的版本代码。而 renderer process 的代码则通过 webpack 打包 React 代码。</p>\n<h3 class=\"heading\" id=\"gulp-babel-编译-main-process-代码\" style=\"position:relative;\"><a href=\"#gulp-babel-%E7%BC%96%E8%AF%91-main-process-%E4%BB%A3%E7%A0%81\" aria-label=\"gulp babel 编译 main process 代码 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>gulp-babel 编译 main process 代码</h3>\n<p class=\"para\">通过 gulp 和 babel 可以很轻松地完成</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var path = require(&#39;path&#39;);\nvar gulp = require(&#39;gulp&#39;);\nvar babel = require(&quot;gulp-babel&quot;);\n\nvar ROOT_PATH = path.resolve(__dirname);\nvar APP_PATH = path.resolve(ROOT_PATH, &#39;app&#39;);\n\n// main process 的编译\ngulp.task(&#39;babel:electron-main&#39;, function () {\n  return gulp.src([APP_PATH + &#39;/main.js&#39;, APP_PATH + &#39;/main/**/*.js&#39;], { base: APP_PATH })\n    .pipe(babel())\n    .pipe(gulp.dest(&#39;dist&#39;));\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">gulp 与 babel 的配合使用的更多细节可以参考 <a href=\"https://babeljs.io/docs/setup/\" class=\"link-underline\">babel</a> 和 <a href=\"https://github.com/babel/gulp-babel\" class=\"link-underline\">gulp-babel</a>。</p>\n<p class=\"para\">React 的 webpack 配置在这里我就不重复了，到处都能找到。</p>\n<h3 class=\"heading\" id=\"process-的重启和刷新\" style=\"position:relative;\"><a href=\"#process-%E7%9A%84%E9%87%8D%E5%90%AF%E5%92%8C%E5%88%B7%E6%96%B0\" aria-label=\"process 的重启和刷新 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>process 的重启和刷新</h3>\n<p class=\"para\">我发现在目前市面上Electron 的相关基础教程中，简单的介绍都是如此：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 安装 \nnpm install -g electron-prebuilt\n// 启动\nelectron .\n\n//更好一点的是按照官方给出的 quick start\nnpm start</code>\n        </deckgo-highlight-code>\n<p class=\"para\">但是这样有一个很直接的问题：每次修改 main process 相关代码之后需要重启，修改了 renderer process 相关代码之后需要手动刷新，这很影响开发体验。</p>\n<p class=\"para\">renderer process 的 hot load 很好处理，和前端开发类似，react 和 vue 都有类似的工具，直接将前端开发中使用的配置挪过来就好。而 main process 的自动化则需要另寻办法，当然，也不难。使用 <a href=\"https://github.com/Quramy/electron-connect\" class=\"link-underline\">electron-connect</a> 可以很好的帮助我们解决这个问题，在 gulp 中设置好task 之后然后在 renderer process 和 main process 中的插入一段代码即可。</p>\n<ul>\n<li>gulpfile.js</li>\n</ul>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var gulp = require(&#39;gulp&#39;);\nvar gutil = require(&#39;gulp-util&#39;);\nvar electron = require(&#39;electron-connect&#39;).server.create();\n\ngulp.task(&#39;watch:electron&#39;, function () {\n  electron.start();\n  gulp.watch([&#39;./app/src/main.js&#39;, &#39;./app/src/main/**/*.js&#39;], electron.restart);\n  gulp.watch([&#39;./app/dist/**/*.{html,js,css}&#39;], electron.reload);\n});</code>\n        </deckgo-highlight-code>\n<ul>\n<li>RendererProcess</li>\n</ul>\n<deckgo-highlight-code language=\"html\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Hello World!&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;!-- All of the Node.js APIs are available in this renderer process. --&gt;\n&lt;!--We are using node &lt;script&gt;document.write(process.versions.node)&lt;/script&gt;,--&gt;\nChromium &lt;script&gt;document.write(process.versions.chrome)&lt;/script&gt;,\nand Electron &lt;script&gt;document.write(process.versions.electron)&lt;/script&gt;.\nand Node &lt;script&gt;document.write(process.version)&lt;/script&gt;.\n&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;script&gt;\n  \t//创建 client\n    require(&#39;electron-connect&#39;).client.create();\n&lt;/script&gt;\n&lt;/html&gt;</code>\n        </deckgo-highlight-code>\n<ul>\n<li>MainProcess</li>\n</ul>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&#39;use strict&#39;;\n\nvar app = require(&#39;app&#39;);\nvar BrowserWindow = require(&#39;browser-window&#39;);\nvar client = require(&#39;electron-connect&#39;).client;\n\napp.on(&#39;ready&#39;, function () {\n  var mainWindow = new BrowserWindow({\n    width: 400,\n    height: 300\n  });\n  mainWindow.loadUrl(&#39;file://&#39; + __dirname + &#39;/index.html&#39;);\n\n  // Connect to server process\n  client.create(mainWindow);\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">细心的同学可能会发现，在 watch 的 task 中，同时对 main process 和 renderer process 的代码监听，对应的操作是 restart 和 reload。reload 会刷新当前的页面，在这里 React 的 hot load 都可以不需要了。印象中好像 hot load 是不会整个刷新页面的，回头可以试试。</p>\n<p class=\"para\">至此，只需要在终端中执行</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">gulp watch:electron </code>\n        </deckgo-highlight-code>\n<p class=\"para\">就能达到开发过程中 electron 自动 restart 和 reload 的目的了。如果想看详细文档可以前往 <a href=\"https://github.com/Quramy/electron-connect\" class=\"link-underline\">这里</a>。</p>\n<p class=\"para\">上述只是简单的例子，更多时候需要根据项目的规划做调整，一下是我的 gulpfile.js</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var path = require(&#39;path&#39;);\nvar gulp = require(&#39;gulp&#39;);\nvar babel = require(&quot;gulp-babel&quot;);\nvar gutil = require(&#39;gulp-util&#39;);\nvar webpack = require(&#39;webpack&#39;);\nvar webpackConfig = require(&#39;./webpack.config.js&#39;);\nvar electron = require(&#39;electron-connect&#39;).server.create();\n\nvar ROOT_PATH = path.resolve(__dirname);\nvar APP_PATH = path.resolve(ROOT_PATH, &#39;app&#39;);\n\n// 开发\nvar webpackConfigDev = Object.create(webpackConfig);\nwebpackConfigDev.devtool = &#39;eval-source-map&#39;;\nwebpackConfigDev.debug = true;\n\nvar devCompiler = webpack(webpackConfigDev);\n\n// renderer process 的 webpack 编译\ngulp.task(&#39;webpack:build-dev&#39;, function () {\n  devCompiler.run(function (err, status) {\n    if (err) {\n      throw new gutil.PluginError(&#39;webpack:build-dev&#39;, err);\n    }\n    gutil.log(&#39;[webpack:build-dev]&#39;, status.toString({\n      colors: true\n    }));\n  });\n});\n\n// main process 的编译\ngulp.task(&#39;babel:electron-main&#39;, function () {\n  return gulp.src([APP_PATH + &#39;/main.js&#39;, APP_PATH + &#39;/main/**/*.js&#39;, APP_PATH + &#39;/constant/*.js&#39;], { base: APP_PATH })\n    .pipe(babel())\n    .pipe(gulp.dest(&#39;dist&#39;));\n});\n\n\ngulp.task(&#39;watch&#39;, [&#39;babel:electron-main&#39;, &#39;webpack:build-dev&#39;], function () {\n\n  electron.start();\n\n  gulp.watch([&#39;./app/main.js&#39;, &#39;./app/main/**/*.js&#39;], [&#39;babel:electron-main&#39;]);\n  gulp.watch([APP_PATH + &#39;/constant/*.js&#39;, &#39;./app/src/**/*.{html,js,css}&#39;], [&#39;webpack:build-dev&#39;]);\n\n  gulp.watch([&#39;./dist/main.js&#39;, &#39;./dist/main/**/*.js&#39;], electron.restart);\n  gulp.watch([&#39;./dist/renderer/*.{html,js,css}&#39;, &#39;./dist/renderer/**/*.{html,js,css}&#39;], electron.reload);\n\n});\n\ngulp.task(&#39;dev&#39;, [&#39;watch&#39;]);\n</code>\n        </deckgo-highlight-code>","tableOfContents":"<ul>\n<li><a href=\"#gulp-babel-%E7%BC%96%E8%AF%91-main-process-%E4%BB%A3%E7%A0%81\">gulp-babel 编译 main process 代码</a></li>\n<li><a href=\"#process-%E7%9A%84%E9%87%8D%E5%90%AF%E5%92%8C%E5%88%B7%E6%96%B0\">process 的重启和刷新</a></li>\n</ul>","headings":[{"id":"gulp-babel-编译-main-process-代码","depth":3,"value":"gulp-babel 编译 main process 代码"},{"id":"process-的重启和刷新","depth":3,"value":"process 的重启和刷新"}],"frontmatter":{"title":"Electron 开发的 gulp 配置","date":"2016-08-05","cover":null,"description":null,"categories":["前端"],"tags":["electron"]}},"previous":{"fields":{"slug":"/blogs/2016-08-13-输入框插入表情的实现/"},"frontmatter":{"title":"输入框插入表情的实现"}},"next":{"fields":{"slug":"/blogs/2016-08-04-真的是好久没写博客了/"},"frontmatter":{"title":"真的是好久没写博客了","tags":["随笔"],"categories":["随笔"],"status":null}}},"pageContext":{"id":"555f9de2-fc40-5a78-a55c-2e52ce59ad80","previousPostId":"074202c8-ea93-5b02-bab6-cf5c58269207","nextPostId":"ec86d378-b3fa-5fac-8d70-322cd11ce8bd"}},
    "staticQueryHashes": ["2841359383"]}