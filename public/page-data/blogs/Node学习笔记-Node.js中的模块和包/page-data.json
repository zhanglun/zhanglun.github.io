{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/Node学习笔记-Node.js中的模块和包/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"b95017c1-3fa9-5841-80ae-b639a3e9971b","html":"<p class=\"para\">之前简单的了解了 Node.js 。对 Node.js  有一个简单的认识。接下来查看了 API 文档中模块有关的知识点，参照《Node.js 开发指南》，并做笔记。</p>\n<!--more-->\n<p class=\"para\">模块和包是 Node.js 中最重要的支柱。经常将模块和包相提并论，因为二者之间其实没有本质上的区别，经常混用。如果硬要作出区分的话，那么可以把包理解成：实现某个功能的众多模块的集合。</p>\n<p class=\"para\">##什么是模块\r\n模块是 Node.js 应用程序的基本组成部分。Node 有一套简单的模块加载机制。在 Node.js 中，文件和模块是一一对应的。也就是说，一个 Node.js 文件就可以看成是一个模块，所以在 Node 中创建一个模块非常简单。Node 提供了 exports 和 require 两个对象。exports 是模块公开的接口，意思就是创建模块得靠 exports；require 用于从外部获取一个模块的接口，也就是说使用模块要用 require 。</p>\n<p class=\"para\">举个例子方便了解模块： <em>foo.js</em> 加载同目录中的模块 <em>circle.js</em> 。</p>\n<p class=\"para\"><em>foo.js</em> 中的内容：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var circle = require(&#39;./circle.js&#39;);\r\nconsole.log( &#39;The area of a circle of radius 4 is &#39; + circle.area(4));</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><em>circle.js</em> 中的内容：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var PI = Math.PI;\r\n\r\nexports.area = function (r) {\r\n  return PI * r * r;\r\n};\r\n\r\nexports.circumference = function (r) {\r\n  return 2 * PI * r;\r\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><em>circle.js</em> 模块通过 exports 对象输出了两个方法：area() 和 circumference()，在 <em>foo.js</em> 中使用 require() 加载这个模块，然后便可以直接访问 exports 对象的成员函数了。反言之，如果想为自定义的模块添加属性或者方法，将它们添加到 exports 这个特殊的对象上就可以达到目的。</p>\n<p class=\"para\">如果希望模块提供的接口是一个构造函数，或者输出的是一个完整的对象而不是一个属性，那么可以使用 <strong>module.exports</strong> 代替 exports。\r\n但是注意，exports 是 module.exports 的一个引用，只是为了用起来方便。</p>\n<p class=\"para\">下面的 <em>bar.js</em> 使用了 square 模块，而 square 模块提供了一个构造函数的接口：</p>\n<p class=\"para\"><em>bar.js</em> 中的内容：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var square = require(&#39;./square.js&#39;);\r\nvar mySquare = square(2);\r\nconsole.log(&#39;The area of my square is &#39; + mySquare.area());</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><em>square.js</em> 中的内容：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// 使用 exports 将无法创建 module,必须使用 module.exports\r\n\r\nmodule.exports = function(width) {\r\n    return {\r\n        area: function() {\r\n            return width * width;\r\n        }\r\n    };\r\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">使用 module.exports 可以很快得到想要的：</p>\n<!-- ![使用 module.exports](http://cl.ly/image/1b32450A2744/download/2014-04-25_205447.png) -->\n<p class=\"para\">而使用 exports 时：</p>\n<!-- ![使用 exports](http://cl.ly/image/040A3H2K2g0n/download/2014-04-25_210131.png) -->\n<p class=\"para\">(module.exports 和 exports 二者之间更具体的关系将之后补上)。</p>\n<p class=\"para\">##模块的循环调用</p>\n<p class=\"para\">当存在循环的模块引用时，有的模块可能在返回时不会执行。看看这个例子：</p>\n<p class=\"para\"><em>a.js</em> 中的内容：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">console.log(&#39;模块 a 开始了！&#39;);\r\nexports.done = false;\r\nvar b = require(&#39;./b.js&#39;);\r\nconsole.log(&#39;在 a 中, b.done = %j&#39;, b.done);\r\nexports.done = true;\r\nconsole.log(&#39;模块 a 结束了！&#39;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><em>b.js</em> 中的内容：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">console.log(&#39;模块 b 开始了！&#39;);\r\nexports.done = false;\r\nvar a = require(&#39;./a.js&#39;);\r\nconsole.log(&#39;在 b 中, a.done = %j&#39;, a.done);\r\nexports.done = true;\r\nconsole.log(&#39;模块 b 结束了！&#39;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><em>main.js</em> 中的内容：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">console.log(&#39;main 开始了！&#39;);\r\nvar a = require(&#39;./a.js&#39;);\r\nvar b = require(&#39;./b.js&#39;);\r\nconsole.log(&#39;在 main 中, a.done=%j, b.done=%j&#39;, a.done, b.done);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">当 main.js 加载 a.js 时，a.js 又加载 b.js。这个时候，b.js 又会尝试去加载 a.js 。为了防止出现无限循环的加载，a.js 中的 exports 对象会返回一个 <strong>unfinished copy</strong> 给 b.js 模块。然后模块b完成加载，同时将提供模块a的接口。当 main.js 加载完a，b两个模块之后，输出如下：</p>\n<!-- ![cycles](http://cl.ly/image/263z0W3W0m0G/download/2014-04-25_212142.png)   -->\n<p class=\"para\">##模块的分类和载入\r\nNode.js 的模块可以分成两类，一类是原生模块（核心模块），另一类是文件模块。核心模块由二进制编译而成，定义在源代码的 <strong>lib/</strong> 目录下,加载的速度最快，比如：HTTP 模块。而文件模块我的理解就是那些可以 require 的文件，后缀可以是 .js、.json、.node。</p>\n<p class=\"para\">require() 总是会优先加载核心模块。例如，require(‘http’) 总是返回编译好的HTTP 模块，而不管是否有这个名字的文件。模块在第一次加载后会被缓存。这意味着（类似其他缓存）每次调用require(‘foo’)的时候都会返回同一个对象，当然，必须是每次都解析到同一个文件。</p>\n<p class=\"para\">前面的例子中 <code>require(“./a.js”)</code> 等，就是在加载文件模块。如果按文件名没有查找到对应的模块，那么 Node.js 会添加 .js和 .json后缀名，再尝试加载，如果还是没有找到，最后会加上 .node 的后缀名再次尝试加载。如果指定的路径不存在，require() 会抛出一个 code 属性为 <strong>‘MODULE_NOT_FOUND’</strong> 的错误。</p>\n<p class=\"para\">在 require() 没有以’/‘或者’./‘来指向一个文件时，这个模块要么是”核心模块”，要么就是从 node_modules 文件夹加载的。如果 require() 中的模块名不是一个<strong>本地模块(不在项目目录中)</strong>，也没有以<code>’/’</code>, <code>’../’</code>, 或是 <code>’./’</code> 开头，那么 Node.js 会从当前模块的父目录开始，尝试在它的 <code>‘/node_modules’</code> 文件夹里加载相应模块。如果没有找到，那么就再向上移动到父目录，直到到达顶层目录位置。</p>\n<p class=\"para\">举个例子，如果 <em>foo.js</em> 文件的路径是<code>‘E:/Code/nodejs/demo/foo.js’</code>,加载 <em>bar.js</em> 模块，那么 Node.js 将会按照下面的顺序检查文件目录：</p>\n<ul>\n<li>E:/Code/nodejs/demo/node_modules/bar.js</li>\n<li>E:/Code/nodejs/node_modules/bar.js</li>\n<li>E:/Code/node_modules/bar.js</li>\n<li>E:/node_modules/bar.js</li>\n</ul>\n<p class=\"para\">所以尽可能地把依赖放在就近的位置，以防崩溃。</p>\n<p class=\"para\"><strong>个人笔记，仅供参考</strong></p>\n<blockquote class=\"quote\">\n<p class=\"para\">参考:</p>\n</blockquote>\n<ul>\n<li>\n<p class=\"para\"><a href=\"http://book.douban.com/subject/10789820/\" class=\"link-underline\">《Node.js 开发指南》</a></p>\n</li>\n<li>\n<p class=\"para\"><a href=\"http://nodejs.org/docs/latest/api/modules.html#modules_core_modules\" class=\"link-underline\">Node.js API</a></p>\n</li>\n<li>\n<p class=\"para\"><a href=\"http://www.infoq.com/cn/articles/nodejs-module-mechanism\" class=\"link-underline\">深入浅出 Node.js 三</a></p>\n</li>\n</ul>","tableOfContents":"","headings":[],"frontmatter":{"title":"Node学习笔记-Node.js中的模块","date":"2014-04-25","cover":null,"description":null,"categories":["Node.js"],"tags":["笔记","Node.js"]}},"previous":{"fields":{"slug":"/blogs/(译)node.js的模块- exports 和 module.exports/"},"frontmatter":{"title":"【译】Node.js的模块-exports和module.exports"}},"next":{"fields":{"slug":"/blogs/Node学习笔记-Node.js介绍/"},"frontmatter":{"title":"Node.js入门-Node.js 介绍","tags":["Node.js"],"categories":["Node.js"],"status":null}}},"pageContext":{"id":"b95017c1-3fa9-5841-80ae-b639a3e9971b","previousPostId":"61c585be-d577-55f9-a983-3cd509546299","nextPostId":"a1cb3dcf-96f7-58e5-9727-5ee493865cae"}},
    "staticQueryHashes": ["2841359383"]}