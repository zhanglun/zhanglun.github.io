{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2016-10-30-使用-React-Router-创建单页应用/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"6a4ace5b-58e9-5bf6-af6d-ac89fbaf66c3","html":"<p class=\"para\">最近业余时间在学习 React，配合 Redux 和 React-Router 正在不紧不慢地开发一个小工具<a href=\"https://github.com/zhanglun/moviemaster\" class=\"link-underline\">moviemaster</a>，用于管理硬盘中的电影剧集。在单页应用开发中，redux 并不是必须的，所以今天只讲讲 前端的路由系统以及 React-Router的简单使用。</p>\n<!--more-->\n<h3 class=\"heading\" id=\"什么是路由\" style=\"position:relative;\"><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1\" aria-label=\"什么是路由 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>什么是路由</h3>\n<p class=\"para\">以下来自维基百科：：</p>\n<blockquote class=\"quote\">\n<p class=\"para\">路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动。路由发生在OSI网络参考模型中的第三层即网路层。</p>\n</blockquote>\n<p class=\"para\">路由引导分组转送，经过一些中间的节点后，到它们最后的目的地。</p>\n<p class=\"para\">这是网络工程中的术语，对大家而言，最熟悉的应该就是家里的路由器。路由是指路由器从一个接口上收到数据包，根据数据包的目的地址进行定向并转发到另一个接口的过程。放在 Web 上来说，url 就像是路由器中的路由表，每个 url 对应不同的页面或者内容，就像路由表中的的 IP 对应不同的网络一样。</p>\n<p class=\"para\">先来看一下熟悉的套路：</p>\n<!-- ![image_1b0a1gh7ge4u1g9l14mm7v41me9a.png](http://7xnrrd.com1.z0.glb.clouddn.com/e4199599d78057a8efacb848ab9b5927.png) -->\n<p class=\"para\">在传统的网页应用架构中，客户端只是一个展示层，通过 url 访问服务端，服务端则根据自己的“路由表”将对应的页面分发给客户端。但是在这种模式下，ajax 异步加载的内容是无法通过url 记录的。无论你在页面上操作了多少，异步请求了多少数据，在每次重新访问同一个 url 时，服务端返回给客户端的内容都是一模一样。</p>\n<!--![image_1b0a24tg94le1p03qa76br1apfg.png](http://7xnrrd.com1.z0.glb.clouddn.com/6ed2cf502e487c30c3640a2026071f87.png) -->\n<p class=\"para\">如果前端有自己专属的“路由表”来分发页面上不同的状态，那不就行了？</p>\n<h3 class=\"heading\" id=\"Hash-和-pushState\" style=\"position:relative;\"><a href=\"#Hash-%E5%92%8C-pushState\" aria-label=\"Hash 和 pushState permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hash 和 pushState</h3>\n<p class=\"para\">据我所知，目前有两种方式可以构建出前端的路由系统：url 中的#和 HTML5中的 history API。其原理如下：</p>\n<ol>\n<li>阻止标签的默认跳转动作。</li>\n<li>ajax或者 Fetch 请求内容。</li>\n<li>将返回的内容添加到页面中。</li>\n<li>使用 hash 或者 pushState 修改 url。</li>\n</ol>\n<h4 class=\"heading\" id=\"经典的-Hash\" style=\"position:relative;\"><a href=\"#%E7%BB%8F%E5%85%B8%E7%9A%84-Hash\" aria-label=\"经典的 Hash permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>经典的 Hash</h4>\n<p class=\"para\">#代表网页中的一个位置。后面接着的字符，就是该位置的标识符。比如，</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">https://zhanglun.github.io/index.html#body</code>\n        </deckgo-highlight-code>\n<p class=\"para\">就代表网页 index.html 的 body 位置。浏览器读取这个 URL 后，会自动将body位置滚动至可视区域。标识符的指定有两个方法。</p>\n<ol>\n<li>使用锚点</li>\n</ol>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;a name=&quot;body&quot;&gt;&lt;/a&gt;</code>\n        </deckgo-highlight-code>\n<ol start=\"2\">\n<li>使用id属性</li>\n</ol>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;div id=&quot;body&quot; &gt;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">#是用来指向文档的内容，属于浏览器的行为，与服务端无关，在 HTTP请求中也不会携带 #及其后面的内容，对于服务端而言 <a href=\"http://www.baidu.com\" class=\"link-underline\">http://www.baidu.com</a> 和 <a href=\"http://www.baidu.com#action=fuckbaidu\" class=\"link-underline\">http://www.baidu.com#action=fuckbaidu</a> 返回给客户端的都是前者所分发的内容，但是在浏览器中可以通过 Window 对象上的 <code>location.hash</code> 进行操作。因此，在浏览器中可以通过 hash 来记录页面的状态，构建“路由表”。当页面状态发生变化时，hash 相应变化，重新加载时又可以通过 url 中携带的 hash 直接将页面设置到对应的状态。</p>\n<p class=\"para\">比如：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">http://www.example.com/\nhttp://www.examplt.com/#edit\nhttp://www.examplt.com/#settings</code>\n        </deckgo-highlight-code>\n<ol>\n<li>访问<code>/</code>时，呈现主页。</li>\n<li>点击页面上的<code>Edit</code>按钮，页面呈现编辑对应的内容。通过 url 直接访问时，检查 hash 是否和 <code>edit</code> 匹配，如果匹配执行加载编辑内容的代码</li>\n<li>点击页面上的<code>Settings</code>按钮，页面呈现设置对应的内容。通过 url 直接访问时，检查 hash 是否和 <code>settings</code> 匹配，如果匹配执行加载编辑内容的代码。</li>\n</ol>\n<p class=\"para\">以下是伪代码：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">  function hashHandler () {\n    let key = location.hash.slice(1);\n    switch(key) {\n      case &#39;edit&#39;:\n        renderEditPanel();\n        break;\n      case &#39;settings&#39;:\n        renderSettings();\n        break;\n       default:\n        break;\n    }\n  }\n  window.onload = () =&gt; {\n    hashHandler();\n  }\n  window.onhashchange = () =&gt; {\n    hashHandler();\n  }</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"HTML5-中的-pushState\" style=\"position:relative;\"><a href=\"#HTML5-%E4%B8%AD%E7%9A%84-pushState\" aria-label=\"HTML5 中的 pushState permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTML5 中的 pushState</h4>\n<p class=\"para\">pushState是 History API中的一个方法，其文档可以看这里 <a href=\"https://developer.mozilla.org/zh-CN/docs/DOM/Manipulating_the_browser_history\" class=\"link-underline\">MDN History</a>。它的功能简单的说就是：修改 url，添加历史记录。比如<code>/blogs</code>和<code>settings</code>对应的是两个页面，如果只是在页面上点击标签切换，需要做的操作只有：发送请求修改页面内容和调用 pushState 方法修改 url。问题来了，对于前端而言需要将其视为同一个页面，但实际上这两个 url 对于服务端来说是两个不同的请求，所以这里需要服务端的配合。</p>\n<p class=\"para\">我的做法是：对应的url 返回的都是同一个页面，然后浏览器接受之后检查前端定义路由系统，执行响应的代码。这个方法可能会造成页面平白添加一个短暂的延迟，不过影响不是很大。</p>\n<h3 class=\"heading\" id=\"React-Router的使用\" style=\"position:relative;\"><a href=\"#React-Router%E7%9A%84%E4%BD%BF%E7%94%A8\" aria-label=\"React Router的使用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React-Router的使用</h3>\n<p class=\"para\">目前来说，任何一个路由系统库或者框架，虽说是写法不一，但是都是在上述两种方式的基础上实现的。让我觉得耳目一新的是：使用路由嵌套的概念来定义 view 的嵌套集合，当一个给定的 URL 被调用时，整个集合中（命中的部分）都会被渲染。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">import React from &#39;react&#39;;\nimport { render } from &#39;react-dom&#39;;\nimport { Router, Route, IndexRoute, hashHistory } from &#39;react-router&#39;;\n\nimport App from &#39;./containers/App&#39;;\nimport MovieContainer from &#39;./containers/Movies&#39;;\nimport Detail from &#39;./containers/Detail&#39;;\n\n\nlet rootElement = document.getElementById(&#39;app&#39;);\nrender(\n  &lt;Router&gt;\n    &lt;Route path=&quot;/&quot; component={App}&gt;\n      &lt;Route path=&quot;about&quot; component={About} /&gt;\n      &lt;Route path=&quot;inbox&quot; component={Inbox}&gt;\n        &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;\n      &lt;/Route&gt;\n    &lt;/Route&gt;\n  &lt;/Router&gt;,\nrootElement);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在入口文件中，引入 React-Router，以组件的形式在 render 中使用，上述代码配置结果如下：</p>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>组件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/</td>\n<td>App</td>\n</tr>\n<tr>\n<td>/about</td>\n<td>App -> About</td>\n</tr>\n<tr>\n<td>/inbox</td>\n<td>App -> Inbox</td>\n</tr>\n<tr>\n<td>/inbox/messages/:id</td>\n<td>App -> Inbox -> Message</td>\n</tr>\n</tbody>\n</table>\n<p class=\"para\">在路由中，组件对应设置的子组件可以通过 <code>this.props.children</code> 渲染在父组件中</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">class App extend Component {\n  constructor(props) {\n    super(props)\n  }\n  render() {\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n      {this.props.children}\n    &lt;/div&gt;\n  }\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">当 URL 为 / 时， App 中并没有渲染任何的组件，render 中的 this.props.children 还是 undefined。此时可以使用 <code>IndexRoute</code> 来设置一个默认页面。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">render(\n  &lt;Router&gt;\n    &lt;Route path=&quot;/&quot; component={App}&gt;\n      {/* 当 url 为/时渲染 Welcome */}\n      &lt;IndexRoute component={Welcome} /&gt;\n      &lt;Route path=&quot;about&quot; component={About} /&gt;\n      &lt;Route path=&quot;inbox&quot; component={Inbox}&gt;\n        &lt;Route path=&quot;messages/:id&quot; component={Message} /&gt;\n      &lt;/Route&gt;\n    &lt;/Route&gt;\n  &lt;/Router&gt;,\nrootElement);</code>\n        </deckgo-highlight-code>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>组件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/</td>\n<td>App -> Welcome</td>\n</tr>\n<tr>\n<td>/about</td>\n<td>App -> About</td>\n</tr>\n<tr>\n<td>/inbox</td>\n<td>App -> Inbox</td>\n</tr>\n<tr>\n<td>/inbox/messages/:id</td>\n<td>App -> Inbox -> Message</td>\n</tr>\n</tbody>\n</table>\n<p class=\"para\">看一下这一段代码</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;Route path=&quot;posts&quot; component={Post}&gt;\n  &lt;Route path=&quot;users/:userid&quot; component={User}&gt;\n    &lt;Route path=&quot;messages/:messageid&quot; component={Message} /&gt;\n  &lt;/Route&gt;\n&lt;/Route&gt;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">此时匹配的路由分别是：<code>/posts</code>，<code>/posts/usres/:userid</code> 和<code>/posts/users/:userid/messages/:messageid</code>，可以看出，嵌套的<code>&#x3C;Route></code>所匹配的 url是包裹着它的 <code>&#x3C;Route></code>的 path “之和”。但是问题又来了，嵌套的好处在于路由之间结构清晰直观，但是也会导致 url 的不美观，试想<code>/posts/users/:userid/messages/:messageid</code>这么长的路由也是着实让人心累。React-Router 的配置提供了一个选择：将 Route 的 path 设置成绝对路径。同时可以使用<code>&#x3C;Redirect/></code> 将修改为绝对路径的路由重定向到之前的设置</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;Route path=&quot;posts&quot; component={Inbox}&gt;\n  &lt;Route path=&quot;/users/:userid&quot; component={Message}&gt;\n    &lt;Route path=&quot;/messages/:messageid&quot; component={Message} /&gt;\n  &lt;/Route&gt;\n&lt;/Route&gt;</code>\n        </deckgo-highlight-code>\n<table>\n<thead>\n<tr>\n<th>URL</th>\n<th>组件</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/posts</td>\n<td>App -> Post</td>\n</tr>\n<tr>\n<td>/user/:userid</td>\n<td>App -> Post -> User</td>\n</tr>\n<tr>\n<td>/messages/:messageid</td>\n<td>App -> Post -> User ->Message</td>\n</tr>\n</tbody>\n</table>\n<p class=\"para\">基础的配置完成之后，通过 <code>&#x3C;Link></code>自动或者通过<code>browserHistory</code>和<code>hashHistory</code>手动执行路由的跳转。</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%AF%E7%94%B1\">什么是路由</a></p>\n</li>\n<li>\n<p><a href=\"#hash-%E5%92%8C-pushstate\">Hash 和 pushState</a></p>\n<ul>\n<li><a href=\"#%E7%BB%8F%E5%85%B8%E7%9A%84-hash\">经典的 Hash</a></li>\n<li><a href=\"#html5-%E4%B8%AD%E7%9A%84-pushstate\">HTML5 中的 pushState</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#react-router%E7%9A%84%E4%BD%BF%E7%94%A8\">React-Router的使用</a></p>\n</li>\n</ul>","headings":[{"id":"什么是路由","depth":3,"value":"什么是路由"},{"id":"Hash-和-pushState","depth":3,"value":"Hash 和 pushState"},{"id":"经典的-Hash","depth":4,"value":"经典的 Hash"},{"id":"HTML5-中的-pushState","depth":4,"value":"HTML5 中的 pushState"},{"id":"React-Router的使用","depth":3,"value":"React-Router的使用"}],"frontmatter":{"title":"使用 React-Router 创建单页应用","date":"2016-10-30","cover":null,"description":null,"categories":["前端"],"tags":["React","JavaScript"]}},"previous":{"fields":{"slug":"/blogs/2016-11-11-译-CSS-Grid-Flexbox-和-Box-Alignment-网页布局的新系统/"},"frontmatter":{"title":"【译】CSS Grid, Flexbox 和 Box Alignment:网页布局的新系统"}},"next":{"fields":{"slug":"/blogs/2016-09-25-实现一个稍微复杂的simplelist/"},"frontmatter":{"title":"实现一个稍微复杂的simplelist","tags":["前端"],"categories":["技术学习"],"status":null}}},"pageContext":{"id":"6a4ace5b-58e9-5bf6-af6d-ac89fbaf66c3","previousPostId":"c5b7a38e-a1e7-5176-aba2-d021eef28128","nextPostId":"c9476842-70de-5256-b70d-39c555374739"}},
    "staticQueryHashes": ["2841359383"]}