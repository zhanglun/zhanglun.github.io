{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/劝架CommonJS和ESModule/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"b0164ce6-c940-5a43-bb5e-cba2e13310fb","html":"<p class=\"para\">今天在开发过程中遇到一个报错</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">Error [ERR_REQUIRE_ESM]: Must use import to load ES Module: /root/projects/build-tool/node_modules/ora/index.js\nrequire() of ES modules is not supported.\nrequire() of /root/projects/build-tool/node_modules/ora/index.js from /root/projects/build-tool/init.js is an ES module file as it is a .js file whose nearest parent package.json contains &quot;type&quot;: &quot;module&quot; which defines all .js files in that package scope as ES modules.\nInstead rename index.js to end in .cjs, change the requiring code to use import(), or remove &quot;type&quot;: &quot;module&quot; from /root/projects/build-tool/node_modules/ora/package.json.</code>\n        </deckgo-highlight-code>\n<p class=\"para\">糟糕，遇到CommonJS和ESModule两兄弟打架了😢</p>\n<p class=\"para\">错误信息简单翻译一下就是: 我项目中使用<code>require()</code>加载了一个ES Module，后者不支持<code>require()</code>。要么我把自己的 JavaScript 文件后缀改成 <code>.cjs</code> ，然后用 <code>import()</code> 方法加载<code>Ora</code>。要么我把Ora的package.json 中的 <code>type: module</code> 去掉</p>\n<p class=\"para\">按照第一种方式修改之后，代码立马就能跑起来。但是这种方法还是有些问题：</p>\n<ul>\n<li>\n<p class=\"para\">项目中其他文件也有可能会引入到ESModule模式的依赖，我需要改更多文件的后缀</p>\n</li>\n<li>\n<p class=\"para\">文件后缀修改之后，在其被导入的地方需要同步修改</p>\n</li>\n<li>\n<p class=\"para\">目录中<code>.js</code>和<code>.cjs</code>的文件混在一起，都是JavaScript却总是给开发者一种混乱的感觉</p>\n</li>\n<li>\n<p class=\"para\">在文件内部 <code>require()</code> 和 <code>import()</code> 并存，也带来了混乱</p>\n</li>\n</ul>\n<p class=\"para\">那么有没有更加优雅的“劝架”方法呢？在回答这个问题前，我们先来认识认识这两兄弟。</p>\n<h3 class=\"heading\" id=\"CommonJS\" style=\"position:relative;\"><a href=\"#CommonJS\" aria-label=\"CommonJS permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CommonJS</h3>\n<p class=\"para\">在ESModule诞生之前，CommonJS作为NodeJS的模块系统标准。CommonJS是NodeJS社区孵化出的模块标准，实现了JavaScript在服务端的模块化。在CommonJS中，每一个JavaScript文件都是一个模块，可以使用<code>module.exports</code> 或者 <code>exports</code>导出变量，函数和对象。使用<code>require()</code>加载模块。默认使用同步的方式加载模块。</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// foo.js\nmodule.exports = function() { \n  return &#39;Hello foo!&#39;;\n}\n\n// index.js\nvar foo = require(&#39;./foo&#39;);\nconsole.log(foo()); // Hello foo!</code>\n        </deckgo-highlight-code>\n<p class=\"para\">具体的标准可以参考 <a href=\"%5Bhttps://nodejs.org/dist/latest-v16.x/docs/api/modules.html%5D(https://nodejs.org/dist/latest-v16.x/docs/api/modules.html)\" class=\"link-underline\">NodeJS Modules</a></p>\n<p class=\"para\">CommonJS是面向服务端的模块系统，浏览器端无法使用。早期使用AMD模块规范在浏览器端实现JavaScript的模块化开发和加载。Webpack等构建工具，按照NodeJS中的CommonJS标准，实现了一套解析逻辑，在打包阶段注入对CommonJS模块的解析逻辑，使得能够像NodeJS一样加载和导出CommonJS。这使得在前端开发阶段就能用上相对比较“标准化”的模块化开发。</p>\n<h3 class=\"heading\" id=\"ESModule\" style=\"position:relative;\"><a href=\"#ESModule\" aria-label=\"ESModule permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ESModule</h3>\n<p class=\"para\">在 ES6 提出了 ESModule 作为语言标准以后，JavaScript这门语言终于有了自己的模块化方案了，具体的标准可参考<a href=\"%5Bhttps://tc39.es/ecma262/#sec-modules%5D(https://tc39.es/ecma262/#sec-modules)\" class=\"link-underline\">ECMAScript Modules</a>。</p>\n<p class=\"para\">自 Node v8.5以来，开发人员已经能够使用参数<code>--experimental-modules</code> 开启对ES模块规范的支持。从Node v12.4开始，模块可以在.mjs文件（或在某些情况下的.js文件）中定义，或者在Package.json中增加<code>type: modules</code>来表示启用ESModule。而自Node v15.3开始，可以不用 experimental flag 使用ESModule。</p>\n<p class=\"para\">与CommonJS相比对最为直观的差别是，ESModule 使用 import 导出模块，使用 import 加载模块。比如说：</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// foo.mjs\nexport function foo() { \n  return &#39;Hello foo!&#39;; \n}\n\n// index.mjs\nimport { foo } from &#39;./foo.mjs&#39;;\nconsole.log(foo()); // Hello foo!</code>\n        </deckgo-highlight-code>\n<p class=\"para\">当然二者的差别不止如此。而二者之间的差异也间接引发了文章开篇所提到的那个问题。</p>\n<h3 class=\"heading\" id=\"简单谈谈二者的差异\" style=\"position:relative;\"><a href=\"#%E7%AE%80%E5%8D%95%E8%B0%88%E8%B0%88%E4%BA%8C%E8%80%85%E7%9A%84%E5%B7%AE%E5%BC%82\" aria-label=\"简单谈谈二者的差异 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>简单谈谈二者的差异</h3>\n<p class=\"para\">在CommonJS中，require() 是同步的。它不会返回Promise，也支持Callback。加载到模块之后会立刻执行，返回模块返回的对象。</p>\n<p class=\"para\">在ESM中，模块的查找模块加载器。查找阶段，解析JavaScript文件找到import和export的调用，但不会执行import的文件。在解析阶段，ESM加载器可以立即检测到命名导入中的错误，并抛出一个异常，而不需要实际运行依赖的代码。解析通过之后，加载器开始异步下载和解析你导入的JavaScript，构造出依赖的module graph，最后代码开始执行。ES模块加载器保证了，在ES Module 构建的依赖图中，所有的脚本都是并行下载，但是顺序执行。</p>\n<p class=\"para\">可以看到，二者在模块加载和解析的过程已经有很大的差别了。这也使得两种方案下的模块无法很好的互相导入和导出。</p>\n<p class=\"para\">CommonJS不能 <code>require()</code> ESModule的最简单的原因是，后者允许顶层的await ，但是前者不行。</p>\n<p class=\"para\">在ESModule中，你可以这么写：</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export const foo = await fetch(&#39;./data.json&#39;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">但是在CommonJS中你得这么写：</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">(async () =&gt; {\n\tconst { foo } = await fetch(&#39;./foo.mjs&#39;);\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">CommonJS可以导入 ESMoudle，但是不太好用。必须使用异步的动态导入</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">(async () =&gt; {\n    const {foo} = await import(&#39;./foo.mjs&#39;);\n})();</code>\n        </deckgo-highlight-code>\n<p class=\"para\">虽然能用，但是在导出的时候你得导出Promise，这可能会让使用的人感到困惑。</p>\n<p class=\"para\">ESModule 不能在导入阶段直接导入CommonJS具名导出的对象，你可以这么写：</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">import _ form &#39;./lodahs.cjs&#39;;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">但是不能在导入的同时进行解构，因为解构出来的对象是<strong>具名导出的对象</strong>，下面的操作会报错</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">import { shuffle } from &#39;./lodash.cjs&#39;\n// SyntaxError: The requested module &#39;./lodash.cjs&#39; does not provide an export named &#39;shuffle&#39;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">因为CommonJS只有在执行的时候才能计算出<strong>具名导出的对象</strong>，而ESModule的模块计算发生在解析阶段。所以你只能在导入之后再解构。</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">import _ from &#39;./lodash.cjs&#39;;\nconst {shuffle} = _;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">对导出对象的处理上也有差异，在CommonJS中，导出的对象所指向的值是可以修改的</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// b.js\nexports.name = &#39;b&#39;;\n\n// a.js\nlet { name } = require(&#39;b&#39;);\nname = 123;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">而使用ESModule规范的导入被当成常量处理，不允许修改：</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// a.js\nexport let num = 1\nexport const addNumber = ()=&gt;{\n    num++\n}\n\n// b.js\nimport {  num , addNumber } from &#39;./a&#39;\nnum = 2\n\n// 报错\nnum = 2\n    ^\nTypeError: Assignment to constant variable.</code>\n        </deckgo-highlight-code>\n<p class=\"para\">二者有如此多的差异，最好还是不要混用。但是在ESModule出现之前，所有的NPM包都是CommonJS规范标准下开发的。在实际开发过程中难免会遇到二者混合出现的场景，也就是文章开头遇到的错误。</p>\n<p class=\"para\">但是再想想，在日常的前端开发中，似乎经常遇到两种写法混用的情况，而且还没有遇到任何上述提到的问题。为什么呢？</p>\n<p class=\"para\">那是因为现在前端开发基本使用bundler工具打包过，其中使用了babel，将ES6的语法进行了转换，bundler工具最后以CommonJS的模式输出。在产出物中可以找到<code>__esModule</code>属性，将导入的模块标记为ESModule，方便后续的处理。</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// a.js\nexport default 1;\n\n// main.js\nimport a from &#39;./a&#39;;\n\nconsole.log(a);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">转换之后</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// a.js\nObject.defineProperty(exports, &quot;__esModule&quot;, {\n  value: true\n});\nexports.default = 1;\n\n// main.js\n&#39;use strict&#39;;\n\nvar _a = require(&#39;./a&#39;);\n\nvar _a2 = _interopRequireDefault(_a);\n\nfunction _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }\n\nconsole.log(_a2.default);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">所以回到最初的问题，有没有更优雅一些当时来解决我的问题呢？有，加上babel配置进行一次编译。</p>\n<h3 class=\"heading\" id=\"加上一次编译\" style=\"position:relative;\"><a href=\"#%E5%8A%A0%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91\" aria-label=\"加上一次编译 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>加上一次编译</h3>\n<p class=\"para\">@babel/preset-env 是babel的一个核心插件，用来转换代码，让开发者能用上新的特性。其中的modules属性允许我们将ES Module 转换成另一个模块类型。默认是auto， 设置为目标模块类型为CommonJS即可。</p>\n<p class=\"para\">参考：</p>\n<ul>\n<li><a href=\"https://redfin.engineering/node-modules-at-war-why-commonjs-and-es-modules-cant-get-along-9617135eeca1\" class=\"link-underline\">Node Modules at War: Why CommonJS and ES Modules Can’t Get Along</a></li>\n</ul>\n<h3 class=\"heading\" id=\"CommonJS的执行过程\" style=\"position:relative;\"><a href=\"#CommonJS%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\" aria-label=\"CommonJS的执行过程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CommonJS的执行过程</h3>\n<p class=\"para\">在CommonJS中，使用require()加载模块，使用module.exports 导出模块。咱们先来看看require()，考虑一下代码：</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// main.js\nconst fs = require(&#39;fs&#39;);\nconst a = require(&#39;./a&#39;;\nconst b = require(&#39;../b/index.js&#39;);\n\nmodule.exports = {\n\ta,\n  b\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在main.js 真正执行之前，Node会用一个Module Wrapper 将代码包裹</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">(function (exports, require, module, __filename, __dirname) {\n\t// main.js\n\tconst fs = require(&#39;fs&#39;);\n\tconst a = require(&#39;./a&#39;;\n\tconst b = require(&#39;../b/index.js&#39;);\n\t\n\tmodule.exports = {\n\t\ta,\n\t  b\n\t}\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">通过这种方式实现了：</p>\n<ul>\n<li>\n<p class=\"para\">将模块顶部的变量作用域（比如： var, const或者let)限制在模块中，而不是全局对象global</p>\n</li>\n<li>\n<p class=\"para\">提供了一些指向当前模块的，看起来像是全局的变量</p>\n<ul>\n<li>\n<p class=\"para\">module 和 exports ，可以导出模块中的值</p>\n</li>\n<li>\n<p class=\"para\">__filename是模块的绝对路径，__dirname是模块文件所在的文件夹路径</p>\n</li>\n</ul>\n</li>\n</ul>\n<p class=\"para\">解决了模块作用域的问题之后，再来看看require()的事情。使用require可以导入NodeJS模块，JSON和本地文件。假设我们在目录Y中使用require(x)导入X，具体的执行过程如下：</p>\n<deckgo-highlight-code language=\"plaintext\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">1. 如果 X 是核心模块（比如： fs, path, http)\n   a. 返回核心模块\n   b. 停止\n2. 如果 X 以 &#39;/&#39; 开头\n   a. 将 Y 设置为系统根目录\n3. 如果 X 以 &#39;./&#39; or &#39;/&#39; 或者 &#39;../&#39;开头，按照下面的步骤顺序执行\n   a. 执行 LOAD_AS_FILE(Y + X)\n   b. 执行 LOAD_AS_DIRECTORY(Y + X)\n   c. 抛错 &quot;not found&quot;\n4. 如果 X 以 &#39;#&#39; 开头\n   a. 执行 LOAD_PACKAGE_IMPORTS(X, dirname(Y))\n5. 执行 LOAD_PACKAGE_SELF(X, dirname(Y))\n6. 执行 LOAD_NODE_MODULES(X, dirname(Y))\n7. 抛错 &quot;not found&quot;\n\nLOAD_AS_FILE(X)\n1. 如果 X 是一个文件, 以该文件的格式加载。停止\n2. 如果 X.js 是一个文件, 以 JavaScript 文本的形式加载该文件。停止\n3. 如果 X.json 是一个文件, 将它解析为一个 JavaScript 对象。 停止\n4. 如果 X.node 是一个文件, 以二进制插件的形式加载该文件。 停止\n\nLOAD_INDEX(X)\n1. 如果 X/index.js 是一个文件, 以 JavaScript 文本的形式加载该文件。 停止\n2. 如果 X/index.json 是一个文件, 将它解析为一个 JavaScript 对象。停止\n3. 如果 X/index.node 是一个文件, 以二进制插件的形式加载该文件。停止\n\nLOAD_AS_DIRECTORY(X)\n1. 如果 X/package.json 是一个文件,\n   a. 解析这个文件，查找 main 字段\n   b. 如果 main 是可为 false 的值，前往第二步\n   c. 否则 创建一个新的路径 M = X + (json main field)\n   d. LOAD_AS_FILE(M)\n   e. LOAD_INDEX(M)\n   f. 抛错 &quot;not found&quot;\n2. LOAD_INDEX(X)\n\nLOAD_NODE_MODULES(X, START)\n1. 从当前目录开始，向上遍历找到所有的“node_modules” let DIRS = NODE_MODULES_PATHS(START)\n2. 遍历每一个目录，依次执行下面的步骤，直到最后抛出 &quot;not found&quot;\n   a. LOAD_PACKAGE_EXPORTS(X, DIR)\n   b. LOAD_AS_FILE(DIR/X)\n   c. LOAD_AS_DIRECTORY(DIR/X)\n\nNODE_MODULES_PATHS(START)\n1. let PARTS = path split(START)\n2. let I = count of PARTS - 1\n3. let DIRS = [GLOBAL_FOLDERS]\n4. while I &gt;= 0,\n   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE\n   b. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)\n   c. DIRS = DIRS + DIR\n   d. let I = I - 1\n5. return DIRS\n\nLOAD_PACKAGE_IMPORTS(X, DIR)\n1. 找到离DIR最近的作用域SCOPE\n2. 如果没有找到SCOPE，返回\n3. 如果 SCOPE/package.json &quot;imports&quot; 是 null 或者 undefined, 返回\n4. 4. 如果 SCOPE/package.json 的 &quot;imports&quot; 不为空，则检查 X 和 SCOPE 对应的文件的路径 let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE), [&quot;node&quot;, &quot;require&quot;]) 。\n5. RESOLVE_ESM_MATCH(MATCH).\n\nLOAD_PACKAGE_EXPORTS(X, DIR)\n1. Try to interpret X as a combination of NAME and SUBPATH where the name\n   may have a @scope/ prefix and the subpath begins with a slash (`/`).\n2. 如果 X does not match this pattern or DIR/NAME/package.json is not a file,\n   return.\n3. Parse DIR/NAME/package.json, and look for &quot;exports&quot; field.\n4. If &quot;exports&quot; is null or undefined, return.\n5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), &quot;.&quot; + SUBPATH,\n   `package.json` &quot;exports&quot;, [&quot;node&quot;, &quot;require&quot;])defined in the ESM resolver.\n6. RESOLVE_ESM_MATCH(MATCH)\n\nLOAD_PACKAGE_SELF(X, DIR)\n1. Find the closest package scope SCOPE to DIR.\n2. If no scope was found, return.\n3. If the SCOPE/package.json &quot;exports&quot; is null or undefined, return.\n4. If the SCOPE/package.json &quot;name&quot; is not the first segment of X, return.\n5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),\n   &quot;.&quot; + X.slice(&quot;name&quot;.length), `package.json` &quot;exports&quot;, [&quot;node&quot;, &quot;require&quot;])\ndefined in the ESM resolver.\n6. RESOLVE_ESM_MATCH(MATCH)\n\nRESOLVE_ESM_MATCH(MATCH)\n1. let { RESOLVED, EXACT } = MATCH\n2. let RESOLVED_PATH = fileURLToPath(RESOLVED)\n3. If EXACT is true,\n   a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension\n      format. 停止\n4. Otherwise, if EXACT is false,\n   a. LOAD_AS_FILE(RESOLVED_PATH)\n   b. LOAD_AS_DIRECTORY(RESOLVED_PATH)\n5. THROW &quot;not found&quot;</code>\n        </deckgo-highlight-code>\n<blockquote class=\"quote\">\n<p class=\"para\"><code>PACKAGE_IMPORTS_RESOLVE</code> 的定义在 <a href=\"https://nodejs.org/docs/latest-v14.x/api/esm.html#esm_resolver_algorithm\" class=\"link-underline\">esm_resolver_algorithm</a>，里面还执行了其他的算法逻辑，感兴趣的同学可以自行阅读。在模块查找的过程中，如果找到了的package.json中有import字段，便会执行 <code>PACKAGE_IMPORTS_RESOLVE</code> ，返回的是一个对象：</p>\n</blockquote>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">```javascript\nresolvedMatch {\n\tresolved: String; // 模块对应的路径\n\texact: Boolean; // 精确查找 or 模糊查找\n}\n```</code>\n        </deckgo-highlight-code>","tableOfContents":"<ul>\n<li><a href=\"#commonjs\">CommonJS</a></li>\n<li><a href=\"#esmodule\">ESModule</a></li>\n<li><a href=\"#%E7%AE%80%E5%8D%95%E8%B0%88%E8%B0%88%E4%BA%8C%E8%80%85%E7%9A%84%E5%B7%AE%E5%BC%82\">简单谈谈二者的差异</a></li>\n<li><a href=\"#%E5%8A%A0%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91\">加上一次编译</a></li>\n<li><a href=\"#commonjs%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\">CommonJS的执行过程</a></li>\n</ul>","headings":[{"id":"CommonJS","depth":3,"value":"CommonJS"},{"id":"ESModule","depth":3,"value":"ESModule"},{"id":"简单谈谈二者的差异","depth":3,"value":"简单谈谈二者的差异"},{"id":"加上一次编译","depth":3,"value":"加上一次编译"},{"id":"CommonJS的执行过程","depth":3,"value":"CommonJS的执行过程"}],"frontmatter":{"title":"劝架CommonJS和ESModule","date":"2021-02-10","cover":"","description":null,"categories":["技术研究"],"tags":["JavaScrtipt","Node.js"]}},"previous":{"fields":{"slug":"/blogs/2021-04-23-ParseInt()的迷幻行为/"},"frontmatter":{"title":"ParseInt()的迷幻行为"}},"next":{"fields":{"slug":"/blogs/2020-12-14-随机的联想/"},"frontmatter":{"title":"关于JavaScript的随机数","tags":[],"categories":["技术研究"],"status":null}}},"pageContext":{"id":"b0164ce6-c940-5a43-bb5e-cba2e13310fb","previousPostId":"e3d68767-ea0a-5e8e-b97a-870c83e23193","nextPostId":"652f97f3-e58b-5d3c-9e08-6a8d2599b0e2"}},
    "staticQueryHashes": ["2841359383"]}