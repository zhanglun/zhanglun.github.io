{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/使用Rust抓取网页内容/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"b10956ea-e220-5e87-b54e-ade4ea9037dd","html":"<p class=\"para\">在<a href=\"https://github.com/zhanglun/lettura\" class=\"link-underline\">Lettura</a>中已经基本实现了RSS阅读器的能力。日常的基本使用已经没有太大问题。 但是有很多RSS的源返回的主体内容只会有一些很简单的摘要信息，如果想查看更多内容，只能点击外链前往浏览器阅读。当遇到一些“标题党”文章时，前往浏览器阅读又会带来一些来自于这个额外操作的挫败感。所以一直想在Lettura中加上直接阅读全文的能力，让使用体验能够更加舒服一些。</p>\n<p class=\"para\">在一些桌面阅读器中，也支持访问Web页面的能力。部分原生桌面程序比如Reeder、Readkit等通过WebView访问页面，有一些软件则通过工具提取页面的内容，再自定义展示。</p>\n<p class=\"para\">可能有同学会想到，在Web中可以通过iframe标签代替WebView实现页面的加载。但是实际上iframe有诸多的限制，站点可以通过设置响应头<code>X-Frame-Options</code>或者<code>Content-Security-Policy</code>禁止自己的站点被iframe嵌入。</p>\n<deckgo-highlight-code language=\"toml\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&quot;X-Frame-Options&quot;: deny|saneorigin|allow-from [url]\n&quot;Content-Security-Policy&quot;: &quot;frame-ancestors &#39;self&#39;&quot;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">也可以通过JavaScrpit判断当前的页面的顶级窗口<code>window.top</code>和自身窗口<code>window.self</code>是否相等，如果不相等，则是因为嵌入了iframe。</p>\n<deckgo-highlight-code language=\"javascript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">if (window.top != window.self) {\n  window.top.location = window.self.location; // 替换顶级窗口的地址\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">iframe并不能完成解决当前的问题。在Tauri生态中，也有关于相关的<a href=\"https://github.com/tauri-apps/tauri/issues/2975\" class=\"link-underline\">讨论</a>，截止到本文发布时间，还没有实现相关特性。</p>\n<p class=\"para\">页面内容提取在不同编程语言中都有相对较为热门的工具，比如Python中的<a href=\"https://pypi.org/project/mercy-reader/\" class=\"link-underline\">mercy-reader</a>，Node.js中的 <a href=\"https://www.npmjs.com/package/@postlight/mercury-parser\" class=\"link-underline\">@postlight/mercury-parser</a>。万变不离其宗，其核心的思路都可以简化为以下几个步骤：</p>\n<ul>\n<li>\n<p class=\"para\">发起HTTP请求访问url</p>\n</li>\n<li>\n<p class=\"para\">解析返回的HTML内容，构建返回的数据格式</p>\n</li>\n</ul>\n<p class=\"para\">既然如此，用Rust来实现内容的提取吧。参考自 <a href=\"https://www.scrapingbee.com/blog/web-scraping-rust/\" class=\"link-underline\">https://www.scrapingbee.com/blog/web-scraping-rust/</a> 的文章，使用 reqwest 发起网络请求，使用 scraper 解析页面内容，抓取页面案例也依然使用IMDB。</p>\n<h2 class=\"heading subtitle heading\" id=\"创建项目添加依赖\" style=\"position:relative;\"><a href=\"#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96\" aria-label=\"创建项目添加依赖 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>创建项目，添加依赖</h2>\n<p class=\"para\">为了更好的演示，创建一个全新的项目。</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">cargo new web_scraper</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在Cargo.toml中添加依赖。</p>\n<deckgo-highlight-code language=\"toml\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">[dependencies]\nreqwest = {version = &quot;0.11&quot;, features = [&quot;blocking&quot;]}\nscraper = &quot;0.12.0&quot;</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"获取网页的HTML\" style=\"position:relative;\"><a href=\"#%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E7%9A%84HTML\" aria-label=\"获取网页的HTML permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>获取网页的HTML</h2>\n<p class=\"para\">reqwest是Rust生态中使用相当广泛的HTTP请求库，它提供的功能非常全面，基本上能满足大部分浏览器的能力。<a href=\"https://docs.rs/reqwest/latest/reqwest/struct.Client.html\" class=\"link-underline\">reqwest::Client</a> 默认是异步的，少量请求时，使用同步的<a href=\"https://docs.rs/reqwest/latest/reqwest/blocking/index.html\" class=\"link-underline\">reqwest::blocking</a>会更加方便一些。</p>\n<deckgo-highlight-code language=\"rust\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fn main() {\n\n    let response = reqwest::blocking::get(\n        &quot;https://www.imdb.com/search/title/?groups=top_100&amp;sort=user_rating,desc&amp;count=100&quot;,\n    )\n    .unwrap()\n    .text()\n    .unwrap();\n\n}</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"从-HTML-中提取信息\" style=\"position:relative;\"><a href=\"#%E4%BB%8E-HTML-%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BF%A1%E6%81%AF\" aria-label=\"从 HTML 中提取信息 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><strong>从 HTML 中提取信息</strong></h2>\n<p class=\"para\">Web 抓取中最难的部分通常是从 HTML 文档中获取需要的特定信息。在Python中有pyquery，Node.js中有cherrio，JavaScript中有jQuery，Rust 中常用的工具是 scraper 库。它将 HTML 文档解析为树状结构来工作，可以使用 CSS 选择器来查询元素。在核心用法上这几个工具基本上大同小异。</p>\n<p class=\"para\">首先将返回的数据解析成为scraper定义的数据结构。</p>\n<deckgo-highlight-code language=\"rust\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let document = scraper::Html::parse_document(&amp;response);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">然后通过选择器找到自己想要的内容。比如，在这个例子中，我要找到IMDB中Top100的电影标题。首先通过浏览器的审查元素找到页面的结构，</p>\n<deckgo-highlight-code language=\"rust\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;h3 class=&quot;lister-item-header&quot;&gt;\n    &lt;span class=&quot;lister-item-index unbold text-primary&quot;&gt;1.&lt;/span&gt;\n    &lt;a href=&quot;/title/tt0111161/?ref_=adv_li_tt&quot;&gt;The Shawshank Redemption&lt;/a&gt;\n    &lt;span class=&quot;lister-item-year text-muted unbold&quot;&gt;(1994)&lt;/span&gt;\n&lt;/h3&gt;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">构造出能够命中元素的CSS选择器，获取到元素内容</p>\n<deckgo-highlight-code language=\"rust\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let title_selector = scraper::Selector::parse(&quot;h3.lister-item-header&gt;a&quot;).unwrap();\nlet titles = document.select(&amp;title_selector).map(|x| x.inner_html());</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><code>titles</code> 是一个包含了100个元素的迭代器，可以遍历输出</p>\n<deckgo-highlight-code language=\"rust\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">titles.zip(1..101).for_each(|(item, number)| println!(&quot;{}. {}&quot;, number, item));</code>\n        </deckgo-highlight-code>\n<p class=\"para\">完整的代码如下：</p>\n<deckgo-highlight-code language=\"rust\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">fn main() {\n    let response = reqwest::blocking::get(\n        &quot;https://www.imdb.com/search/title/?groups=top_100&amp;sort=user_rating,desc&amp;count=100&quot;,\n    )\n    .unwrap()\n    .text()\n    .unwrap();\n\n    let document = scraper::Html::parse_document(&amp;response);\n\n    let title_selector = scraper::Selector::parse(&quot;h3.lister-item-header&gt;a&quot;).unwrap();\n\n    let titles = document.select(&amp;title_selector).map(|x| x.inner_html());\n\n    titles\n        .zip(1..101)\n        .for_each(|(item, number)| println!(&quot;{}. {}&quot;, number, item));\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">接下来执行<code>cargo run</code>，如果编译通过，你应该可以看到以下的输出：</p>\n<deckgo-highlight-code language=\"rust\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">1. The Shawshank Redemption\n2. The Godfather\n3. The Dark Knight\n4. The Lord of the Rings: The Return of the King\n5. Schindler&#39;s List\n6. The Godfather: Part II\n7. 12 Angry Men\n8. Pulp Fiction\n9. Inception\n10. The Lord of the Rings: The Two Towers\n...</code>\n        </deckgo-highlight-code>","tableOfContents":"<ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96\">创建项目，添加依赖</a></li>\n<li><a href=\"#%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E7%9A%84html\">获取网页的HTML</a></li>\n<li><a href=\"#%E4%BB%8E-html-%E4%B8%AD%E6%8F%90%E5%8F%96%E4%BF%A1%E6%81%AF\"><strong>从 HTML 中提取信息</strong></a></li>\n</ul>","headings":[{"id":"创建项目添加依赖","depth":2,"value":"创建项目，添加依赖"},{"id":"获取网页的HTML","depth":2,"value":"获取网页的HTML"},{"id":"从-HTML-中提取信息","depth":2,"value":"从 HTML 中提取信息"}],"frontmatter":{"title":"使用Rust抓取网页内容","date":"2022-10-13","cover":"","description":null,"categories":["技术研究"],"tags":["Rust"]}},"previous":{"fields":{"slug":"/blogs/结合Diesel实现翻页查询/"},"frontmatter":{"title":"结合Diesel实现翻页查询"}},"next":{"fields":{"slug":"/blogs/学习项目管理-项目管理的意义/"},"frontmatter":{"title":"学习项目管理-项目管理的意义","tags":["项目管理","读书笔记"],"categories":["解决方案"],"status":"publish"}}},"pageContext":{"id":"b10956ea-e220-5e87-b54e-ade4ea9037dd","previousPostId":"2a9eb382-4791-51e8-b300-ca006fa7ba67","nextPostId":"fbfce5da-2ee5-557f-bb56-e4c422e457a3"}},
    "staticQueryHashes": ["2841359383"]}