{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/Node学习笔记-Wrangling the File System/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"d757b860-334b-547e-9fb8-66da22479a1e","html":"<p class=\"para\">在开发过程中，有时候会需要访问一些本地的文件，对文件进行一些操作。现在来对这方面的问题展开学习。下面是几个简单的例子，包括监听文件的变化和读取命令行中的参数</p>\n<h2 class=\"heading subtitle heading\" id=\"监听文件的变化\" style=\"position:relative;\"><a href=\"#%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8C%96\" aria-label=\"监听文件的变化 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>监听文件的变化</h2>\n<p class=\"para\">不急着动手，先想想如果做。首先，Node需要访问本地的文件，访问到文件后才有办法监听。Node自带<code>fs</code>模块可以帮助访问本地文件，更巧的是，fs模块本身就提供了<a href=\"http://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener\" class=\"link-underline\">watch()</a>这个方法。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var fs = require(&#39;fs&#39;);\r\n\r\nfs.watch(&#39;target.txt&#39;, function() {\r\n    console.log(&quot;File &#39;target.txt&#39; just changed!&quot;);\r\n});\r\n\r\nconsole.log(&quot;Now watching target.txt for changes...&quot;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">很简单的例子，自己的笔记就没有必要再解释了。无非就是，在引入fs模块之后，调用fs提供的watch方法对文件进行监听，监听时，每发生了修改就调用watch方法中的回调函数，打印出“File ‘target.txt’ just changed!”</p>\n<h2 class=\"heading subtitle heading\" id=\"现在来说说如何在Node中读取命令行中的参数\" style=\"position:relative;\"><a href=\"#%E7%8E%B0%E5%9C%A8%E6%9D%A5%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E5%9C%A8Node%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0\" aria-label=\"现在来说说如何在Node中读取命令行中的参数 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>现在来说说如何在Node中读取命令行中的参数</h2>\n<p class=\"para\">在上面的例子上稍微修改。需要用到新的东西：Node中的一个全局对象<a href=\"http://nodejs.org/api/process.html#process_process\" class=\"link-underline\"><code>process</code></a>。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var fs = require(&quot;fs&quot;),\r\n    filename = process.argv[2];\r\n\r\nconsole.log(process.argv);\r\n\r\nif(!filename){\r\n    console.log(&quot;A file to watch  must be specified&quot;);\r\n}\r\n\r\nfs.watch(filename, function() {\r\n    console.log(&quot;File &quot; + filename + &quot; just changed!&quot;);\r\n});\r\nconsole.log(&quot;Now watching &quot; + filename + &quot; for changes...&quot;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">保存文件之后，可以像这样启动它：</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">node watcher-argv.js target.txt</code>\n        </deckgo-highlight-code>\n<p class=\"para\">效果看起来和上面一个例子简直是一模一样的，但是后者的代码更加灵活，因为监控的文件是以参数的形式传递给函数，而不是写死在源代码中。</p>\n<p class=\"para\">这个<code>process</code>全局对象可以在Node的任何地方使用，它是 EventEmitter的一个实例。<a href=\"http://nodejs.org/api/process.html#process_process_argv\" class=\"link-underline\">process.argv</a>是一个数组，它包含了命令行中的参数。第一个元素一定是”node”，或者<code>node.exe</code>的路径，第二个元素是当前执行的js文件的路径，第三个之后，包括第三个的元素都来自命令行参数。如果输出<code>process.aegv</code>的话，在我的window下，如果是CMD中，第一个元素是一个字符串“node”，在powershell中第一个元素是<code>node.exe</code>的路径。</p>\n<h2 class=\"heading subtitle heading\" id=\"Spawning-a-Child-Process\" style=\"position:relative;\"><a href=\"#Spawning-a-Child-Process\" aria-label=\"Spawning a Child Process permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spawning a Child Process</h2>\n<p class=\"para\">现在利用Node中的<a href=\"http://nodejs.org/api/child_process.html\" class=\"link-underline\"><code>child-process</code></a>的模块，来增强我们的程序。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var fs = require(&#39;fs&#39;),\r\n    spawn = require(&#39;child_process&#39;).spawn,\r\n    filename = process.argv[2];\r\nif (!filename) {\r\n    throw Error(&quot;A file to watch must be specified!&quot;);\r\n}\r\nfs.watch(filename, function() {\r\n    var ls = spawn(&#39;ls&#39;, [&#39;-lh&#39;, filename]);\r\n    ls.stdout.pipe(process.stdout);\r\n});\r\nconsole.log(&quot;Now watching &quot; + filename + &quot; for changes...&quot;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">修改文件之后，你会发现在终端中会这样显示：</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">-rw-r--r-- 1 CrispElite Admin 0B Dec 19 22:45 target.txt</code>\n        </deckgo-highlight-code>\n<p class=\"para\">关于<code>spawn</code>的使用，官方给出的<a href=\"http://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options\" class=\"link-underline\">文档</a>很详细。\r\n<code>spawn()</code>的调用实质上运行给的命令指定的进程，数组中的元素是这条命令的参数。参数默认情况下是一个空数组。这个方法返回一个<code>ChildProcess</code>对象，它的<code>stdin</code>,<code>stdout</code>,<code>stderr</code> 都是可以访问的数据流。而<code>pipe</code>的作用就是将子进程的数据直接发送到标准输出流中。</p>\n<h2 class=\"heading subtitle heading\" id=\"Capturing-Data-from-an-EventEmitter\" style=\"position:relative;\"><a href=\"#Capturing-Data-from-an-EventEmitter\" aria-label=\"Capturing Data from an EventEmitter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Capturing Data from an EventEmitter</h2>\n<p class=\"para\">==！（未完……）</p>\n<p class=\"para\">参考： <strong>Nodejs the right way</strong></p>","tableOfContents":"<ul>\n<li><a href=\"#%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8C%96\">监听文件的变化</a></li>\n<li><a href=\"#%E7%8E%B0%E5%9C%A8%E6%9D%A5%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%BD%95%E5%9C%A8node%E4%B8%AD%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0\">现在来说说如何在Node中读取命令行中的参数</a></li>\n<li><a href=\"#spawning-a-child-process\">Spawning a Child Process</a></li>\n<li><a href=\"#capturing-data-from-an-eventemitter\">Capturing Data from an EventEmitter</a></li>\n</ul>","headings":[{"id":"监听文件的变化","depth":2,"value":"监听文件的变化"},{"id":"现在来说说如何在Node中读取命令行中的参数","depth":2,"value":"现在来说说如何在Node中读取命令行中的参数"},{"id":"Spawning-a-Child-Process","depth":2,"value":"Spawning a Child Process"},{"id":"Capturing-Data-from-an-EventEmitter","depth":2,"value":"Capturing Data from an EventEmitter"}],"frontmatter":{"title":"Node学习笔记-Wrangling the File System","date":"2014-11-07","cover":null,"description":null,"categories":["Node.js"],"tags":["笔记","Node.js"]}},"previous":{"fields":{"slug":"/blogs/定时将图片保存在SAE的Storage中/"},"frontmatter":{"title":"定时将图片保存在SAE的Storage中"}},"next":{"fields":{"slug":"/blogs/Node学习笔记-Data Sources and Flow Control/"},"frontmatter":{"title":"Node学习笔记-Data Sources and Flow Control","tags":["笔记","Node.js"],"categories":["Node.js"],"status":null}}},"pageContext":{"id":"d757b860-334b-547e-9fb8-66da22479a1e","previousPostId":"52b2af54-ff9d-5821-b562-9e9feb09b9e0","nextPostId":"f1d9670a-36de-599d-962c-35d000d9401a"}},
    "staticQueryHashes": ["2841359383"]}