{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/Node学习笔记-Node.js核心API之Util/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"f0d46990-9f00-520a-8fe4-122e213c4e45","html":"<p class=\"para\">最近正在学习Node，在图书馆借了基本关于Node的书，同时在网上查阅资料，颇有收获，但是整体感觉对Node的理解还是停留在一个很模棱两可的状态。比如Node中的模块，平时练习就接触到那么几个，其他的一些模块暂时只会在学习的时候接触到，不常用便就荒废了。正所谓好记心不如烂笔头，多做笔记还是更有利于理解和记忆。自己做的总结也方便回头复习，所以决定踏上漫长的修炼之旅……</p>\n<!--more-->\n<p class=\"para\">##util模块\r\nutil 是一个 Node.js 核心模块，提供了一些常用函数，用于弥补核心 JavaScript 的功能过于精简的不足。这些函数都包含在 <code>util</code> 模块中，可以通过引用模块来使用它们。</p>\n<p class=\"para\">###util.format(format, […])\r\n返回一个格式化的字符串，其作用效果有点类似 <code>printf</code>。第一个参数是一个包含若干个占位符的字符串。将每个参数转换后的值代替参数对应的占位符。支持占位符有：</p>\n<ul>\n<li>%s - String.</li>\n<li>%d - Number (both integer and float).</li>\n<li>%j - JSON.</li>\n<li>% - single percent sign (’%’). This does not consume an argument.</li>\n</ul>\n<p class=\"para\">如果第一个参数中的占位符找不到与之对应的参数， 那么这个占位符将不会被替换</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">util.format(&#39;%s:%s&#39;, &#39;foo&#39;); // &#39;foo:%s&#39;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">如果占位符太少，多余的参数会调用 <code>util.inspect()</code> 转换成字符串，然后用空格将多余的字符串拼接在一起。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">util.format(&#39;%s:%s&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;zhanglun&#39;); // &#39;foo:bar baz zhanglun&#39;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">如果第一个参数不是一个需要格式化的字符串，那么这个方法会将所有的参数用空格拼接成一个新的字符串，然后返回这个字符串。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">util.format(1, 2, 3, &quot;zhanglun&quot;); // &#39;1 2 3 \\&#39;zhanglun\\&#39;&#39;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">###util.debug(string)\r\n这是一个同步输出的方法。当执行到这一句代码的时候会阻塞进程，并且以标准错误的形式将参数 string 输出。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">require(&#39;util&#39;).debug(&#39;message on stderr&#39;); //message on stderr</code>\n        </deckgo-highlight-code>\n<p class=\"para\">###util.log(string)\r\n以标准输出的形式输出。它将获取当前的时间戳，并和参数 string 一起输出，中间用 ” - ” 连接。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">require(&#39;util&#39;).log(&#39;Timestmaped message.&#39;); //15 May 21:41:33 - Timestmaped message</code>\n        </deckgo-highlight-code>\n<p class=\"para\">###util.inspect(object,[options])\r\n这个方法将任意对象转换为字符串，对调试来说很有用。至少接受一个参数 object，即需要处理的字符串。此外还可以传递一个可选的参数 options，用来控制字符串的输出格式。</p>\n<ul>\n<li><code>showHidden</code>——如果<code>showHidden</code>为 true，那么这个方法将会把参数 object 中不可枚举的属性输出。</li>\n<li><code>depth</code>——表示最大的递归层数。如果指定了 depth，也就指定了格式化代码时递归的次数。如果不指定depth，默认会递归2次，指定为 null 时将不限定次数，完整地遍历对象。</li>\n<li><code>color</code>——如果<code>color</code>为 true，输出的格式将会以 ANSI 颜色编码，可以在终端显示更漂亮的效果。</li>\n<li><code>customInspect</code>——如果为 false，那么将要被遍历检查的对象（参数object）中定义的<code>inspect（）</code>函数将不会被调用。 默认值为 true。</li>\n</ul>\n<p class=\"para\">下面先来看一个例子：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var util = require(&quot;util&quot;);\r\nvar obj1 = {\r\n        &quot;aa&quot;: function() {\r\n            console.log(&quot;aa&quot;);\r\n        },\r\n        &quot;inspect&quot;: function() {\r\n            console.log(&quot;obj1&#39;s inspect()&quot;);\r\n        },\r\n        &quot;bb&quot;: function() {\r\n            console.log(&quot;bb&quot;);\r\n        }\r\n    },\r\n    obj2 = {\r\n        &quot;cc&quot;: function() {\r\n            console.log(&quot;cc&quot;);\r\n        },\r\n        &quot;inspect&quot;: function() {\r\n            console.log(&quot;obj2&#39;s inspect()&quot;);\r\n            return &quot;Hello&quot;;\r\n        },\r\n        &quot;dd&quot;: function() {\r\n            console.log(&quot;dd&quot;);\r\n        }\r\n    };\r\n\r\nvar str1 = util.inspect(obj1, {\r\n    showHidden: false,\r\n    depth: null,\r\n    customInspect: false\r\n}),\r\n    str2 = util.inspect(obj2, {\r\n        showHidden: false,\r\n        depth: null,\r\n        customInspect: true\r\n    });\r\n\r\nconsole.log(&quot;str1 : &quot; + str1);\r\nconsole.log(&quot;str2 : &quot; + str2);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">其输出结果：</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">obj2&#39;s inspect()\r\nstr1 : { aa: [Function], inspacet: [Function], bb: [Function] }\r\nstr2 : Hello</code>\n        </deckgo-highlight-code>\n<p class=\"para\">暂时先忽略颜色，待会接着说，先看<code>customInspect</code>。上面的例子中，有两个对象：obj1 和 obj2，内部都定义了一个 inspect()函数，调用<code>util.inspect()</code>方法时，只有<code>customInspect</code>不同。当<code>customInspect</code>为 true 时，比如 obj2，其内部的 <code>util.inspect()</code>函数在执行<code>util.inspect()</code>时就被调用了，同时只会返回这个内部的 <code>util.inspect()</code>执行后的返回值，如果没有函数显示地调用 return 语句，则返回 undefined。可以试试修改上面的示例代码中 obj2 的<code>inspect()</code>的返回值。而对于 obj1，其<code>customInspect</code>，所以其内部的<code>inspect()</code>并不会被调用。</p>\n<p class=\"para\">####定制颜色\r\n可以通过两个对象：<code>util.inspect.styles</code>和<code>util.inspect.colors</code>全局定制输出的颜色。<code>util.inspect.styles</code>是一个<code>util.inspect.colors</code>中的颜色到样式的映射。后面的没搞懂怎么回事，以后再补上。</p>\n<p class=\"para\">###util.isArray(object)\r\n如果参数 object 是一个数组，返回 true，否则返回 false。\r\nvar util = require(‘util’);</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">util.isArray([])\r\n  // true\r\nutil.isArray(new Array)\r\n  // true\r\nutil.isArray({})\r\n  // false\r\n  </code>\n        </deckgo-highlight-code>\n<p class=\"para\">###util.isRegExp(object)\r\n如果参数 object 是一个 RegExp 对象，返回 true，否则返回 false。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var util = require(&#39;util&#39;);\r\n\r\nutil.isRegExp(/some regexp/)\r\n  // true\r\nutil.isRegExp(new RegExp(&#39;another regexp&#39;))\r\n  // true\r\nutil.isRegExp({})\r\n  // false\r\n  </code>\n        </deckgo-highlight-code>\n<p class=\"para\">###util.isDate(object)</p>\n<p class=\"para\">如果参数 object 是一个 Date 对象，返回 true，否则返回 false。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var util = require(&#39;util&#39;);\r\n\r\nutil.isDate(new Date())\r\n  // true\r\nutil.isDate(Date())\r\n  // false (without &#39;new&#39; returns a String)\r\nutil.isDate({})\r\n  // false\r\n  </code>\n        </deckgo-highlight-code>\n<p class=\"para\">###util.isError(object)</p>\n<p class=\"para\">如果参数 object 是一个 Error 对象，返回 true，否则返回 false。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var util = require(&#39;util&#39;);\r\n\r\nutil.isError(new Error())\r\n  // true\r\nutil.isError(new TypeError())\r\n  // true\r\nutil.isError({ name: &#39;Error&#39;, message: &#39;an error occurred&#39; })\r\n  // false\r\n  </code>\n        </deckgo-highlight-code>\n<p class=\"para\">###util.inherits(constructor, superConstructor)\r\n这是一个实现对象之间原型继承的函数。constructor 将会继承 superConstructor。另外，通过<code>constructor.super_</code>可以访问到 superConstructor。</p>\n<deckgo-highlight-code  theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var util = require(&quot;util&quot;);\r\nvar events = require(&quot;events&quot;);\r\n\r\nfunction MyStream() {\r\n}\r\nutil.inherits(MyStream, events.EventEmitter);\r\n\r\nMyStream.prototype.write = function(data) {\r\n    this.emit(&quot;data&quot;, data);\r\n}\r\n\r\nvar stream = new MyStream();\r\n\r\n\r\nconsole.log(stream instanceof events.EventEmitter); // true\r\nconsole.log(MyStream.super_); \r\n//{ [Function: EventEmitter] listenerCount: [Function] }\r\nconsole.log(MyStream.super_ === events.EventEmitter); // true\r\n\r\nstream.on(&quot;data&quot;, function(data) {\r\n    console.log(&#39;Received data: &quot;&#39; + data + &#39;&quot;&#39;);\r\n})\r\nstream.write(&quot;It works!&quot;); // Received data: &quot;It works!&quot;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">util 模块还提供了其他的一些工具函数，更多详情请戳<a href=\"http://nodejs.org/api/util.html#util_util\" class=\"link-underline\">这里</a>。</p>","tableOfContents":"","headings":[],"frontmatter":{"title":"Node学习笔记—Node.js核心API之Util","date":"2014-05-15","cover":null,"description":null,"categories":["Node.js"],"tags":["笔记","Node.js"]}},"previous":{"fields":{"slug":"/blogs/(译)取消事件冒泡的危害/"},"frontmatter":{"title":"(译)阻止事件传播的危害"}},"next":{"fields":{"slug":"/blogs/Node学习笔记-Node.js核心API之HTTP/"},"frontmatter":{"title":"Node学习笔记-Node.js中的核心API之HTTP","tags":["笔记","Node.js"],"categories":["Node.js"],"status":null}}},"pageContext":{"id":"f0d46990-9f00-520a-8fe4-122e213c4e45","previousPostId":"f9448968-cbfe-53a8-a14e-57742cbdf09b","nextPostId":"ce460098-5488-5b8c-841b-7c37b9a9e323"}},
    "staticQueryHashes": ["2841359383"]}