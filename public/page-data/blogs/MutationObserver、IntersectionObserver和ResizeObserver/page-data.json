{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/MutationObserver、IntersectionObserver和ResizeObserver/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"b1766f50-a2ca-52ce-b40d-d080274ea52f","html":"<p class=\"para\">在之前的<a href=\"../%E4%BB%8Egetboundingclientrect%E5%88%B0intersection-observer/index.md\" class=\"link-underline\">从getboundingclientrect到intersection-observer</a>中提到了<code>Intersection Observer API</code>，今天趁热打铁，将现有的其他几个Observer API 一并整理，方便查阅</p>\n<h2 class=\"heading subtitle heading\" id=\"IntersectionObserver\" style=\"position:relative;\"><a href=\"#IntersectionObserver\" aria-label=\"IntersectionObserver permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IntersectionObserver</h2>\n<p class=\"para\">字面翻译：交叉的观察者。即观察两个元素之间的交叉情况</p>\n<p class=\"para\">Web的传统位置计算机制依赖于显式查询DOM的状态。 其中一些会导致样式重新计算和布局(比如前文提到的<code>offsetHeight</code>, <code>offsetWidth</code> 和 <code>getBoundingClientRect()</code>)，并且经常需要JavaScript脚本需要轮询此信息，因此经常会让浏览器触发多余的重新计算和布局。在实际工作中，追踪或者判断DOM是否出现在客户端视图窗口中是一个很常见的操作。比如图片懒加载，滚动时元素进入的动画等等。一般来说可以通过监听滚动事件，使用<code>getBoundingClientRect()</code>来计算元素的位置。但正如前文所言，这存在性能问题。\n<code>Intersection Observer API</code> 就是为这而<a href=\"https://github.com/w3c/IntersectionObserver/blob/master/explainer.md\" class=\"link-underline\">设计</a>的，显着降低其CPU，GPU和能源消耗。</p>\n<h3 class=\"heading\" id=\"创建一个-IntersectionObserver\" style=\"position:relative;\"><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-IntersectionObserver\" aria-label=\"创建一个 IntersectionObserver permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>创建一个 IntersectionObserver</h3>\n<p class=\"para\">IntersectionObserver 的 API 非常简洁</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const observer = new IntersectionObserver(changes =&gt; {\n  for (const change of changes) {\n    console.log(change)\n  }\n}, {});\n\n// 观察目标元素的可见性变化\nobserver.observe(target);\n\n// 停止对一个元素的观察\nobserver.unobserve(target);\n\n// 停止对所有目标元素可见性变化的观察\nobserver.disconnect();</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"callback\" style=\"position:relative;\"><a href=\"#callback\" aria-label=\"callback permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>callback</h3>\n<p class=\"para\">回调接收 IntersectionObserverEntry 对象和观察者的列表：</p>\n<deckgo-highlight-code language=\"ts\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const callback = function(entries: IntersectionObserverEntry[], observer: IntersectionObserver) { \n  entries.forEach(entry =&gt; {\n    // Each entry describes an intersection change for one observed\n    // target element:\n    //   entry.boundingClientRect\n    //   entry.intersectionRatio\n    //   entry.intersectionRect\n    //   entry.isIntersecting\n    //   entry.rootBounds\n    //   entry.target\n    //   entry.time\n  });\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><code>entries</code>是一个数组，和<code>threshold</code>对应。即使<code>threshold</code>输入的是一个数字，<code>entries</code>也会返回数组。下图是<code>IntersectionObserverEntry</code>的结构</p>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2d9e4db5e60c060aa6af53a7319481c0/8b936/intersection-observer-api.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94.14893617021278%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/UlEQVQ4y5WS607jMBCFef93QkICAYW2QuJWlTaEpElz8yUXO47j8awGCltWXbo7GkX+4eOc+c6cGGOSKIneomAVBOvXIAjykltrYRgQAI3Brtu1Uugc7tUJIva1YSvGoqaXRnLBWMU5t0LQ1ZcXvLjAyQTnc7y+xqcnTBLcbDCOMYpIDBZEVKexsRb/LAB6AgC9p6+15OWzSeyME3GdbwfTg0cP4D+KBF+1f9637R2UG1VLwP8sEo+Dbcq+r02e5tu0ShOuOm+0I5MAqDWh0pqsKkXktMa6RudIrIQWa87WgsfiLcyWi224KtqYoRC4WOBshjc3OJ3i7S3e3xOz6ZTgcf4+8+D4q8g25j2Ij9n87gBwxDZYJ6M6SwatYIfGoz94/QP7J7+duAgbIdxPOf0VmB3rQutm4Fzwindd5/seT0/x4QEfH2m8szMaeDYjBGX5TayEZkteRSII8iwpuu0Wq4oWaz7Huzu8usLzc3prMsHLS3x+/jJCYtMObMnSsGG8UVqptqOQvEfGMMtQSspGCMrpEDDgoajyAY6uyfe1260nC2VVWDf635cAdqj2+8CfARpmrPUjuNGNo3P+39dTN1qmbVt2ZRjzvGirihIqChr4uFhqvmnzjcpjKXndSNFI2QtBnH4WA4CWfS+GTrWMV3YcB2vHcQR/3PsvrBRMEro/rEYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"intersection-observer-api.png\"\n        title=\"intersection-observer-api.png\"\n        src=\"/static/2d9e4db5e60c060aa6af53a7319481c0/1d69c/intersection-observer-api.png\"\n        srcset=\"/static/2d9e4db5e60c060aa6af53a7319481c0/4dcb9/intersection-observer-api.png 188w,\n/static/2d9e4db5e60c060aa6af53a7319481c0/5ff7e/intersection-observer-api.png 375w,\n/static/2d9e4db5e60c060aa6af53a7319481c0/1d69c/intersection-observer-api.png 750w,\n/static/2d9e4db5e60c060aa6af53a7319481c0/78797/intersection-observer-api.png 1125w,\n/static/2d9e4db5e60c060aa6af53a7319481c0/8b936/intersection-observer-api.png 1368w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p class=\"para\">下图可以清晰的看出<code>intersectionRadio</code>的意义</p>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9bc316a320eafbfc56bd4b26454cab96/cc155/intersectratio.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 98.93617021276596%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEr0lEQVQ4y42Ua08TaRiGR7rxi9mP/IT9B6u7RrPxEAJyKqX0RIEoSlRQQDCFCkqhWBtaSEgsXcgWbIusca3Qw5QeKEVoS2em7ZSKa4if/Eb8C2PfezODEk02m53kyv3cM5N7njfPOy9FURS1l07LSrkcxefzjtyrV2CWlgTW4yGsxwMJt/sIjwfMN7WE10uYxcVygabBv3+vFvOogt8vK21tUXsM43hz5w5iDQ1CvLmZxJubEVcqsdHSgg2VCnGFAgm1WvJiLaFUkmh1dTltNuPdp09fAoNBGR+NUnwm42AePwY7PCxwJhNhR0fBPnwIzmRCwWJBZnAQjNGIVG8v4hoNNlpbsaHXk1hTUzljtWL/8FBNOZ1OqrC6KttLJqliNuvY6u5GtLZWEL983EVT03FHMbn8iMbGI5qayPrly+XU+PhRh2JgKZ2WvcvnqRLPP82/eAF2YUHgXC7CuVz4TxYXRQg7P1/mg0GUPnxQSYF/ZzKy4u4uxXOcM+f1gnn6VGCdTsI6nfiOuTkwc3PHKuF0kuzsbLng84E/ONBSNpvtxIDFQtlmZn6JhELrL3t78Uyp/OzRaolHq4Vbq4WoHo0GHp0Oy3o9vK2tki63tWG5o4O4W1qI32xGIBZzUgCkwVjt9l8LmYwz/OAB1m7eFPx375K17m4EenoQ7O8HPTgI3/Xr8HV1IdDXh+ctLfAqFFhWKslSTQ2JmM1IF4sPqbNnz1aIgU/s9tNcOr0QuHcPL/V64fWNG8R37Rp8nZ14dfUqVru68Fd7O/5Uq/FS7Ewuh6euDt7GRrJ46RIJj40hVSw+omQy2U9SoNV6mi8U5nPRKLKrq0LW7ydZvx/HrK2BCQTABIOSsqEQWJoWIUwgQPZ2dpDc3n5EVVRU/PbjqVOnTCbTr3vF4vwblwtRq1WIT0+TuN2O2DfEp6ch3bPZJJX8zAyJWq0kvbKCrVRKCjx3UiarHDIaz+/x/O+vb9+Gu6pK8DY0EG99PUSWGxsl3LW10jKfKxRSvVRVhWc1NeSP8+dJ0GDADsdJgWfEJU/Z7T/nWXYhNjmJ8MCAEBkZIetDQ4gYjYiOjGBjfBzBvj6Ig0pMTMDf3S0OBCtqNfHU15N1kwnbLPuIqqysPCkGTlosZ/h8fsF36xZcFy8K7tpa4r5yBc9EamokdX+tq6ulWqKujrguXCCh4eGjQPESt87k5OTp/bdvHXwyiVw4LOQiEZKLRPA/IBxNk1IqhTc7Ow8og8FwQtPZSU1NTZ3bSiZ9sfl5BJ88+UzbbISemsK/EfrW22wkaLGQhNuNUCQyK/16Xzb3iZ3t7ZXYwAACCsXnkFZLQhoNROjWVoR0OgRFr9OB1usRVKulZ+J7Abm8vDE2hiTD3JUCmUjkh93NTWqf52dZ8fi6f1/IjY4SbngYnNGI3MgICuPj2O3vR7qnB+zQEDbFo0ulQkKrJfGGhnJmYgIHh4cKKXA/mZQdlErU22LRkTIYkFCphGRHB0m2tSHZ3o5NvV5S0YtBok9otUhoNEjodCQul5czZjP2P37USEPhsllZjuMohmEcTDyOLE0L2XCYZMNhscZ3+pX1dTBHkCxNl9nNTewyjPofpgrvWq7q9LwAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"intersectratio.png\"\n        title=\"intersectratio.png\"\n        src=\"/static/9bc316a320eafbfc56bd4b26454cab96/1d69c/intersectratio.png\"\n        srcset=\"/static/9bc316a320eafbfc56bd4b26454cab96/4dcb9/intersectratio.png 188w,\n/static/9bc316a320eafbfc56bd4b26454cab96/5ff7e/intersectratio.png 375w,\n/static/9bc316a320eafbfc56bd4b26454cab96/1d69c/intersectratio.png 750w,\n/static/9bc316a320eafbfc56bd4b26454cab96/cc155/intersectratio.png 886w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p class=\"para\"><code>IntersectionObservers</code> 是异步传递数据，回调函数中的代码将在主线程中运行。 规范中提到<code>IntersectionObserver</code>实现应使用<code>requestIdleCallback（）</code>。 这意味着对回调函数的执行是低优先级的，将在客户端空闲时间进行。 这是有意为之。</p>\n<h3 class=\"heading\" id=\"options\" style=\"position:relative;\"><a href=\"#options\" aria-label=\"options permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>options</h3>\n<p class=\"para\">传递到IntersectionObserver()构造函数的 options 对象包含以下字段：</p>\n<ul>\n<li><strong>root</strong>\n<ul>\n<li>指定根(root)元素，用于检查目标的可见性。必须是目标元素的父级元素。</li>\n<li>如果未指定或者为null，则默认为浏览器视窗。</li>\n</ul>\n</li>\n<li><strong>rootMargin</strong>\n<ul>\n<li>根元素的外边距。类似于css中的 margin 属性，比如 “10px 20px 30px 40px” (top, right, bottom, left)。</li>\n<li>如果有指定root参数，则rootMargin也可以使用百分比来取值。该属性值是用作root元素和target发生交集时候的计算交集的区域范围，使用该属性可以控制root元素每一边的收缩或者扩张。</li>\n<li>默认值为0。</li>\n</ul>\n</li>\n<li><strong>threshold</strong>\n<ul>\n<li>可以是一个数字也可以是一个数字数组。目标元素和根元素相交程度达到该值的时候IntersectionObserver注册的回调函数将会被执行。</li>\n<li>如果你只是想要探测当target元素的在root元素中的可见性超过50%的时候，你可以指定该属性值为0.5。</li>\n<li>如果你想要target元素在root元素的可见程度每多25%就执行一次回调，那么你可以指定一个数组[0, 0.25, 0.5, 0.75, 1]。</li>\n<li>默认值是0(意味着只要有一个target像素出现在root元素中，回调函数将会被执行)。</li>\n<li>该值为1.0含义是当target完全出现在root元素中时候 回调才会被执行。</li>\n</ul>\n</li>\n</ul>\n<p class=\"para\"><strong>注意：</strong></p>\n<ol>\n<li>如果使用默认的<code>options</code>，目标元素部分进入视图窗口和完全离开视图窗口时，都会触发一次回调函数</li>\n<li>如果你想同时观察多个元素，尽可能地在一个<code>IntersectionObserver</code>的实例上调用多次<code>observer</code>方法</li>\n</ol>\n<h3 class=\"heading\" id=\"常用场景\" style=\"position:relative;\"><a href=\"#%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF\" aria-label=\"常用场景 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>常用场景</h3>\n<h4 class=\"heading\" id=\"元素的可见性监听\" style=\"position:relative;\"><a href=\"#%E5%85%83%E7%B4%A0%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9B%91%E5%90%AC\" aria-label=\"元素的可见性监听 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>元素的可见性监听</h4>\n<deckgo-highlight-code language=\"html\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;!-- 网页中嵌入的广告 --&gt;\n&lt;iframe id=&quot;theAd&quot;&gt;&lt;/iframe&gt;\n&lt;!-- 嵌入的脚本 --&gt;\n&lt;script src=&quot;//cdn.example.com/ads.js&quot; async&gt;&lt;/script&gt;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// ads.js\n\n// 上报信息\nfunction logImpressionToServer() { /* ... */ }\n\n// 判断是否可见\nfunction isVisible(boundingClientRect, intersectionRect) {\n  return ((intersectionRect.width * intersectionRect.height) /\n          (boundingClientRect.width * boundingClientRect.height) &gt;= 0.5);\n}\n\nfunction visibleTimerCallback(element, observer) {\n  delete element.visibleTimeout;\n\n  processChanges(observer.takeRecords());\n\n  if (&#39;isVisible&#39; in element) {\n    delete element.isVisible;\n    logImpressionToServer();\n    observer.unobserve(element);\n  }\n}\n\n// 交叉时的回调函数\nfunction processChanges(changes) {\n  changes.forEach(function(changeRecord) {\n    const element = changeRecord.target;\n    element.isVisible = isVisible(changeRecord.boundingClientRect, changeRecord.intersectionRect);\n    if (&#39;isVisible&#39; in element) {\n      // 显示\n      element.visibleTimeout = setTimeout(visibleTimerCallback, 1000, element, observer);\n    } else {\n      // 隐藏\n      if (&#39;visibleTimeout&#39; in element) {\n        clearTimeout(element.visibleTimeout);\n        delete element.visibleTimeout;\n      }\n    }\n  });\n}\n\nconst observer = new IntersectionObserver(\n  processChanges,\n  { threshold: [0.5] } \n);\n\nconst theAd = document.querySelector(&#39;#theAd&#39;);\nobserver.observe(theAd);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">乍看之下好像需要编写更多复杂代码，但是对比传统的方式，这种方式有其优点</p>\n<ol>\n<li>无需监听scroll事件</li>\n<li>没有频繁的同步计算布局，没有插件依赖，只使用了一个定时器来记录状态</li>\n</ol>\n<h4 class=\"heading\" id=\"数据滚动\" style=\"position:relative;\"><a href=\"#%E6%95%B0%E6%8D%AE%E6%BB%9A%E5%8A%A8\" aria-label=\"数据滚动 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>数据滚动</h4>\n<p class=\"para\">许多系统使用数据绑定列表来管理其视图内内容，可以通过回收DOM的方式保持内存和布局效。率。通常我们在渲染分页加载的列表数据的时候，为了避免滚动的时候出现卡顿感，会一次加载好几页的数据，但是实际上需要渲染的数据是总数据的子集。并且随着页码的加大，这个列表中的DOM会越来越多。我们可以在列表元素上使用 <code>IntersectionObserver</code>，来通知系统何时加载数据，何时回收DOM</p>\n<deckgo-highlight-code language=\"html\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;style&gt;\n  .container {\n    overflow: auto;\n    width: 10em;\n    height: 30em;\n    position: relative;\n  }\n\n  .inner-scroll-surface {\n    position: absolute;\n    left: 0px;\n    top: 0px;\n    width: 100%;\n    /* proportional to the # of expected items in the list */\n    height: 1000px;\n  }\n\n  .scroll-item {\n    position: absolute;\n    height: 2em;\n    left: 0px;\n    right: 0px;\n  }\n&lt;/style&gt;\n\n&lt;div class=&quot;container&quot;&gt;\n  &lt;div class=&quot;inner-scroll-surface&quot;&gt;\n    &lt;div class=&quot;scroll-item&quot; style=&quot;top: 0em;&quot;&gt;item 1&lt;/div&gt;\n    &lt;div class=&quot;scroll-item&quot; style=&quot;top: 2em;&quot;&gt;item 2&lt;/div&gt;\n    &lt;div class=&quot;scroll-item&quot; style=&quot;top: 4em;&quot;&gt;item 3&lt;/div&gt;\n    &lt;!-- ... --&gt;\n  &lt;/div&gt;\n&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">As the user moves the container, the children can be observed and as they cross the threshold of the scrollable area, a manager can recycle them and fill them with new data instead of needing to re-create the items from scratch.</p>\n<p class=\"para\">当用户滚动列表时，列表元素经过预先设定的阈值时，可以执行对应的处理逻辑</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function query(selector) {\n  return Array.from(document.querySelectorAll(selector));\n}\n\nfunction init() {\n  const opts = { \n    root: document.querySelector(&quot;.container&quot;),\n    rootMargin: &quot;500px 0px&quot; \n  };\n  const observer = new IntersectionObserver(manageItemPositionChanges, opts);\n\n  query(&quot;.inner-scroll-surface &gt; .scroll-item&quot;)\n    .forEach(function(scrollItem) {\n      observer.observe(scrollItem);\n    });\n}\n\nfunction manageItemPositionChanges(changes) {\n  // ...\n}</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"延迟加载\" style=\"position:relative;\"><a href=\"#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD\" aria-label=\"延迟加载 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>延迟加载</h4>\n<p class=\"para\">使用<code>IntersectionObserver</code>轻松实现懒加载</p>\n<deckgo-highlight-code language=\"html\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;div class=&quot;lazy-loaded&quot;&gt;\n  &lt;template&gt;\n    ...\n  &lt;/template&gt;\n&lt;/div&gt;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function query(selector) {\n  return Array.from(document.querySelectorAll(selector));\n}\n\nvar observer = new IntersectionObserver(\n  // 预先加载在视窗可见区域高度两倍以内的元素\n  function(changes) {\n    changes.forEach(function(change) {\n      var container = change.target;\n      var content = container.querySelector(&quot;template&quot;).content;\n      container.appendChild(content);\n      observer.unobserve(container);\n    });\n  },\n  { rootMargin: &quot;200% 0%&quot; }\n);\n\nquery(&quot;.lazy-loaded&quot;).forEach(function(item) {\n  observer.observe(item);\n});</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"MutationObserver\" style=\"position:relative;\"><a href=\"#MutationObserver\" aria-label=\"MutationObserver permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MutationObserver</h2>\n<p class=\"para\">在web应用中，DOM操作是相当频繁的。在过去有一段时间，公认有效的一种方式是使用<code>Mutation Events</code>，不过这个特性在API的设计中有缺陷，为DOM添加 mutation 监听器反而会进一步降低修改DOM文档的性能（慢1.5 - 7倍）。而且 移除监听器不会减少性能的消耗。目前已经被废弃了。具体原因可以查看<a href=\"https://lists.w3.org/Archives/Public/public-webapps/2011JulSep/0779.html\" class=\"link-underline\">DOM Mutation Events Replacement: The Story So Far / Existing Points of Consensus</a>。简单来说以下三点原因：</p>\n<ol>\n<li>冗余。因为经常触发</li>\n<li>慢。因为事件传播所以慢，同时还阻止了一些UA的自我优化</li>\n<li>容易crash。</li>\n</ol>\n<p class=\"para\">W3C提出了<code>MutationObserver</code>来代替<code>Mutation Events</code>。</p>\n<h3 class=\"heading\" id=\"创建一个-MutationObserver\" style=\"position:relative;\"><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-MutationObserver\" aria-label=\"创建一个 MutationObserver permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>创建一个 MutationObserver</h3>\n<p class=\"para\"><code>MutationObserver</code> 可以监听DOM节点的变化，属性的变化，它最基本的语法如下：</p>\n<deckgo-highlight-code language=\"ts\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const targetNode = document.querySelector(&quot;#someElement&quot;)\nconst observerOptions = {\n  childList: true,  // 观察目标子节点的变化，是否有添加或者删除\n  attributes: true, // 观察属性变动\n  subtree: true     // 观察后代节点，默认为 false\n}\n\nconst observer = new MutationObserver(callback)\n\nfunction callback(records: mutationRecord[], observer: MutationObserver) {\n  // ...\n}\nobserver.observe(targetNode, observerOptions)\n\n// ...\n\nobserver.disconnect() // 停止观察变动。 可以重用观察者。所有已经检测到但是尚未向观察者报告的变动都会被丢弃</code>\n        </deckgo-highlight-code>\n<p class=\"para\">使用选择器来获取目标节点树。 <code>observerOptions</code> 中设定了观察者的选项，通过设定 childList 和 attributes 为 true 来获取所需信息，表示同时观察目标节点树的childList和attributes的变化。</p>\n<h3 class=\"heading\" id=\"callback-1\" style=\"position:relative;\"><a href=\"#callback-1\" aria-label=\"callback 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>callback</h3>\n<p class=\"para\">每当被指定的节点或子树以及配置项有 DOM 变动时，callback会被异步调用。这个函数有两个参数：一个是描述所有被触发改动的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord\" class=\"link-underline\"><code>MutationRecord</code></a> 对象数组，另一个是调用该函数的MutationObserver 对象。比如：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function callback(mutationRecords, observer) {\n  mutationRecords.forEach((mutation) =&gt; {\n    switch(mutation.type) {\n      case &#39;childList&#39;:\n        /* 从树上添加或移除一个或更多的子节点；参见 mutation.addedNodes 与\n           mutation.removedNodes */\n        break;\n      case &#39;attributes&#39;:\n        /* mutation.target 中某节点的一个属性值被更改；该属性名称在 mutation.attributeName 中，\n           该属性之前的值为 mutation.oldValue */\n        break;\n    }\n  });\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">:::info\ncallback 的函数签名和 <code>IntersectionObserver</code> 很相似。其实这些 Observer 的callback 的函数签名都是相似的\n:::</p>\n<p class=\"para\">之后指定目标节点与记录选项，我们开始观察使用 <code>observe()</code> 指定的 DOM 节点。</p>\n<p class=\"para\">从现在开始直到调用 <code>disconnect()</code> ，每次以 targetNode 为根节点的 DOM 树添加或移除元素时，以及这些元素的任意属性改变时，<code>callback()</code> 都会被调用。</p>\n<h3 class=\"heading\" id=\"options-1\" style=\"position:relative;\"><a href=\"#options-1\" aria-label=\"options 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>options</h3>\n<p class=\"para\"><code>observer(target, options)</code> 中的 <code>options</code> 是一个<code>MutationObserverInit</code>对象，描述了 MutationObserver 的配置。当调用 <code>observe()</code> 方法时，<code>childList</code>，<code>attributes</code> 或者 <code>characterData</code> 三个属性之中，至少有一个必须为 <code>true</code>，否则会抛出 <code>TypeError</code> 异常。</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>描述</th>\n<th>是否可选</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>childList</td>\n<td>设为 <code>true</code> 时，监视目标节点（如果 subtree 为 true，则包含子孙节点）添加或删除新的子节点。</td>\n<td>可选</td>\n<td>false</td>\n</tr>\n<tr>\n<td>attributes</td>\n<td>设为 <code>true</code> 时，观察受监视元素的属性值变更</td>\n<td>可选</td>\n<td>false</td>\n</tr>\n<tr>\n<td>characterData</td>\n<td>设为 <code>true</code> 时，监视指定目标节点或子节点树中节点所包含的字符数据的变化</td>\n<td>可选</td>\n<td>-</td>\n</tr>\n<tr>\n<td>attributeFilter</td>\n<td>要监视的特定属性名称的数组。如果未包含此属性，则对所有属性的更改都会触发变动通知</td>\n<td>可选</td>\n<td>-</td>\n</tr>\n<tr>\n<td>attributeOldValue</td>\n<td>当监视节点的属性改动时，将此属性设为 true 将记录任何有改动的属性的上一个值</td>\n<td>可选</td>\n<td>-</td>\n</tr>\n<tr>\n<td>characterDataOldValue</td>\n<td>设为 <code>true</code>时， 受监视节点的文本(text)发生更改时记录节点文本的先前值</td>\n<td>可选</td>\n<td>-</td>\n</tr>\n<tr>\n<td>subtree</td>\n<td>设为 <code>true</code> 时将监视范围扩展至目标节点整个节点树中的所有节点。MutationObserverInit 的其他值也会作用于此子树下的所有节点，而不仅仅只作用于目标节点。</td>\n<td>可选</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<h3 class=\"heading\" id=\"takeRecords\" style=\"position:relative;\"><a href=\"#takeRecords\" aria-label=\"takeRecords permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>takeRecords()</h3>\n<p class=\"para\">返回<strong>已检测到但尚未由观察者的回调函数处理的所有匹配DOM更改的列表，使变更队列保持为空</strong>。 最常见的使用场景是：在断开观察者之前立即获取所有未处理的更改记录，以便在停止观察者时可以处理任何未处理的更改。比如：</p>\n<deckgo-highlight-code language=\"diff\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var targetNode = document.querySelector(&quot;#someElement&quot;);\nvar observerOptions = {\n  childList: true,\n  attributes: true\n}\n\nvar observer = new MutationObserver(callback);\nobserver.observe(targetNode, observerOptions);\n\n// 这里做了一些事情\n// ...\n+// 开始处理尚未结束的变更\n+var mutations = observer.takeRecords();\n\n+if (mutations) {\n+  callback(mutations);\n+}\n\nobserver.disconnect();</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"Resize-Observer\" style=\"position:relative;\"><a href=\"#Resize-Observer\" aria-label=\"Resize Observer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Resize Observer</h2>\n<p class=\"para\">这个API和其他的Observer类似，他可以用来观察元素大小的变化。onresize事件则只能有window来触发。大部分使用场景可能是在视窗大小发生变化，或者在移动设备上屏幕旋转时，监听页面元素尺寸的变化。在resizeObserver出现之前，只能使用 <code>window.resize</code> 事件来见视窗的大小变化。这种方式稍不留神就容易因为频繁触发resize事件而出现性能问题，从另一个层面来说，<code>resize</code>有点“浪费资源”，因为我们只能通过视窗的变化来计算目标元素的变化。</p>\n<p class=\"para\">现如今重Web端的SPA页面中，经常需要动态地添加或者删除DOM，频繁修改父元素的尺寸，这种case只有Resize Observer API能够帮我们。</p>\n<p class=\"para\">除了监听元素大小变化之外，还有几个有意思的特性：</p>\n<ol>\n<li>目标元素被插入或者从DOM中移除时会触发观察</li>\n<li>目标元素display修改为<code>none</code>时会触发观察</li>\n<li>非替换元素(<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element\" class=\"link-underline\">link</a>)不会触发观察</li>\n<li>tranforms不会触发观察</li>\n<li>如果元素被渲染了时尺寸不是0，0，也会触发观察</li>\n</ol>\n<h3 class=\"heading\" id=\"创建一个-ResizeObserver\" style=\"position:relative;\"><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-ResizeObserver\" aria-label=\"创建一个 ResizeObserver permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>创建一个 ResizeObserver</h3>\n<p class=\"para\">与<code>intersectionObserver</code>和<code>MutationObserver</code>不同，ResizeObserver的构造函数只需要一个<code>callback</code>参数。但是监听和取消监听的方法类似</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function callbacl(entries) {\n  // ...\n}\n\nconst myObserver = new ResizeObserver(callback);\nconst someEl = document.querySelector(&#39;.some-element&#39;)\nconst someOtherEl = document.querySelector(&#39;.some-other-element&#39;)\n\nmyObserver.observe(someEl)\nmyObserver.observe(someOtherEl)</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"callback-2\" style=\"position:relative;\"><a href=\"#callback-2\" aria-label=\"callback 2 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>callback</h3>\n<p class=\"para\">当观察的目标元素尺寸发生变化时触发回调函数，参数是一个<code>ResizeObserverEntry</code>对象数组。ResizeObserverEntry的接口如下</p>\n<deckgo-highlight-code language=\"ts\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">interface ResizeObserverEntry {\n    readonly attribute Element target;\n    readonly attribute DOMRectReadOnly contentRect;\n    readonly attribute sequence&lt;ResizeObserverSize&gt; borderBoxSize;\n    readonly attribute sequence&lt;ResizeObserverSize&gt; contentBoxSize;\n    readonly attribute sequence&lt;ResizeObserverSize&gt; devicePixelContentBoxSize;\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><code>contentRect</code> 是 ResizeObserver API 孵化阶段时的产物，考虑到兼容性问题暂时保留，在未来可能会被废弃。</p>\n<p class=\"para\">当观察的目标元素尺寸发生变化时触发回调函数，参数是一个<code>ResizeObserverEntry</code>对象数组。<code>ResizeObserverEntry</code>对象包含两个属性：<code>contentRect</code>，<code>target</code>。<strong>target</strong>是被观察的目标对象。<strong>contentRect</strong>是<code>DOMRectReadOnly</code>的引用，包含 <code>width</code>, <code>height</code>, <code>x</code>, <code>y</code>, <code>top</code>, <code>right</code>, <code>bottom</code> 和 <code>left</code>。和<code>Element.getBoundingClientRect()</code>返回的数据不同，<code>contentRect</code>的<code>width</code>和<code>height</code>不包含<code>padding</code>，<code>contentRect.top</code>是元素的<code>padding-top</code>，<code>contentRect.left</code>是元素的<code>padding-left</code>。</p>\n<p class=\"para\">比如在元素调整大小时，其内部文本显示为尺寸大小，代码如下：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const resizeObserver = new ResizeObserver(entries =&gt; {\n  for (let entry of entries) {\n    const boxEl = entry.target\n    const dimensions = entry.contentRect\n\n    boxEl.textContent = `${dimensions.width} x ${dimensions.height}`\n  }\n})\n\nresizeObserver.observe(document.querySelector(&#39;.box:nth-child(2)&#39;))</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"observetarget-options\" style=\"position:relative;\"><a href=\"#observetarget-options\" aria-label=\"observetarget options permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>observe(target, options)</h3>\n<p class=\"para\">ResizeObserver实例的observe方法还有第二个参数<code>options</code>。不过暂时处于草案阶段，浏览器还不支持第二个参数。</p>\n<deckgo-highlight-code language=\"ts\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">enum ResizeObserverBoxOptions {\n  &quot;border-box&quot;, \n  &quot;content-box&quot;, \n  &quot;device-pixel-content-box&quot;\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\">可以控制Observer观察不同的CSS尺寸：</p>\n<ul>\n<li><strong>border-box</strong> : box-border。返回的尺寸包含padding和border</li>\n<li><strong>content-box</strong> : content-boder。返回的尺寸不包含padding和border。默认值</li>\n<li><strong>device-pixel-content-box</strong> : 返回的尺寸是未经缩放的，和设备像素相关的大小，一定是一个整数。</li>\n</ul>\n<h3 class=\"heading\" id=\"常用场景-1\" style=\"position:relative;\"><a href=\"#%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF-1\" aria-label=\"常用场景 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>常用场景</h3>\n<h4 class=\"heading\" id=\"iframe的大小变化\" style=\"position:relative;\"><a href=\"#iframe%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96\" aria-label=\"iframe的大小变化 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>iframe的大小变化</h4>\n<p class=\"para\">iframe 可以检测到大小的变化然后通知给父窗口</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let ro = new ResizeObserver(entries =&gt; {\n  let idealSize = computeIdealSize();\n\n  window.parent.postMessage({\n    name: &quot;iframeResize&quot;,\n    width: idealSize.width,\n    height: idealSize.height\n  }, &#39;*&#39;);\n});\n\nro.observe(document.body);\n\n// window上监听message事件\nwindow.addEventListener(&quot;message&quot;, ev =&gt; {\n  if (ev.data &amp;&amp; ev.data.name == &quot;iframeResize&quot;) {\n    let iframe = findEventSourceIframe(ev.source);\n    if (iframe) {\n      iframe.style.width = ev.data.width + &quot;px&quot;;\n      iframe.style.height = ev.data.height + &quot;px&quot;;\n    }\n  }\n}, false);</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"聊天窗口自动滚动到底部\" style=\"position:relative;\"><a href=\"#%E8%81%8A%E5%A4%A9%E7%AA%97%E5%8F%A3%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8%E5%88%B0%E5%BA%95%E9%83%A8\" aria-label=\"聊天窗口自动滚动到底部 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>聊天窗口自动滚动到底部</h4>\n<p class=\"para\">在聊天窗口中，最新的消息在底部。为了防止浏览器自动滚动到顶部，当收到新消息时需要将滚动的位置保持在最底部。当窗口自动变化的时候也要保证能够</p>\n<deckgo-highlight-code language=\"css\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">.chat {\n  overflow: scroll;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"html\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">&lt;div class=&quot;chat&quot;&gt;  &lt;!-- chat has the scrollbar --&gt;\n  &lt;div class=&quot;chat-text&quot;&gt; &lt;!-- chat-text contains chat text --&gt;\n    &lt;div&gt;jack: hi &lt;/div&gt;\n    &lt;div&gt;jill: hi &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let ro = new ResizeObserver( entries =&gt; {\n  for (let e of entries) {\n    let chat = e.target.parentNode;\n    chat.scrollTop = chat.scrollHeight - chat.clientHeight;\n  }\n});\nro.observe(document.querySelector(&#39;.chat-text&#39;))</code>\n        </deckgo-highlight-code>\n<p class=\"para\">ResizeObserver 观察 <code>chat-text</code> 的大小，每次检测到变化时，将 <code>chat</code> 滚动到底部。新消息插入时也会触发到resize的检测。</p>\n<p class=\"para\">当用户向上滚动滚动条阅读历史消息时，新消息插入时自动滚动到底部，这会让用户丢掉之前阅读的信息。所以在这里引出一个新问题，如何保留用户的滚动位置？</p>\n<p class=\"para\">我们可以监听scroll事件来判断是否滚动，但是没有API可以区分是scroll事件是用户行为触发还是程序触发，这里hack的方式是使用flag来区分。代码如下：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">let ro = new ResizeObserver()\n\nfunction initScrollPositionChat(chat) {\n  let chatText = chat.firstElementChild\n\n  chatText.resizeHandler = entry =&gt; {\n    let chat = entry.target.parentNode;\n\n    // 判断flag\n    if (!chat.saveUserScroll) {\n      chat.isResizeScrollEvent = true;\n      chat.scrollTop = chat.scrollHeight - chat.clientHeight;\n    }\n  }\n\n  ro.observe(chatText)\n\n  chat.addEventListener(&#39;scroll&#39;, ev =&gt; {\n    // Ignore scrolls generated by ResizeObserver\n    if (chat.isResizeScrollEvent) {\n      delete chat.isResizeScrollEvent;\n      return;\n    }\n\n    // 保存用户的位置，除非已经滚动到底部了\n    if (chat.scrollTop != chat.scrollHeight - chat.clientHeight) {\n      chat.saveUserScroll = true;\n    } else {\n      chat.saveUserScroll = false;\n    }\n  });\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">Resize Observer API目前还有很多特性处于草稿阶段，有兴趣的朋友可以前往<a href=\"https://www.w3.org/TR/resize-observer/#intro\" class=\"link-underline\">w3.org</a>查阅</p>\n<h2 class=\"heading subtitle heading\" id=\"三个Observer的对比\" style=\"position:relative;\"><a href=\"#%E4%B8%89%E4%B8%AAObserver%E7%9A%84%E5%AF%B9%E6%AF%94\" aria-label=\"三个Observer的对比 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>三个Observer的对比</h2>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3fde7b6b445b8eb5a773e0f1e520c79b/8ad1b/observers.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 204.2553191489362%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAApCAYAAAA1bQl+AAAACXBIWXMAAAsTAAALEwEAmpwYAAAE0ElEQVRIx41XaXfiOgzt//9178xWYIDsceJ9i0MLM/cdi6W0UKYfdByIuZaurmTxNE2veGjxBTG+0HM8PV9bSq+Xd3l9+ifg9P4HKe0vpriBGA1CBj/tefoK0BnM2QlSOkjpEbSHHhXqikFyc9n79NGDe2Hl0yc/E4jPZgImYeAGibHjCHb6AHgFdn5OVzalPSaXMIUZaT7QATlMySRYx+Hyu2vAeO1hDs3NsBdLcH6HmD00ESHMMMqDdQLeJeLyNinnsMKMKC04k+C9wNgJjL2AYBJxEHDKIWoPxzVYMxBg/n0Iu3uAOawJk/bHLF6HnT9rBzMocG4wdBx12WPsJWLYYbf7Q/J5xyF5mAFtJPCbpLgEyzUkt2hqhufnDaqiQ1X2WK4bcOHo4FtAExAzL6cEXWfZKk9cikGjrges1zWaeiDZWBPvcPgB8MjL2Y6gOQIrLPHaFB34oLDbHW5l8xHwTZdHC34C5wLa+Pe6/SD+fwJ662CUgDcCZdlACEO6PL+/1m/8Z8gUpsUUsw4DjFJQUiHG3U1ZfslD2hQCUjpgSgfMu7+wSkJwcQN4tgeA+fsJ0TlY48mCNXBqQFl1UOook4+g72qZ6tWcdJiFHicEw6GlhlYGXo8IugcfR3ibk7O/9fBNvLlSIoJkGNgA1g+wokUKBvMOmOc/FLKRAkVRUxu7152ejk3zlXhKMVISjpWSa9vDKYa+52BsxDAICM7JQ2f9RfRnaZGH87wHYwOapoUPFiGcQiEqEoLVsMZRIqqyQlM3aJuWDuG5FKWBVg5aO2oSFw/ntIePCSZn9QI4YwrxmF1tUFUtNpsSv9cFFsvfWK02WK7WKMsaWuljyJcsxVe4ML0BnvXl3en+GLH6XWG1rlBWPbZFh9W6xrbssNm26HrxluVItbq/C+ithVMjjBiwXBV4XqyxLWoILtG1md8RXTdAcHUFGO8DHgnfIQUHLRgWyy2Wqw2+/1jg2/cFlWIGzFQIoamJPAQ8dpyjArTkxNtyucZmUxBvfcfQNh3quqWkvd0pn3l4ucz3VClV3aPtBlRVByk0nAvQ2sJoB2fDFzy8Eq7UHh0TEMqRcWlpzfxfX1R3AacLhy8Q2kIYg1EptIzDhxlzOtwMAu+6zT1AynBM8CGRpJTxYFxhzEK2EfcGhAeAx80uJjApCWjgCtoFcGVQNgxKB/iwewf2AfAobBviaRg6ELgJHvN8oGpyfoJQBsZFcGlg3XTTF2881N7R5OD9DOUtBiUxCgNhHJRWqJse3SjBRk1ePgDM88oMYQ26QaAfBVrdw/hInmQutfeou5GynQ/Makgnvj+dvmhT2lMmc/ijVhDKYhAaDRtRtB1Z2WVPBb3LXSac+Hz6bJTLmaXu4wNJpR04VkWNn6stlpsK67JF2TIyriyUCZ9PsJfGEBLRkBPS9CO2VY+iZrT+92OFb7/W+PG8wWJdQWn/BcDsoYtwccK26fBzUeD78xpVO6JsBqy2Da2bsqPKeZtt7gHG10uljFaiZgN58nO5xaZsUbUDGsapeup+pIMfDu2XxjAdEKYZVcfwa1ng16qgUJ9XJTom0TKBtueX6nkY8tuN+IKqGyjc7OFyXaEfFVn2NIM+TMq9fwDZg9xdpPK0upDIskadT6SEDPg/96M+qYoH5U8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Observer.png\"\n        title=\"Observer.png\"\n        src=\"/static/3fde7b6b445b8eb5a773e0f1e520c79b/1d69c/observers.png\"\n        srcset=\"/static/3fde7b6b445b8eb5a773e0f1e520c79b/4dcb9/observers.png 188w,\n/static/3fde7b6b445b8eb5a773e0f1e520c79b/5ff7e/observers.png 375w,\n/static/3fde7b6b445b8eb5a773e0f1e520c79b/1d69c/observers.png 750w,\n/static/3fde7b6b445b8eb5a773e0f1e520c79b/78797/observers.png 1125w,\n/static/3fde7b6b445b8eb5a773e0f1e520c79b/aa440/observers.png 1500w,\n/static/3fde7b6b445b8eb5a773e0f1e520c79b/8ad1b/observers.png 2320w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2 class=\"heading subtitle heading\" id=\"参考\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考</h2>\n<ol>\n<li><a href=\"https://developers.google.com/web/updates/2016/04/intersectionobserver\" class=\"link-underline\">IntersectionObserver’s Coming into View</a></li>\n<li><a href=\"https://github.com/w3c/IntersectionObserver/blob/master/explainer.md\" class=\"link-underline\">IntersectionObserver explainer</a></li>\n<li><a href=\"https://web.dev/resize-observer/\" class=\"link-underline\">ResizeObserver: it’s like document.onresize for elements</a></li>\n</ol>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#intersectionobserver\">IntersectionObserver</a></p>\n<ul>\n<li>\n<p><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-intersectionobserver\">创建一个 IntersectionObserver</a></p>\n</li>\n<li>\n<p><a href=\"#callback\">callback</a></p>\n</li>\n<li>\n<p><a href=\"#options\">options</a></p>\n</li>\n<li>\n<p><a href=\"#%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF\">常用场景</a></p>\n<ul>\n<li><a href=\"#%E5%85%83%E7%B4%A0%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9B%91%E5%90%AC\">元素的可见性监听</a></li>\n<li><a href=\"#%E6%95%B0%E6%8D%AE%E6%BB%9A%E5%8A%A8\">数据滚动</a></li>\n<li><a href=\"#%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD\">延迟加载</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#mutationobserver\">MutationObserver</a></p>\n<ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-mutationobserver\">创建一个 MutationObserver</a></li>\n<li><a href=\"#callback-1\">callback</a></li>\n<li><a href=\"#options-1\">options</a></li>\n<li><a href=\"#takerecords\">takeRecords()</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#resize-observer\">Resize Observer</a></p>\n<ul>\n<li>\n<p><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-resizeobserver\">创建一个 ResizeObserver</a></p>\n</li>\n<li>\n<p><a href=\"#callback-2\">callback</a></p>\n</li>\n<li>\n<p><a href=\"#observetarget-options\">observe(target, options)</a></p>\n</li>\n<li>\n<p><a href=\"#%E5%B8%B8%E7%94%A8%E5%9C%BA%E6%99%AF-1\">常用场景</a></p>\n<ul>\n<li><a href=\"#iframe%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%98%E5%8C%96\">iframe的大小变化</a></li>\n<li><a href=\"#%E8%81%8A%E5%A4%A9%E7%AA%97%E5%8F%A3%E8%87%AA%E5%8A%A8%E6%BB%9A%E5%8A%A8%E5%88%B0%E5%BA%95%E9%83%A8\">聊天窗口自动滚动到底部</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E4%B8%89%E4%B8%AAobserver%E7%9A%84%E5%AF%B9%E6%AF%94\">三个Observer的对比</a></p>\n</li>\n<li>\n<p><a href=\"#%E5%8F%82%E8%80%83\">参考</a></p>\n</li>\n</ul>","headings":[{"id":"IntersectionObserver","depth":2,"value":"IntersectionObserver"},{"id":"创建一个-IntersectionObserver","depth":3,"value":"创建一个 IntersectionObserver"},{"id":"callback","depth":3,"value":"callback"},{"id":"options","depth":3,"value":"options"},{"id":"常用场景","depth":3,"value":"常用场景"},{"id":"元素的可见性监听","depth":4,"value":"元素的可见性监听"},{"id":"数据滚动","depth":4,"value":"数据滚动"},{"id":"延迟加载","depth":4,"value":"延迟加载"},{"id":"MutationObserver","depth":2,"value":"MutationObserver"},{"id":"创建一个-MutationObserver","depth":3,"value":"创建一个 MutationObserver"},{"id":"callback-1","depth":3,"value":"callback"},{"id":"options-1","depth":3,"value":"options"},{"id":"takeRecords","depth":3,"value":"takeRecords()"},{"id":"Resize-Observer","depth":2,"value":"Resize Observer"},{"id":"创建一个-ResizeObserver","depth":3,"value":"创建一个 ResizeObserver"},{"id":"callback-2","depth":3,"value":"callback"},{"id":"observetarget-options","depth":3,"value":"observe(target, options)"},{"id":"常用场景-1","depth":3,"value":"常用场景"},{"id":"iframe的大小变化","depth":4,"value":"iframe的大小变化"},{"id":"聊天窗口自动滚动到底部","depth":4,"value":"聊天窗口自动滚动到底部"},{"id":"三个Observer的对比","depth":2,"value":"三个Observer的对比"},{"id":"参考","depth":2,"value":"参考"}],"frontmatter":{"title":"IntersectionObserver、MutationObserver和ResizeObserver","date":"2019-07-13","cover":null,"description":null,"categories":[],"tags":[]}},"previous":{"fields":{"slug":"/blogs/再谈EventLoop/"},"frontmatter":{"title":"再谈EventLoop"}},"next":{"fields":{"slug":"/blogs/从getBoundingClientRect到Intersection Observer/"},"frontmatter":{"title":"从getBoundingClientRect到Intersection Observer","tags":[],"categories":[],"status":null}}},"pageContext":{"id":"b1766f50-a2ca-52ce-b40d-d080274ea52f","previousPostId":"8b41650b-72bc-55f9-a2f0-aa17ee0251c0","nextPostId":"b38353a8-4aab-53d4-a7ba-848e22f02c73"}},
    "staticQueryHashes": ["2841359383"]}