{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2020-11-05-使用Single-SPA实现微前端/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"19735d71-38bc-5691-b204-f44e59b152d0","html":"<h2 class=\"heading subtitle heading\" id=\"背景\" style=\"position:relative;\"><a href=\"#%E8%83%8C%E6%99%AF\" aria-label=\"背景 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>背景</h2>\n<p class=\"para\">随着组织架构调整，目前来车服租车团队已经有一段时间了。虽然主要业务工作还是B端系统的开发，但是租车业务因其业务特点以及一些历史原因，我面对的是两个“巨无霸”型后台系统-Car系统和Car-mis系统。这两个系统历史悠久，经手多个团队，所有租车相关的业务模块诸如交易，商品，履约，车险，商户，车辆库存和权限等，都集成在这两个系统中。</p>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d395d96fc572b3d38849be77acb900dd/cda19/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 73.93617021276594%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAACN0lEQVQoz11Ti27bMAzM/3/XtrZLtmVtmnRdmkZ2EjsW9Zb1ljXYadNtBCEceHcgQUKzMsUwDKWUpmlSSuU9mqYJIVzZtm2dc+WvmF1RSgmhylp7VXddF2O8srvdTkp5Zf8xl1IoIeldXUoRguecy/tshID3/v/OMQ3G594lwpW20bjUu2RcAiZV743PxicbMhW9cdGG7GP+MGsbsYygEqhEVAKZ8JSo5Z0IE45YRCxH6iwi03EaZTLnXEIqMY2vj0OYQEgFqLA+TcXiwuAvgkk5WodhNr7JeQNWY6dxctT12BvwBrQ4WnV2PYx1T5zurB5lOerLGsbOyTMtzoxRzqlida8IAVCS96I2PQMCnAGHFylI13WcdZai0rSDVjPGueuppDU+I9wiI2pJK4Jr3L4aUXNSMTiQbm9ExaCicKAYBdmUqiqCz4RUtgctOgyAARSvjSIYAAALeJUcTqdGCCYp0kpgDIx1nh/LelMwnhYWpBVVL2rFkNcHzZGilea1k6gXI1AUWbnXbG/VyUoULb5cfpZzHoZchlAGX0ooQ5xwKCUoSVM0YzH7N0Geckgfd/bJE02xop0AogmWY4IiJ9JgSYimVFGiGdGMGyGdtMG8mQEDlbA9Huf36+XzdtceF5vN7cPDcvv7V10vHjerl/1TjeaPj/P1eteemKHSinHqMsx6bYjqlvvvN+u7r8+L1WE1f/52u7lbvt4/oNXdZr7Y/ljul5/XN59WX36i5VP7sxGHy/f4A3qFVA42C0K9AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"业务架构图\"\n        title=\"业务架构图\"\n        src=\"/static/d395d96fc572b3d38849be77acb900dd/1d69c/1.png\"\n        srcset=\"/static/d395d96fc572b3d38849be77acb900dd/4dcb9/1.png 188w,\n/static/d395d96fc572b3d38849be77acb900dd/5ff7e/1.png 375w,\n/static/d395d96fc572b3d38849be77acb900dd/1d69c/1.png 750w,\n/static/d395d96fc572b3d38849be77acb900dd/cda19/1.png 785w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p class=\"para\">随着业务迭代，两个系统日渐臃肿，高达90+的模块数使得无论是本地开发还是上线，很多时间都浪费在编译打包阶段；随着应用框架和技术方案等升级和迁移，多框架多版本共存的问题无法避免；两个系统的基本业务逻辑一致，UI上存在一些差异，各自独立开发和维护，无法充分复用相同业务逻辑的代码。微前端可能是目前解决这类问题的最佳方案。</p>\n<p class=\"para\">微前端将微服务的理念应用于浏览器端，将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署。由此也能看出，微前端不是单纯的框架或者工具，是一套完整的体系。对于其价值，目前业界比较认可的观点有以下几个：</p>\n<ol>\n<li>无技术栈限制</li>\n<li>应用单独开发，解耦</li>\n<li>多应用整合，复用</li>\n</ol>\n<p class=\"para\">而这三个特点，似乎能够解决当前租车B端系统的问题。结合现有工程的项目，我们对我们的需求进行分析，并确定了预期的收益</p>\n<ol>\n<li>拆分应用：按照业务拆分成不同的仓库进行维护，独立开发，独立维护</li>\n<li>加速体验：开发模块提速；上线部署提速</li>\n<li>侵入性低：改动尽可能小，允许渐进迁移</li>\n<li>学习成本低：保持现有开发模式，没有学习成本</li>\n<li>统一技术栈：约定统一使用React技术栈，渐进迁移到16.8以后的版本</li>\n</ol>\n<p class=\"para\">针对微前端方案，社区已经有了总结和对比，我们决定采用“基座模式”来实现我们租车业务线的微前端方案。基座模式是由一个主应用和一系列业务子应用构成的系统，并由这个主应用来管理其他子应用，包括从子应用的生命周期管理到应用间的通信机制。作为系统的统一入口，负责将对应的请求指向对应的服务。子应用，则是负责各个子模块的业务实现。更多微前端相关的介绍可以去看看这些文章：</p>\n<ol>\n<li><a href=\"https://micro-frontends.org/\" class=\"link-underline\">What are Micro Frontends</a></li>\n<li><a href=\"https://microfrontends.cn/\" class=\"link-underline\">Thinking in Microfrontend (微前端的那些事儿)</a></li>\n</ol>\n<p class=\"para\">按照预期，使用微前端方案之后，B端系统的架构也会发生响应的变化</p>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 681px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ed01d29655defbb0cde89cafaff7d78d/8ce52/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69.14893617021278%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAIAAACgpqunAAAACXBIWXMAAAsTAAALEwEAmpwYAAACR0lEQVQoz0WS567rIBCE8/7PdnVKEttJ3G0wzR1jmoErn/zICqEV6NNodvYSQvDehxA4X1vQEsoYrtxeewmcbIKCQUOvu7NRrVdtUCCoNhisp99L+KNDCIKPBJUIZASmfGqdRN7QfQXbDPcVbVOzze3OO7GAZWzEiji7X97Kx+G9XTWvqyKOo98k+lG8O3bICHg+HxA2dflq26Yqc9DkANSvNMfgccLzPOdFYdVkRVsXSRx952mkOLQCgDaPonscXbNXVJZ5lqWky/el4ROYye2t7LwP3nIr2rZ+xvevIjthJztGqrp6dSCnuGSk7SmQHAWDgp/N9vrzHE7P3i6al0UWR7ev7BUrDsJBvMbBkmCZNzQYEgz2GoXzcVTz/Q3/lVPhWK2atoXofbBq1IIZOSjRG9nr/X0GI88vb/mh2Ac2xkzjgDHe+LLvfBx6COG8LHLnnHOM8ThOcudCCELpvKzWyMsn53VB3TnRZWi3pcOoq6uSEbCvcBxHCBpK4DoUyzxCCAmlpPn+wHqfKMp7Us2sMAJTnA8MzH1pJetJQbqiR5lcW7FAMcNDMTk9L2VZJkkSRQlFOaiT2+0X1InXhKH0dv2uy8RKtk31I7k+H/d1rIOh58K5yYriopTSWilllOhB9YjvVwxTJwnt0p/vf1Uem53KFVZF0laPfQVO00N2h6J2Kz5RHXomMC2LlHSZU2SkRZm/EMiNIE4hJ9F5K+Z0fyrb0fL0AzuzOgmMwE6hQw9OdWcvsVPM/6k5hZ0+4TPnYzLL4z+OZQ0UHAGfTAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"架构变化\"\n        title=\"架构变化\"\n        src=\"/static/ed01d29655defbb0cde89cafaff7d78d/8ce52/2.png\"\n        srcset=\"/static/ed01d29655defbb0cde89cafaff7d78d/4dcb9/2.png 188w,\n/static/ed01d29655defbb0cde89cafaff7d78d/5ff7e/2.png 375w,\n/static/ed01d29655defbb0cde89cafaff7d78d/8ce52/2.png 681w\"\n        sizes=\"(max-width: 681px) 100vw, 681px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p class=\"para\">基座模式的代表<a href=\"https://github.com/single-spa/single-spa\" class=\"link-underline\">single-spa</a>, <a href=\"https://qiankun.umijs.org/zh/guide\" class=\"link-underline\">qiankun</a>亦是站在前者的肩膀之上诞生的国产的微前端实现库。处于“科研”的考虑，先从single-spa开始入手，了解其原理，学习其思想</p>\n<h2 class=\"heading subtitle heading\" id=\"single-spa-的使用\" style=\"position:relative;\"><a href=\"#single-spa-%E7%9A%84%E4%BD%BF%E7%94%A8\" aria-label=\"single spa 的使用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>single-spa 的使用</h2>\n<p class=\"para\">single-spa的灵感来自现代组建框架的生命周期，抽象了整个应用程序的生命周期。现在是一个能够启用前端微服务架构的稳定库，这个架构就是我们说的微前端，microfrontend。一个single-spa的应用包含以下部分：</p>\n<ol>\n<li>一个 root config。渲染HTML页面和执行应用注册的JavaScript。每个应用注册时需要：</li>\n</ol>\n<ul>\n<li>应用名</li>\n<li>一个加载应用代码的函数</li>\n<li>一个确定应用何时处于活跃\\非活跃状态的函数</li>\n</ul>\n<ol start=\"2\">\n<li>其他应用。 每个应用需要知道如何将自己从DOM中引导，挂载和卸载。和传统的单页应用的主要区别在于，这些程序能够共存吗，因为他们不包含彼此的HTML页面。就像你的React或者Vue应用一样。当活跃时，监听url的路由事件，将内容放进DOM。当不活跃时，不再监听变化，同时将内容从DOM中移除。</li>\n</ol>\n<p class=\"para\">官方发布的脚手架<a href=\"https://single-spa.js.org/docs/create-single-spa/\" class=\"link-underline\">create-single-spa</a>能够帮助我们快速上手</p>\n<h3 class=\"heading\" id=\"创建一个root-config\" style=\"position:relative;\"><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAroot-config\" aria-label=\"创建一个root config permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>创建一个root config</h3>\n<p class=\"para\">使用脚手架可以快速创建root config</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">npx create-single-spa --moduleType root-config</code>\n        </deckgo-highlight-code>\n<p class=\"para\">创建之后，进入目录<code>start</code>启动，访问页面可以看到：</p>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4a3a5a09c122f270b965a90d7d6743b4/196aa/Xnip2021-05-04_13-51-59.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 167.5531914893617%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAiABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAECAwQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAfX0pB0MhWa60XRhAag//8QAHBAAAQQDAQAAAAAAAAAAAAAAAQACEBEhMTJC/9oACAEBAAEFAjkgQcmlSPUerh203X//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AV//xAAWEQADAAAAAAAAAAAAAAAAAAAQESD/2gAIAQIBAT8BCj//xAAaEAACAgMAAAAAAAAAAAAAAAAAIRExIDBR/9oACAEBAAY/AmoL0cLx/8QAHxAAAwABAwUAAAAAAAAAAAAAAAERITFRYSBBgaGx/9oACAEBAAE/IXl3G46YC5IYxU8P2XsQ2ySbCk0NG+hcr8dKf//aAAwDAQACAAMAAAAQyMMMiA//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/EF//xAAYEQEAAwEAAAAAAAAAAAAAAAABECAhMf/aAAgBAgEBPxDWh4R//8QAIRABAAICAQQDAQAAAAAAAAAAAQARITFBUWFx4YGxwfD/2gAIAQEAAT8QQSbCUgeKa3BZ9Pl+5ashexKixw21+yoLHoe0A4/3zDa0Fw2QooadL9y7IL2qK0EpraAmxynpAoy33m2dJu8z/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Xnip2021-05-04_13-51-59.jpg\"\n        title=\"Xnip2021-05-04_13-51-59.jpg\"\n        src=\"/static/4a3a5a09c122f270b965a90d7d6743b4/acb04/Xnip2021-05-04_13-51-59.jpg\"\n        srcset=\"/static/4a3a5a09c122f270b965a90d7d6743b4/bc01b/Xnip2021-05-04_13-51-59.jpg 188w,\n/static/4a3a5a09c122f270b965a90d7d6743b4/bf173/Xnip2021-05-04_13-51-59.jpg 375w,\n/static/4a3a5a09c122f270b965a90d7d6743b4/acb04/Xnip2021-05-04_13-51-59.jpg 750w,\n/static/4a3a5a09c122f270b965a90d7d6743b4/ec605/Xnip2021-05-04_13-51-59.jpg 1125w,\n/static/4a3a5a09c122f270b965a90d7d6743b4/196aa/Xnip2021-05-04_13-51-59.jpg 1130w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h3 class=\"heading\" id=\"创建子应用\" style=\"position:relative;\"><a href=\"#%E5%88%9B%E5%BB%BA%E5%AD%90%E5%BA%94%E7%94%A8\" aria-label=\"创建子应用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>创建子应用</h3>\n<p class=\"para\">接下来创建一个子应用，同样使用脚手架提供的命令</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">npx create-single-spa --moduleType app-parcel</code>\n        </deckgo-highlight-code>\n<p class=\"para\">同样启动之后访问对应的页面，但是此时你会发现，无法通过url正常访问子应用。子应用默认是集成模式，<code>standalone-single-spa-webpack-plugin</code>是关闭的，在不修改配置之前，是无法以独立应用的方式来访问的。那如何开始开发调试呢？如果你不需要启动基座应用，可以通过官方提供的<a href=\"http://single-spa-playground.org/playground\" class=\"link-underline\">playground</a>访问。访问的格式是 <code>http://single-spa-playground.org/playground/instant-test?name=@[orgName]/[&#x26;url=[port]</code>。</p>\n<p class=\"para\">另外一种方式是本地启动主应用，然后再将子应用注入。访问主应用页面的 console, 设置 localStorage，<code>localStorage.setItem('devtools', true)</code>。刷新之后右下角会出现一个小部件，展开之后找到子应用的模块名，填入子应用的地址，然后再刷新一次，如果没有找到对应的模块名，可以手动添加。</p>\n<p class=\"para\">接下来将子应用注入到主应用，编辑<code>src/index.ejs</code>，在import Map中添加子应用的地址和其他需要共享的依赖。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">{\n  &quot;imports&quot;: {\n    &quot;@zhang/root-config&quot;: &quot;//localhost:9000/zhang-root-config.js&quot;,\n    &quot;@zhang/app1&quot;: &quot;//localhost:8500/zhang-app1.js&quot;,\n    &quot;react&quot;: &quot;https://cdn.jsdelivr.net/npm/react@16.13.1/umd/react.production.min.js&quot;,\n    &quot;react-dom&quot;: &quot;https://cdn.jsdelivr.net/npm/react-dom@16.13.1/umd/react-dom.production.min.js&quot;\n  }\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">编辑<code>root-config.js</code>，将子应用注册。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// root-config.js\nimport { registerApplication, start } from &quot;single-spa&quot;;\n\nregisterApplication({\n  name: &quot;@zhang/app1&quot;,\n  app: () =&gt; System.import(&quot;@zhang/app1&quot;),\n  activeWhen: [&quot;/&quot;]\n});\n\nstart({\n  urlRerouteOnly: true,\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">接下来访问主应用时子应用也能够正常渲染。这种方式特别适合子应用依赖主应用上下文的情况。如果你的子应用非常独立，可以使用<code>npm run start:standalone</code>启用standalone模式。</p>\n<p class=\"para\">按照官方的文档体验下来感受还是挺不错的，通过功能健全的脚手架，项目初始化的过程十分轻松。接下来再来聊聊 single-spa提出的一些其他概念，以帮助更好理解和使用这个框架。</p>\n<h2 class=\"heading subtitle heading\" id=\"三种类型\" style=\"position:relative;\"><a href=\"#%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B\" aria-label=\"三种类型 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>三种类型</h2>\n<p class=\"para\">在 <code>single-spa</code> 的上下文中，有三种微前端（microfrontend):</p>\n<ol>\n<li>single-spa applications: 为具体的路由渲染组建</li>\n<li>single-spa parcels: 渲染不控制路由的组件</li>\n<li>utility modules: 共享的代码逻辑，不渲染组件</li>\n</ol>\n<p class=\"para\">一个Web应用可能会包含一个或者多个不同类型的微前端，三者具体的对比如下：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Application</th>\n<th>Parcel</th>\n<th>Utility</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>路由</td>\n<td>多路由</td>\n<td>无路由</td>\n<td>无路由</td>\n</tr>\n<tr>\n<td>API类型</td>\n<td>声明式 API</td>\n<td>命令式 API</td>\n<td>导出一个公共接口</td>\n</tr>\n<tr>\n<td>是否渲染UI</td>\n<td>是</td>\n<td>是</td>\n<td>maybe</td>\n</tr>\n<tr>\n<td>生命周期</td>\n<td>single-spa管理</td>\n<td>自己管理</td>\n<td>外部模块，不管理生命周期</td>\n</tr>\n<tr>\n<td>何时使用</td>\n<td>核心</td>\n<td>需要支持多框架时</td>\n<td>共享逻辑或者创建一个service</td>\n</tr>\n<tr>\n<td>## 应用的生命周期</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p class=\"para\">要添加一个应用，首先需要注册该应用。一旦应用被注册后，必须在其入口文件(entry point)实现下面提到的各个生命周期函数。注册的应用会经过下载(loaded)、初始化(initialized)、被挂载(mounted)、卸载(unmounted)和unloaded（被移除）等过程。single-spa会通过“生命周期”为这些过程提供钩子函数。</p>\n<p class=\"para\">生命周期函数是在各应用的主文件中注册， single-spa 查找对应的函数名并进行调用。</p>\n<blockquote class=\"quote\">\n<ol>\n<li>bootstrap, mount, and unmount的实现是必须的，unload则是可选的</li>\n<li>生命周期函数必须有返回值，可以是Promise或者async函数</li>\n<li>如果导出的是函数数组而不是单个函数，这些函数会被依次调用，对于promise函数，会等到resolve之后再调用下一个函数</li>\n<li>如果 single-spa 未启动，各个应用会被下载，但不会被初始化、挂载或卸载。</li>\n</ol>\n</blockquote>\n<p class=\"para\">生命周期函数使用 <code>props</code> 传参，这个对象包含<code>single-spa</code>相关信息和其他的自定义属性。以<code>bootstrap</code>为例</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function bootstrap(props) {\n  const {\n    name,        // 注册到 single-spa 的应用名称\n    singleSpa,   // 对singleSpa 实例的引用\n    mountParcel, // 手动挂载的函数\n    customProps  // 自定义属性\n  } = props;     // Props 会传给每个生命周期函数\n  return Promise.resolve();\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><code>customProps</code>允许在使用时将自定义属性传递给各个周期，</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// root-config.js\nsingleSpa.registerApplication({\n  name: &#39;app1&#39;,\n  activeWhen,\n  app,\n  customProps: { authToken: &quot;d83jD63UdZ6RS6f70D0&quot; }\n});\nsingleSpa.registerApplication({\n  name: &#39;app1&#39;,\n  activeWhen,\n  app,\n  customProps: (name, location) =&gt; {\n    return { authToken: &quot;d83jD63UdZ6RS6f70D0&quot; };\n  }\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在注册的回调方法中可以获取到传入的自定义属性</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export function mount(props) {\n  console.log(props.authToken); // 可以在 app1 中获取到authToken参数\n  return reactLifecycles.mount(props);\n}</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"single-spa-生态系统\" style=\"position:relative;\"><a href=\"#single-spa-%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F\" aria-label=\"single spa 生态系统 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>single-spa 生态系统</h2>\n<p class=\"para\">single-spa是一个与框架无关的微前端框架，整个体积压缩之后只有5kb左右，它所做的事情就是应用的注册和启动，以及提供生命周期。好在它的生态系统正在蓬勃发展，正在尽可能多地支持更多框架和构建工具，帮助开发者用自己喜欢的框架编写Web程序。这其实印证了前面所提到的： 微前端不是单纯的框架或者工具，是一套完整的体系。</p>\n<p class=\"para\">下一篇文章将对single-spa和single-spa-react的源码进行一次分析，来看看其背后到底是怎么运作的</p>\n<p class=\"para\">参考</p>\n<ol>\n<li><a href=\"https://github.com/phodal/microfrontends#%E8%B7%AF%E7%94%B1%E5%88%86%E5%8F%91%E5%BC%8F%E5%BE%AE%E5%89%8D%E7%AB%AF\" class=\"link-underline\">Thinking in Microfrontend (微前端的那些事儿)</a></li>\n<li><a href=\"https://single-spa.js.org/docs/getting-started-overview#documentation\" class=\"link-underline\">getting-started-overview</a></li>\n</ol>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%E8%83%8C%E6%99%AF\">背景</a></p>\n</li>\n<li>\n<p><a href=\"#single-spa-%E7%9A%84%E4%BD%BF%E7%94%A8\">single-spa 的使用</a></p>\n<ul>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAroot-config\">创建一个root config</a></li>\n<li><a href=\"#%E5%88%9B%E5%BB%BA%E5%AD%90%E5%BA%94%E7%94%A8\">创建子应用</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B\">三种类型</a></p>\n</li>\n<li>\n<p><a href=\"#single-spa-%E7%94%9F%E6%80%81%E7%B3%BB%E7%BB%9F\">single-spa 生态系统</a></p>\n</li>\n</ul>","headings":[{"id":"背景","depth":2,"value":"背景"},{"id":"single-spa-的使用","depth":2,"value":"single-spa 的使用"},{"id":"创建一个root-config","depth":3,"value":"创建一个root config"},{"id":"创建子应用","depth":3,"value":"创建子应用"},{"id":"三种类型","depth":2,"value":"三种类型"},{"id":"single-spa-生态系统","depth":2,"value":"single-spa 生态系统"}],"frontmatter":{"title":"使用 single-spa 实现微前端","date":"2020-11-05","cover":null,"description":null,"categories":["技术研究"],"tags":[]}},"previous":{"fields":{"slug":"/blogs/2020-11-21-single-spa源码解析-registerApplication和start/"},"frontmatter":{"title":"single-spa源码解析-registerApplication和start"}},"next":{"fields":{"slug":"/blogs/2020-10-14-在滴滴的这几年：基于Git的平台文档解决方案/"},"frontmatter":{"title":"在滴滴的这几年：基于Git的平台文档解决方案","tags":[],"categories":["解决方案"],"status":null}}},"pageContext":{"id":"19735d71-38bc-5691-b204-f44e59b152d0","previousPostId":"7a8b3efd-b9ba-543d-a533-e4b1747b9341","nextPostId":"e5df3770-a63b-5c02-8918-75d0e4d225d6"}},
    "staticQueryHashes": ["2841359383"]}