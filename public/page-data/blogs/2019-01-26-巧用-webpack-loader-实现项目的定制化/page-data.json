{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2019-01-26-巧用-webpack-loader-实现项目的定制化/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"c78dc207-20e3-54bd-affc-a2a935bab2a3","html":"<h2 class=\"heading subtitle heading\" id=\"背景\" style=\"position:relative;\"><a href=\"#%E8%83%8C%E6%99%AF\" aria-label=\"背景 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>背景</h2>\n<p class=\"para\">有这样的需求：项目交付的版本要求支持针对客户定制产品的LOGO、登录界面的背景。</p>\n<!--more--> \n<h2 class=\"heading subtitle heading\" id=\"简单分析\" style=\"position:relative;\"><a href=\"#%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90\" aria-label=\"简单分析 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>简单分析</h2>\n<p class=\"para\">手动替换文件再编译这种蠢到极点的方法肯定是无法接受的。如果你说采用分支的方式来对付这种需求，我觉得也是不太现实。分支虽然好用，但是不要瞎用。项目在交付时需要避免交付的代码中包含其他客户的资源和信息。这意味着，通过配置文件等在运行时加载的形式是行不通。</p>\n<p class=\"para\">想来想去，问题的本质无非就是解决项目编译输出时CSS可以使用我们指定的图片文件，而我们需要将这个过程自动化。</p>\n<h2 class=\"heading subtitle heading\" id=\"粗暴的方案\" style=\"position:relative;\"><a href=\"#%E7%B2%97%E6%9A%B4%E7%9A%84%E6%96%B9%E6%A1%88\" aria-label=\"粗暴的方案 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>粗暴的方案</h2>\n<p class=\"para\">先来一种简单而又直接的方案：直接替换。其步骤如下：</p>\n<ol>\n<li>将图片资源放入指定的目录中，按项目(客户)区分</li>\n<li>执行替换图片资源的脚本，使用指定的资源替换</li>\n<li>执行项目的编译命令</li>\n</ol>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// node ./pre-packaging.js it\n\nconst path = require(&quot;path&quot;);\nconst fs = require(&quot;fs&quot;);\nconst project = process.argv[2];\nconst distPath = path.resolve(&quot;./src/static/images&quot;); // 源代码目录\nconst resourcePath = path.resolve(&quot;./resources&quot;, project); // 项目静态文件目录\n\nfunction copyDir(src, dist) {\n  try {\n    fs.accessSync(dist, fs.constants.R_OK | fs.constants.W_OK);\n  } catch (err) {\n    fs.mkdirSync(dist);\n  }\n\n  const copyFile = (src, dist) =&gt; {\n    fs.createReadStream(src).pipe(fs.createWriteStream(dist));\n  };\n\n  const dirList = fs.readdirSync(src);\n\n  dirList.forEach(item =&gt; {\n    const currentPath = path.resolve(src, item);\n    const currentDistPath = path.resolve(dist, item);\n\n    if (fs.statSync(currentPath).isDirectory()) {\n      copyDir(currentPath, currentDistPath);\n    } else {\n      const src = currentPath;\n      const dist = currentDistPath;\n\n      copyFile(src, dist);\n    }\n  });\n}\n\ncopyDir(resourcePath, distPath);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">看起来我们的问题已经得到解决。但是你仔细想想，便会发现，这种简单粗暴的方案存在多个不足之处。</p>\n<ol>\n<li>侵入性强。每次自定义版本构建之后都修改项目中的图片资源，这些修改很容易被同步到远端。</li>\n<li>拓展性差。自定义的图片资源必须严格按照源码中的约定，比如图片格式，图片尺寸。每一张图片都需要在代码中提供相应的插槽。</li>\n<li>功能单一。只能修改图片的引用，当其他的样式需要调整时便无能为力。</li>\n<li>体验性差。将构建过程拆分为准备静态资源和编译两个过程。</li>\n</ol>\n<h2 class=\"heading subtitle heading\" id=\"我们需要优雅\" style=\"position:relative;\"><a href=\"#%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%BC%98%E9%9B%85\" aria-label=\"我们需要优雅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>我们需要优雅</h2>\n<p class=\"para\">如此丑陋的方案是无法接受的，是否有更好的方案？此时我们回到问题：如何实现同一个项目针对不同客户定制界面的Logo和登录背景？</p>\n<p class=\"para\">我们需要修改的是什么？CSS!</p>\n<p class=\"para\">既想修改CSS样式，又想不对源码进行修改，那只有采用CSS样式具有的覆盖规则来实现。源文件中设置默认样式，约定使用的 CSS 选择器，通过编译将新的样式文件和源文件合并，所有的样式打包输出。这种方式有诸多好处：</p>\n<ol>\n<li>侵入性弱。只需要在项目仓库中维护对应的资源，不影响源代码，交付时也不会包含多余的资源。</li>\n<li>拓展性强。自定义的图片资源不在依赖源码，可以使用任意的图片格式。</li>\n<li>功能丰富。可以额外增加自定义样式，不限于需求中的Logo和背景。</li>\n<li>体验好。在编译阶段加载指定的样式，一步到位。</li>\n</ol>\n<p class=\"para\">说到前端的编译打包，自然想到Webpack。可以从 Webpack Loader入手，实现上述过程。</p>\n<h2 class=\"heading subtitle heading\" id=\"Webpack-Loader\" style=\"position:relative;\"><a href=\"#Webpack-Loader\" aria-label=\"Webpack Loader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Webpack Loader</h2>\n<p class=\"para\">在 Webpack 的生态中，Loader 用于对模块的源代码进行转换。Loader 可以使你在 import 或”加载”模块时预处理文件。因此，Loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。Loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。</p>\n<p class=\"para\">Webpack Loader的编写可参考<a href=\"https://webpack.docschina.org/contribute/writing-a-loader/\" class=\"link-underline\">官方文档</a>，有非常详细的说明。</p>\n<p class=\"para\">以常见的一段 Webpack 配置为例：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">module.exports = {\n  entry: [...],\n  output: {...},\n  module: {\n    rules: [\n      ...,\n      {\n        test: /\\.less$/,\n        use: [\n          {\n            loader: &#39;style-loader&#39;,\n          },\n          {\n            loader: &#39;css-loader&#39;,\n          },\n          {\n            loader: &#39;less-loader&#39;,\n          }\n        ];\n      }\n      ...,\n    ],\n  },\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\">上述配置在执行过程中，less文件的编译会按照如下顺序 (<a href=\"https://webpack.docschina.org/contribute/writing-a-loader/#%E5%A4%8D%E6%9D%82%E7%94%A8%E6%B3%95\" class=\"link-underline\">Webpack Loader 执行顺序</a>)：</p>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 664px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/95c0e8c459b471e82c5a05cef9bf673b/31493/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 12.765957446808512%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA/klEQVQI1wHzAAz/AJzMXWd4zpcAPry0W2HQxZpi0caHXc7Ekj69tkkAAAACUce/jWLQxplj0ceVT8a+mQCMggg9vLZBXM3EpGLQxphgz8WrQL62bXTOnQCdzV5TAJ3MXOQALP8GVcbDmorQv/+HzLz/gMy9/13LxYwAmOAcetLE/43SwP+Jy7r/etHD/wCx3h5Pw8V/hM29/4rPvv+Kzr3/YMnApwAA/wKXymDfAJrKXYO33HIAP7y3cGjKvtJoyb25Yca8x0TAvFAAlr0NVsW8v2jKvsppyb3OWca91garvBY7u7lMX8a7xmbIvbdlyL3JQby2ervZZgCWxl55ML2MMRnMH9gAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"IMAGE\"\n        title=\"IMAGE\"\n        src=\"/static/95c0e8c459b471e82c5a05cef9bf673b/31493/1.png\"\n        srcset=\"/static/95c0e8c459b471e82c5a05cef9bf673b/4dcb9/1.png 188w,\n/static/95c0e8c459b471e82c5a05cef9bf673b/5ff7e/1.png 375w,\n/static/95c0e8c459b471e82c5a05cef9bf673b/31493/1.png 664w\"\n        sizes=\"(max-width: 664px) 100vw, 664px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p class=\"para\">在整个编译过程中，我们可以在每一个loader的开始前和结束后合并我们自定义样式，如下图所示：</p>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 735px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f979da3bd447384b9ffb01db20e93b14/7608e/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 25.531914893617024%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABoElEQVQY0wGVAWr+ADu+tx5rzsLuds7A63bPwvNky8C6RsG7VnjWyNV20sXGd9XI2VXHv2tcysGDd9XI13bTxcd01cjNMbezSXHUx7J41cfSetXH1WbPw8AJoqENAD7FxhNw0MTSe87A3HzPweJqy7+mWMnAYoXczf57z8Hsg9nK+2HNwntq0MWYg9nK/3jPxPiB28z9OLm1WoDbzNGC1cf1gtTF9XLVytkDo60PAFu4gQVCsW8QAKb/CwCiqwcAX4sFAJKmCwCIlA0Gt9oVAImVCwCHnQkAmKYNAKCmDxW82hgApKYTAKa0DQCWmw0Er8cWALD/CEq0gxZfuYgGAKDOWrqj0FnfRrGeHjC6yjp10MLXftLD12fMwKsAQ/8IX8rEfXzTxN970cPdW8nBbgBp/Q1rzMG4f9PE4XLOwNwguNgzZbeCIKTQWOOgzlqsAJvIV86cy1nxXbeIFjC7zDtuyLz3dsi69mLHvb3//xAAV8bAl3XKvP10ybz/VsbAiwAA/wNjxbzJd8m68WjFufAnvNgsbLt/I5vJWP2dyli21TPm4Z6jEAYAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"IMAGE\"\n        title=\"IMAGE\"\n        src=\"/static/f979da3bd447384b9ffb01db20e93b14/7608e/2.png\"\n        srcset=\"/static/f979da3bd447384b9ffb01db20e93b14/4dcb9/2.png 188w,\n/static/f979da3bd447384b9ffb01db20e93b14/5ff7e/2.png 375w,\n/static/f979da3bd447384b9ffb01db20e93b14/7608e/2.png 735w\"\n        sizes=\"(max-width: 735px) 100vw, 735px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p class=\"para\">在less-loader之前加入自定义的CSS样式是最好的时机，为什么呢？有两点：</p>\n<ol>\n<li>同时支持原生 CSS 和 Less 两种文件。</li>\n<li>在整个编译开始之前加入，对编译的整个过程没有影响。新增的样式同样享受完整编译过程。</li>\n</ol>\n<p class=\"para\">编译过程修改为如下图所示：</p>\n<p class=\"para\"><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e7cbc41db84c64824a6fd351eb1e7592/6a6e9/3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 10.106382978723403%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAArUlEQVQI1wGiAF3/AKDOWqmiz1nBE6q+EWfMwbV80sTZYsi+kiq4wiZtzMDTec/B2VTEvmxKxMJKedLE1nfRw889vrxAW8fAcXrSxNJtzsHABazaGKLPWI+gz1rMAJrIWLydylfLGLjRGGLCubp3x7ngX8G4mSW6yyZtyb3Resy+2FXEv2JHwcFXeMy+53bLveg8v8FOWsK9f3rKu+1rx7rYB7TrHZrHV62dy1jqwINhtpg5mDIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"IMAGE\"\n        title=\"IMAGE\"\n        src=\"/static/e7cbc41db84c64824a6fd351eb1e7592/1d69c/3.png\"\n        srcset=\"/static/e7cbc41db84c64824a6fd351eb1e7592/4dcb9/3.png 188w,\n/static/e7cbc41db84c64824a6fd351eb1e7592/5ff7e/3.png 375w,\n/static/e7cbc41db84c64824a6fd351eb1e7592/1d69c/3.png 750w,\n/static/e7cbc41db84c64824a6fd351eb1e7592/6a6e9/3.png 826w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<h2 class=\"heading subtitle heading\" id=\"开发一个-merge-loader\" style=\"position:relative;\"><a href=\"#%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA-merge-loader\" aria-label=\"开发一个 merge loader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>开发一个 merge-loader</h2>\n<p class=\"para\">在目前的场景中，merge-loader 只需要一个参数：自定义样式的文件路径。所以 Webpack 配置文件可以修改为：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">module.exports = {\n  entry: [...],\n  output: {...},\n  module: {\n    rules: [\n      ...,\n      {\n        test: /\\.less$/,\n        use: [\n          {\n            loader: &#39;style-loader&#39;,\n          },\n          {\n            loader: &#39;css-loader&#39;,\n          },\n          {\n            loader: &#39;less-loader&#39;,\n          }，\n          {\n            loader: path.resolve(__dirname, &#39;./loader/merge-less.js&#39;), // 自定义loader文件的路径\n            options: {\n              style: path.resolve(root, &#39;client/statics/projects/it/style.less&#39;),\n            },\n          }\n        ];\n      }\n      ...,\n    ],\n  },\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\">merge-loader中的逻辑如下：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const { getOptions } = require(&#39;loader-utils&#39;);\n\nmodule.exports = function (source) {\n  const options = getOptions(this);\n  const { style } = options;\n  \n  // 读取样式文件，返回字符串\n  const string = fs.readFileSync(style);\n\n  // 合并到原始文件，返回给下一个loader\n  source += string;\n\n  return source;\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\">你以为这样就结束了？不，上述逻辑有两个问题还需优化：</p>\n<ol>\n<li>当样式中存在图片的引用时，以字符串形式拼接在源码样式中会遇到图片路径错误的问题</li>\n<li>只要文件通过了规则<code>/\\.less&#x26;/</code>的匹配，就会执行一次merge操作。含有<code>&#x3C;style lang=\"less\">&#x3C;/style></code> 的vue文件也会触发这个规则(虽然重复引用不会增加代码量)。</li>\n</ol>\n<p class=\"para\">这两个问题的解法如下：</p>\n<ol>\n<li>使用 <code>@import \"path/of/style\"</code> 方式 merge 样式文件。其他的处理交给后面的loader，保证文件和图片路径引用正确。</li>\n<li>增加一个参数<code>target</code>，指定一个文件作为 merge 的对象。</li>\n</ol>\n<p class=\"para\">这样一来，loader的逻辑修改如下：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const { getOptions } = require(&#39;loader-utils&#39;);\n\nmodule.exports = function (source， meta) {\n  const options = getOptions(this);\n  const { style, target } = options;\n\n  if (meta) {\n    // file: &#39;test.vue&#39;\n    // sourceRoot: &#39;client&#39;\n    const { file, sourceRoot } = meta;\n\n    if (target === path.join(sourceRoot, file)) {\n      const string = `\\n@import &quot;${style}&quot;;\\n`;\n      \n      source += string;\n    }\n  }\n\n  return source;\n};</code>\n        </deckgo-highlight-code>\n<p class=\"para\">Webpack 配置文件中loader部分修改如下：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">module.exports = {\n  entry: [...],\n  output: {...},\n  module: {\n    rules: [\n      ...,\n      {\n        test: /\\.less$/,\n        use: [\n          {\n            loader: &#39;style-loader&#39;,\n          },\n          {\n            loader: &#39;css-loader&#39;,\n          },\n          {\n            loader: &#39;less-loader&#39;,\n          }，\n          {\n            loader: path.resolve(__dirname, &#39;./loader/merge-less.js&#39;), // 自定义loader文件的路径\n            options: {\n              style: path.resolve(root, &#39;client/statics/projects/it/style.less&#39;),\n            },\n          }\n        ];\n      }\n      ...,\n    ],\n  },\n};</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"优化-Loader\" style=\"position:relative;\"><a href=\"#%E4%BC%98%E5%8C%96-Loader\" aria-label=\"优化 Loader permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>优化 Loader</h2>\n<p class=\"para\">最后利用 <a href=\"https://webpack.docschina.org/contribute/writing-a-loader/#loader-%E5%B7%A5%E5%85%B7%E5%BA%93-loader-utilities-\" class=\"link-underline\">Loader 工具库</a>来优化代码</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const fs = require(&#39;fs&#39;);\nconst path = require(&#39;path&#39;);\nconst loaderUtils = require(&#39;loader-utils&#39;);\nconst validateOptions = require(&#39;schema-utils&#39;);\n\nconst schema = {\n  type: &#39;object&#39;,\n  properties: {\n    style: {\n      type: &#39;string&#39;,\n    },\n    target: {\n      type: &#39;string&#39;,\n    },\n  },\n  required: [ &#39;style&#39;, &#39;target&#39; ],\n};\n\n\nmodule.exports = function (source, meta) {\n  const options = loaderUtils.getOptions(this);\n\n  // 验证 options 参数\n  validateOptions(schema, options, &#39;Loader options&#39;);\n\n  let { style, target } = options;\n\n  /*\n   * Loader 原则之一：不要在模块代码中插入绝对路径，因为当项目根路径变化时，文件绝对路径也会变化\n   * 使用 stringifyReques 将绝对路径转换成相对路径\n   */\n  style = loaderUtils.stringifyRequest(this, style);\n\n  if (meta) {\n    const { file, sourceRoot } = meta;\n\n    if (target === path.join(sourceRoot, file)) {\n      const string = `\\n @import ${style};\\n`;\n\n      source += string;\n    }\n  }\n\n  return source;\n}</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"结束\" style=\"position:relative;\"><a href=\"#%E7%BB%93%E6%9D%9F\" aria-label=\"结束 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>结束</h2>\n<p class=\"para\">至此，已经用一种比较优雅的方式实现了项目Logo等样式的定制化，其优势在于：</p>\n<ol>\n<li>侵入性弱。只需要在项目仓库中维护对应的资源，不影响源代码，交付时也不会包含多余的资源。</li>\n<li>拓展性强。自定义的图片资源不在依赖源码，可以使用任意的图片格式。</li>\n<li>功能丰富。可以额外增加自定义样式，不限于需求中的Logo和背景。</li>\n<li>体验好。在编译阶段加载指定的样式，一步到位。</li>\n</ol>\n<p class=\"para\">如果同学们有其他的实现方式，欢迎讨论~~</p>","tableOfContents":"<ul>\n<li><a href=\"#%E8%83%8C%E6%99%AF\">背景</a></li>\n<li><a href=\"#%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90\">简单分析</a></li>\n<li><a href=\"#%E7%B2%97%E6%9A%B4%E7%9A%84%E6%96%B9%E6%A1%88\">粗暴的方案</a></li>\n<li><a href=\"#%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%BC%98%E9%9B%85\">我们需要优雅</a></li>\n<li><a href=\"#webpack-loader\">Webpack Loader</a></li>\n<li><a href=\"#%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA-merge-loader\">开发一个 merge-loader</a></li>\n<li><a href=\"#%E4%BC%98%E5%8C%96-loader\">优化 Loader</a></li>\n<li><a href=\"#%E7%BB%93%E6%9D%9F\">结束</a></li>\n</ul>","headings":[{"id":"背景","depth":2,"value":"背景"},{"id":"简单分析","depth":2,"value":"简单分析"},{"id":"粗暴的方案","depth":2,"value":"粗暴的方案"},{"id":"我们需要优雅","depth":2,"value":"我们需要优雅"},{"id":"Webpack-Loader","depth":2,"value":"Webpack Loader"},{"id":"开发一个-merge-loader","depth":2,"value":"开发一个 merge-loader"},{"id":"优化-Loader","depth":2,"value":"优化 Loader"},{"id":"结束","depth":2,"value":"结束"}],"frontmatter":{"title":"巧用 webpack loader 实现项目的定制化","date":"2019-01-26","cover":null,"description":null,"categories":["技术应用"],"tags":["Webpack"]}},"previous":{"fields":{"slug":"/blogs/2019-03-09-浅谈-HTTP-缓存/"},"frontmatter":{"title":"浅谈 HTTP 缓存"}},"next":{"fields":{"slug":"/blogs/2018-10-08-在CentOS上部署Pyspider爬虫项目/"},"frontmatter":{"title":"在 CentOS 上部署 pyspider 爬虫项目","tags":["Python"],"categories":[null],"status":null}}},"pageContext":{"id":"c78dc207-20e3-54bd-affc-a2a935bab2a3","previousPostId":"e684b29e-a44d-5534-8d03-2980ca03d355","nextPostId":"23a1881a-4b13-5f29-bc5a-1c94ce4c92e9"}},
    "staticQueryHashes": ["2841359383"]}