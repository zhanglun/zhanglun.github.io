{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2020-11-21-single-spa源码解析-registerApplication和start/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"7a8b3efd-b9ba-543d-a533-e4b1747b9341","html":"<p class=\"para\">首先将问题简化，假定主应用和子应用都已经准备好的情况下，针对应用的注册和启动这两个关键操作进行分析。</p>\n<p class=\"para\">在主应用中只需要调用<code>registerApplication</code>即可注册子应用，调用<code>start</code>启动主应用。比如下面的例子</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// single-spa-config.js\nimport { registerApplication, start } from &#39;single-spa&#39;;\n\n// 使用简单参数\nregisterApplication(\n  &#39;app2&#39;, \n  () =&gt; import(&#39;src/app2/main.js&#39;),\n  (location) =&gt; location.pathname.startsWith(&#39;/app2&#39;),\n  { some: &#39;value&#39; },\n);\n\n// 使用对象参数\nregisterApplication({\n  name: &#39;app1&#39;,\n  app: () =&gt; import(&#39;src/app1/main.js&#39;),\n  activeWhen: &#39;/app1&#39;,\n  customProps: {\n    some: &#39;value&#39;,\n  }\n);\n\nstart();</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"registerApplication\" style=\"position:relative;\"><a href=\"#registerApplication\" aria-label=\"registerApplication permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>registerApplication</h2>\n<p class=\"para\">先让我们来看一下函数签名</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">registerApplication(\n  appNameOrConfig,\n  appOrLoadApp,\n  activeWhen,\n  customProps\n)</code>\n        </deckgo-highlight-code>\n<p class=\"para\">可以传四个参数，也能传递一个对象。对象参数的效果与四个参数效果一样。因为在 <code>registerApplication</code> 函数的顶部就会执行来一个序列化参数的操作，统一将参数转换成约定 <code>registration</code>。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// src/application/apps.js\nexport function registerApplication(\n  appNameOrConfig,\n  appOrLoadApp,\n  activeWhen,\n  customProps\n) {\n  const registration = sanitizeArguments(\n    appNameOrConfig,\n    appOrLoadApp,\n    activeWhen,\n    customProps\n  );\n  ...\n}</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"序列化参数\" style=\"position:relative;\"><a href=\"#%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%82%E6%95%B0\" aria-label=\"序列化参数 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>序列化参数</h3>\n<p class=\"para\"><code>sanitizeArguments</code>这个方法里面的逻辑不复杂，简单来说就是将各参数序列化成需要的类型。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function sanitizeArguments(\n  appNameOrConfig,\n  appOrLoadApp,\n  activeWhen,\n  customProps\n) {\n  const usingObjectAPI = typeof appNameOrConfig === &quot;object&quot;;\n\n  const registration = {\n    name: null,\n    loadApp: null,\n    activeWhen: null,\n    customProps: null,\n  };\n\n  if (usingObjectAPI) {\n    validateRegisterWithConfig(appNameOrConfig);\n    registration.name = appNameOrConfig.name;\n    registration.loadApp = appNameOrConfig.app;\n    registration.activeWhen = appNameOrConfig.activeWhen;\n    registration.customProps = appNameOrConfig.customProps;\n  } else {\n\n// 校验各参数类型，如果不通过就抛出错误。\n    validateRegisterWithArguments(\n      appNameOrConfig,\n      appOrLoadApp,\n      activeWhen,\n      customProps\n    );\n    registration.name = appNameOrConfig;\n    registration.loadApp = appOrLoadApp;\n    registration.activeWhen = activeWhen;\n    registration.customProps = customProps;\n  }\n\n  registration.loadApp = sanitizeLoadApp(registration.loadApp);\n  registration.customProps = sanitizeCustomProps(registration.customProps);\n  registration.activeWhen = sanitizeActiveWhen(registration.activeWhen);\n\n  return registration;\n}</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"将应用注入\" style=\"position:relative;\"><a href=\"#%E5%B0%86%E5%BA%94%E7%94%A8%E6%B3%A8%E5%85%A5\" aria-label=\"将应用注入 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>将应用注入</h3>\n<p class=\"para\">参数序列化之后，先调用 <code>getAppNames</code> 方法检查是否存在重复注册的子应用，如果有则抛出错误</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">if (getAppNames().indexOf(registration.name) !== -1)\n  throw Error(\n    formatErrorMessage(\n      21,\n      __DEV__ &amp;&amp;\n      `There is already an app registered with name ${registration.name}`,\n      registration.name\n    )\n  );</code>\n        </deckgo-highlight-code>\n<p class=\"para\">如果不存在重复注册的应用，接下来就将所有的应用注册到 apps 数组中，执行 <code>reroute()</code></p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">apps.push(\n  assign(\n    {\n      loadErrorTime: null,\n      status: NOT_LOADED,\n      parcels: {},\n      devtools: {\n        overlays: {\n          options: {},\n          selectors: [],\n        },\n      },\n    },\n    registration\n  )\n);\n\nif (isInBrowser) {\n  ensureJQuerySupport();\n  reroute();\n}</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"start\" style=\"position:relative;\"><a href=\"#start\" aria-label=\"start permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>start</h2>\n<p class=\"para\">因为<code>start</code>方法和<code>registeApplication</code>方法最后都调用了<code>reroute</code>，<code>start</code>的代码比较少，所以先介绍start方法。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">// src/start.js\nimport { reroute } from &quot;./navigation/reroute.js&quot;;\nimport { formatErrorMessage } from &quot;./applications/app-errors.js&quot;;\nimport { setUrlRerouteOnly } from &quot;./navigation/navigation-events.js&quot;;\nimport { isInBrowser } from &quot;./utils/runtime-environment.js&quot;;\n\nlet started = false;\n\nexport function start(opts) {\n  started = true;\n  if (opts &amp;&amp; opts.urlRerouteOnly) {\n    setUrlRerouteOnly(opts.urlRerouteOnly);\n  }\n  if (isInBrowser) {\n    reroute();\n  }\n}\n\nexport function isStarted() {\n  return started;\n}\n\nif (isInBrowser) {\n  setTimeout(() =&gt; {\n    if (!started) {\n      console.warn(\n        formatErrorMessage(\n          1,\n          __DEV__ &amp;&amp;\n            `singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted.`\n        )\n      );\n    }\n  }, 5000);\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">首先申明了一个 <code>started</code> 变量作为应用启动的标记，默认是 <code>false</code>，表示未启动。<code>isStarted()</code>返回这个标记，用来判断当前应用的状态。</p>\n<p class=\"para\">start`方法接受一个options参数，目前只有一个配置：urlRerouteOnly。默认是false。如果设置成true，调用history.pushState() 和 history.replaceState() 时不会触发 reroute，除非客户端路由真的发生了变化。设置为true时在某些时候会有更好的性能。</p>\n<p class=\"para\"><code>urlRerouteOnly</code>会在navigation-events中使用，后面再讲。</p>\n<p class=\"para\">在文件的最后作了一个超时检测，在代码执行5s后<code>isStarted</code>状态依旧是<code>false</code>时抛出一个警告。</p>\n<p class=\"para\">接下来看一下核心方法Reroute</p>\n<h2 class=\"heading subtitle heading\" id=\"reroute\" style=\"position:relative;\"><a href=\"#reroute\" aria-label=\"reroute permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>reroute</h2>\n<p class=\"para\">默认设置 <code>appChangeUnderway</code>为<code>false</code>。函数每次执行时都会判断<code>appChangeUnderway</code>。<code>appChangeUnderway</code>为<code>true</code>时表示当前有<code>reroute</code>的任务正在执行(reroute被调用了并且其中的promsie任务还没结束），此时返回一个Promise，内部将resolve，reject和reoute的第二个参数一起 push 到<code>peopleWaitingOnAppChange</code>中，等当前reroute对应的任务执行完成之后在作为 <code>pendingPromise</code> 参数继续执行。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">if (appChangeUnderway) {\n  return new Promise((resolve, reject) =&gt; {\n    peopleWaitingOnAppChange.push({\n      resolve,\n      reject,\n      eventArguments,\n    });\n  });\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">但是<code>appChangeUnderway</code>初始值是<code>false</code>，在什么时候被修改成true的呢？接着往下看。</p>\n<p class=\"para\">调用<code>getAppChanges()</code>方法将注册的应用按照当前各自的生命周期分组:</p>\n<ol>\n<li>加载失败（LOAD_ERROR) 的app放入appToUnload</li>\n<li>未下载（NOT_LOADED)和下载中（LOADING_SOURCE_CODE)的app放入 appsToLoad</li>\n<li>未引导（NOT_BOOTSTRAPPED)和未挂载（NOT_MOUNTED)的app放入appsToUnload或者appsToMount</li>\n<li>已挂载（MOUNTED)的app放入appsToUnmount</li>\n</ol>\n<p class=\"para\">未引导（NOT_BOOTSTRAPPED)和未挂载（NOT_MOUNTED)的app会多加一个判断，当前window.location匹配activeWhen规则时放入appToMount数组，否则放入appsToUnload。</p>\n<p class=\"para\">分组完毕之后，判断前文提到的started状态。如果started为true，将appChangeUnderway也设置为true，然后将app按照toUnload，toLoad,toUnmount和toMount的分组数组合并在一起，保存到appsThatChanged数组中。最后调用 performAppChanges 方法，返回执行的结果。如果started为false，将ToLoad的app赋值给appsThatChanged，然后调用loadApps方法，并返回执行的结果。</p>\n<h3 class=\"heading\" id=\"loadApps-和-performAppChanges\" style=\"position:relative;\"><a href=\"#loadApps-%E5%92%8C-performAppChanges\" aria-label=\"loadApps 和 performAppChanges permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>loadApps 和 performAppChanges</h3>\n<h4 class=\"heading\" id=\"loadApps\" style=\"position:relative;\"><a href=\"#loadApps\" aria-label=\"loadApps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>loadApps</h4>\n<p class=\"para\">先来看较为简单的loadApps()方法。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function loadApps() {\n  return Promise.resolve().then(() =&gt; {\n    const loadPromises = appsToLoad.map(toLoadPromise);\n\n    return (\n      Promise.all(loadPromises)\n        .then(callAllEventListeners)\n        // there are no mounted apps, before start() is called, so we always return []\n        .then(() =&gt; [])\n        .catch((err) =&gt; {\n          callAllEventListeners();\n          throw err;\n        })\n    );\n  });\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\"><code>loadApps</code>只有在启动的时候会调用一次，此时<code>started</code> 为 <code>false</code>。这个方法具体做了什么事情呢？</p>\n<p class=\"para\">遍历appsToLoad中的app，最后返回一个Promise数组，通过Promise.all()一次性全部调用将app的状态设置为 <code>LOADING_SOURCE_CODE</code>，然后检查参数中的生命周期函数，将这些函数挂载到app上。然后再调用 <code>callAllEventListeners</code> 方法，劫持 <code>hashchange</code> 和<code>popstate</code>这两个事件。</p>\n<h4 class=\"heading\" id=\"performAppChanges\" style=\"position:relative;\"><a href=\"#performAppChanges\" aria-label=\"performAppChanges permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>performAppChanges</h4>\n<p class=\"para\">如果应用已经启动，即 <code>started</code>为 <code>true</code> 时，逻辑会进入到 <code>performAppChanges</code> 方法，这个方法有点长。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function performAppChanges() {\n  return Promise.resolve().then(() =&gt; {\n    // https://github.com/single-spa/single-spa/issues/545\n    window.dispatchEvent(\n      new CustomEvent(\n        appsThatChanged.length === 0\n          ? &quot;single-spa:before-no-app-change&quot;\n          : &quot;single-spa:before-app-change&quot;,\n        getCustomEventDetail(true)\n      )\n    );\n\n    window.dispatchEvent(\n      new CustomEvent(\n        &quot;single-spa:before-routing-event&quot;,\n        getCustomEventDetail(true, { cancelNavigation })\n      )\n    );\n\n    if (navigationIsCanceled) {\n      window.dispatchEvent(\n        new CustomEvent(\n          &quot;single-spa:before-mount-routing-event&quot;,\n          getCustomEventDetail(true)\n        )\n      );\n      finishUpAndReturn();\n      navigateToUrl(oldUrl);\n      return;\n    }\n\n    const unloadPromises = appsToUnload.map(toUnloadPromise);\n\n    const unmountUnloadPromises = appsToUnmount\n      .map(toUnmountPromise)\n      .map((unmountPromise) =&gt; unmountPromise.then(toUnloadPromise));\n\n    const allUnmountPromises = unmountUnloadPromises.concat(unloadPromises);\n\n    const unmountAllPromise = Promise.all(allUnmountPromises);\n\n    unmountAllPromise.then(() =&gt; {\n      window.dispatchEvent(\n        new CustomEvent(\n          &quot;single-spa:before-mount-routing-event&quot;,\n          getCustomEventDetail(true)\n        )\n      );\n    });\n\n    /* We load and bootstrap apps while other apps are unmounting, but we\n      * wait to mount the app until all apps are finishing unmounting\n      */\n    const loadThenMountPromises = appsToLoad.map((app) =&gt; {\n      return toLoadPromise(app).then((app) =&gt;\n        tryToBootstrapAndMount(app, unmountAllPromise)\n      );\n    });\n\n    /* These are the apps that are already bootstrapped and just need\n      * to be mounted. They each wait for all unmounting apps to finish up\n      * before they mount.\n      */\n    const mountPromises = appsToMount\n      .filter((appToMount) =&gt; appsToLoad.indexOf(appToMount) &lt; 0)\n      .map((appToMount) =&gt; {\n        return tryToBootstrapAndMount(appToMount, unmountAllPromise);\n      });\n    return unmountAllPromise\n      .catch((err) =&gt; {\n        callAllEventListeners();\n        throw err;\n      })\n      .then(() =&gt; {\n        /* Now that the apps that needed to be unmounted are unmounted, their DOM navigation\n          * events (like hashchange or popstate) should have been cleaned up. So it&#39;s safe\n          * to let the remaining captured event listeners to handle about the DOM event.\n          */\n        callAllEventListeners();\n\n        return Promise.all(loadThenMountPromises.concat(mountPromises))\n          .catch((err) =&gt; {\n            pendingPromises.forEach((promise) =&gt; promise.reject(err));\n            throw err;\n          })\n          .then(finishUpAndReturn);\n      });\n  });\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">可以看到，这个方法也是放在一个 <code>Promise.resolve()</code>中。首先触发了一些自定义事件，然后根据应用状态分别创建了对应取消操作的Promise数组。需要被移除的应用 <code>appToUnLoad</code>创建了<code>unLoadPromises</code>，需要被卸载的应用<code>appsToUnmount</code>先创建卸载的<code>toUnmountPromise</code>，再创建 <code>unLoadPromise</code>。最后将所有的Promise合并成一个数组通过Promise.all执行，执行完成之后触发<code>single-spa:before-mount-routing-event</code>事件。</p>\n<p class=\"para\">至此，需要unmount和unload的app执行过程都结束了，接下来如法炮制开始load和mount对应的应用。使用 <code>appToLoad</code> 和 <code>appToMount</code> 创建一个Promise数组，通过Promise.all执行。在app对应状态变更完成之后，调用 <code>tryToBootstrapAndMount</code>完成引导并挂载应用。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">function tryToBootstrapAndMount(app, unmountAllPromise) {\n  if (shouldBeActive(app)) {\n    return toBootstrapPromise(app).then((app) =&gt;\n      unmountAllPromise.then(() =&gt;\n        shouldBeActive(app) ? toMountPromise(app) : app\n      )\n    );\n  } else {\n    return unmountAllPromise.then(() =&gt; app);\n  }\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">引导并挂载成功之后触发一次<code>single-spa:routing-event</code>事件，根据变化的app数量决定触发<code>single-spa:no-app-change</code>事件还是<code>single-spa:app-change</code>事件。最后将<code>appChangeUnderway</code>设置为<code>false</code>，保证后续的reroute()调用能够执行，此时也标志着当前这次reroute调用的执行已结束，最后检查当前是否还有pengding中的任务，有的话继续执行。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">if (peopleWaitingOnAppChange.length &gt; 0) {\n  /* While we were rerouting, someone else triggered another reroute that got queued.\n    * So we need reroute again.\n    */\n  const nextPendingPromises = peopleWaitingOnAppChange;\n  peopleWaitingOnAppChange = [];\n  reroute(nextPendingPromises);\n}</code>\n        </deckgo-highlight-code>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#registerapplication\">registerApplication</a></p>\n<ul>\n<li><a href=\"#%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%82%E6%95%B0\">序列化参数</a></li>\n<li><a href=\"#%E5%B0%86%E5%BA%94%E7%94%A8%E6%B3%A8%E5%85%A5\">将应用注入</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#start\">start</a></p>\n</li>\n<li>\n<p><a href=\"#reroute\">reroute</a></p>\n<ul>\n<li>\n<p><a href=\"#loadapps-%E5%92%8C-performappchanges\">loadApps 和 performAppChanges</a></p>\n<ul>\n<li><a href=\"#loadapps\">loadApps</a></li>\n<li><a href=\"#performappchanges\">performAppChanges</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","headings":[{"id":"registerApplication","depth":2,"value":"registerApplication"},{"id":"序列化参数","depth":3,"value":"序列化参数"},{"id":"将应用注入","depth":3,"value":"将应用注入"},{"id":"start","depth":2,"value":"start"},{"id":"reroute","depth":2,"value":"reroute"},{"id":"loadApps-和-performAppChanges","depth":3,"value":"loadApps 和 performAppChanges"},{"id":"loadApps","depth":4,"value":"loadApps"},{"id":"performAppChanges","depth":4,"value":"performAppChanges"}],"frontmatter":{"title":"single-spa源码解析-registerApplication和start","date":"2020-11-21","cover":null,"description":null,"categories":["技术研究"],"tags":[]}},"previous":{"fields":{"slug":"/blogs/2020-11-28-如何在项目中接入single-spa/"},"frontmatter":{"title":"如何在项目中接入single-spa"}},"next":{"fields":{"slug":"/blogs/2020-11-05-使用Single-SPA实现微前端/"},"frontmatter":{"title":"使用 single-spa 实现微前端","tags":[],"categories":["技术研究"],"status":null}}},"pageContext":{"id":"7a8b3efd-b9ba-543d-a533-e4b1747b9341","previousPostId":"d0f0ca39-1cce-5939-a405-e41f8619403c","nextPostId":"19735d71-38bc-5691-b204-f44e59b152d0"}},
    "staticQueryHashes": ["2841359383"]}