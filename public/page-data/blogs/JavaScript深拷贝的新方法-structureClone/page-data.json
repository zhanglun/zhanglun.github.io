{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/JavaScript深拷贝的新方法-structureClone/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"1caaf643-db67-5fa5-8197-0a71f6fbd694","html":"<p class=\"para\">对象拷贝这个话题算是老生常谈了，从浅拷贝到深拷贝，从最简单的JSON.stringfy()到递归遍历赋值，作为面试八股文的常客，字节的朋友甚至写出了<a href=\"https://juejin.cn/post/6844903929705136141\" class=\"link-underline\">惊艳面试官的深拷贝</a>，不得不佩服。</p>\n<p class=\"para\">通常在项目开发中，遇到深拷贝的场景，一般有多种处理方式：</p>\n<ul>\n<li>\n<p class=\"para\">使用其他第三方库</p>\n</li>\n<li>\n<p class=\"para\">使用有前人“沉淀”的类库</p>\n</li>\n<li>\n<p class=\"para\">自己再“实现”一次</p>\n</li>\n</ul>\n<p class=\"para\">现在可以使用一个内置的方法来解决深拷贝的问题，它就是今天的主角：structuredClone()。在本文发布时，各浏览器的nightly版本中已经实现了这个API，在Firefox 94的版本中甚至已经是稳定状态了。Node 在v17的版本中<a href=\"https://github.com/nodejs/node/pull/39759\" class=\"link-underline\">实现了这个API</a>，可以直接使用了。让我们对它进行一些些简单的探索。</p>\n<p class=\"para\">在讨论JavaScript中的对象的拷贝问题时，通常是从浅拷贝和深拷贝两个角度来讨论。</p>\n<h2 class=\"heading subtitle heading\" id=\"浅拷贝\" style=\"position:relative;\"><a href=\"#%E6%B5%85%E6%8B%B7%E8%B4%9D\" aria-label=\"浅拷贝 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>浅拷贝</h2>\n<p class=\"para\">对于基本类型来说，拷贝就是复制对应的值，在内存中新开辟一块地址保存这个值。而引用类型的浅拷贝则是复制其内存地址。如果被拷贝对象的属性中有其他引用类型，当拷贝后的对象对内部的引用类型发生变化之后，原始对象也会受到影响。我们使用解构来举个简单的例子：</p>\n<deckgo-highlight-code language=\"typescript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const myOriginal = {\n  someProp: &quot;with a string value&quot;,\n  anotherProp: {\n    withAnotherProp: 1,\n    andAnotherProp: true\n  }\n};\n\nconst myShallowCopy = {...myOriginal};</code>\n        </deckgo-highlight-code>\n<p class=\"para\">修改或者添加拷贝结果的属性时，原对象不受影响。</p>\n<deckgo-highlight-code language=\"typescript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">myShallowCopy.aNewProp = &quot;a new value&quot;;\nconsole.log(myOriginal.aNewProp)\n// ^  `undefined`</code>\n        </deckgo-highlight-code>\n<p class=\"para\">但是，添加或者修改内部嵌套的属性时，两个对象会同步修改。</p>\n<deckgo-highlight-code language=\"typescript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">myShallowCopy.anotherProp.aNewProp = &quot;a new value&quot;;\nconsole.log(myOriginal.anotherProp.aNewProp) \n// ^ logs `a new value`</code>\n        </deckgo-highlight-code>\n<h2 class=\"heading subtitle heading\" id=\"深拷贝\" style=\"position:relative;\"><a href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D\" aria-label=\"深拷贝 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>深拷贝</h2>\n<p class=\"para\">深拷贝的逻辑是将一个对象的属性逐一复制，当属性的值是一个对象时，创建一个新的对象，重复复制的过程，直到属性值为基本类型。需要所有的对象最终都的内存地址都是全新的。</p>\n<p class=\"para\">在不使用类库的情况下，使用 JSON API 可以快速实现深拷贝：</p>\n<deckgo-highlight-code language=\"typescript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const myDeepCopy = JSON.parse(JSON.stringify(myOriginal));</code>\n        </deckgo-highlight-code>\n<p class=\"para\">这个方法简单易用，而且V8针对 JSON.parse()做过优化，尽可能提高JSON.parse()的执行效率。但是它也有一些局限性：</p>\n<ul>\n<li>\n<p class=\"para\"><strong>无法处理循环引用</strong>：当对象存在循环引用时，JSON.stringify()会抛出错误</p>\n</li>\n<li>\n<p class=\"para\"><strong>不支持一些内置的类型</strong>：如果属性中包含一些内置的对象类型，JSON.stringify()执行时，会去掉一些属性值，最后输出的是”{}“字符串，比如： Map, Set, Date, RegExp 等</p>\n</li>\n<li>\n<p class=\"para\"><strong>丢弃函数:</strong> 如果属性值是一个函数，JSON.stringify 会直接抛弃这个属性</p>\n</li>\n</ul>\n<p class=\"para\">在 structuredClone 出现之前，JSON API 似乎是唯一一个解决深拷贝问题的API, 虽然不太完美。</p>\n<h2 class=\"heading subtitle heading\" id=\"StructuredClone\" style=\"position:relative;\"><a href=\"#StructuredClone\" aria-label=\"StructuredClone permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>StructuredClone</h2>\n<p class=\"para\">在HTML Sepc 中通过了<a href=\"https://html.spec.whatwg.org/multipage/structured-data.html#dom-structuredclone\" class=\"link-underline\">StructuredClone()</a>的提案，帮助我们在一些场景中方便的复制结构化对象。用法非常简单，很轻松地就能解决深拷贝的问题。在内部实现中，通过维护一个记录引用访问状态的Map来实现对循环引用的支持。</p>\n<deckgo-highlight-code language=\"typescript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const myDeepCopy = structuredClone(myOriginal);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">还支持第二个参数： transfter，这个参数是可选的，可以将被复制对象中的ArrayBuffer等可转换的对象转移到新的对象中，而不是复制一份，比如：</p>\n<deckgo-highlight-code language=\"typescript\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var uInt8Array = new Uint8Array(1024 * 1024 * 16); // 16MB\nfor (var i = 0; i &lt; uInt8Array.length; ++i) {\n  uInt8Array[i] = i;\n}\n\nconst transferred = structuredClone(uInt8Array, { transfer: [uInt8Array.buffer] }).\nconsole.log(uInt8Array.byteLength);  // 0\nconsole.log(transferred.byteLength); // 16MB</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在复制时，将 uInt8Array 的 buffer 对象转移到 transferred 中。</p>\n<p class=\"para\">除了我们显示的调用这个API之外，它也经常在内部被其他的API调用。比如使用IndexedDB存储数据时，通过postMessage在Worker之间传递消息或者执行其他一些涉及到复制对象相关的API。</p>\n<p class=\"para\">相比JSON API，在深拷贝这件事情上，structuredClone有一些优势，比如支持循环引用，对数据类型的支持能力更加健壮，甚至执行效率上又有一些优势。但是structuredClone本身亦有一些限制：</p>\n<ul>\n<li>\n<p class=\"para\">函数不能复制，抛出<code>DataCloneError</code>的错误类型</p>\n</li>\n<li>\n<p class=\"para\">DOM 节点不能复制，抛出<code>DataCloneError</code>的错误类型</p>\n</li>\n<li>\n<p class=\"para\">其他明确不会保留的属性：</p>\n<ul>\n<li>\n<p class=\"para\">RegExp中的lastIndex不会被保留</p>\n</li>\n<li>\n<p class=\"para\">属性描述符，setter, getter 等其他类似的特性不会复制。如果一个对象通过属性描述符标记为只读，复制之后将会变成可读可写，因为可读可写是默认值</p>\n</li>\n<li>\n<p class=\"para\">原型链不会被遍历，也不会被复制</p>\n</li>\n</ul>\n</li>\n</ul>\n<p class=\"para\">如果这些限制不影响你的使用，structuredClone将会是一个不错的选择。反之你也可以继续使用第三方库来解决深拷贝的问题。</p>\n<h2 class=\"heading subtitle heading\" id=\"参考\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考</h2>\n<ul>\n<li>\n<p class=\"para\"><a href=\"https://web.dev/structured-clone/\" class=\"link-underline\">https://web.dev/structured-clone/</a></p>\n</li>\n<li>\n<p class=\"para\"><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/structuredClone#browser_compatibility\" class=\"link-underline\">https://developer.mozilla.org/en-US/docs/Web/API/structuredClone#browser_compatibility</a></p>\n</li>\n<li>\n<p class=\"para\"><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#see_also\" class=\"link-underline\">https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#see_also</a></p>\n</li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"#%E6%B5%85%E6%8B%B7%E8%B4%9D\">浅拷贝</a></li>\n<li><a href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D\">深拷贝</a></li>\n<li><a href=\"#structuredclone\">StructuredClone</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>","headings":[{"id":"浅拷贝","depth":2,"value":"浅拷贝"},{"id":"深拷贝","depth":2,"value":"深拷贝"},{"id":"StructuredClone","depth":2,"value":"StructuredClone"},{"id":"参考","depth":2,"value":"参考"}],"frontmatter":{"title":"JavaScript深拷贝的新方法-structureClone","date":"2021-12-18","cover":"https://www.notion.so/images/page-cover/met_gerome_1890.jpg","description":null,"categories":["技术研究"],"tags":["JavaScrtipt"]}},"previous":{"fields":{"slug":"/blogs/《架构师修炼之道》摘录04-换位思考/"},"frontmatter":{"title":"《架构师修炼之道》摘录04-换位思考"}},"next":{"fields":{"slug":"/blogs/【译】防御性CSS/"},"frontmatter":{"title":"【译】防御性CSS","tags":["CSS"],"categories":["博客译文"],"status":"publish"}}},"pageContext":{"id":"1caaf643-db67-5fa5-8197-0a71f6fbd694","previousPostId":"e250a237-b966-5f69-99dc-f0cf113a4c79","nextPostId":"d83bed9e-7725-5b5e-a719-8b7c8ab2164a"}},
    "staticQueryHashes": ["2841359383"]}