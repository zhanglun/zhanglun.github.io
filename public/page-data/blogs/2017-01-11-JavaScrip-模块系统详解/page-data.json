{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blogs/2017-01-11-JavaScrip-模块系统详解/",
    "result": {"data":{"site":{"siteMetadata":{"title":"张小伦的网络日志","description":"欢迎来到张小伦的网络日志 \n\t\t一个记录生活，分享心得的博客","menu":[{"id":"home","name":"首页","url":"/"},{"id":"blog","name":"博文","url":"/blogs"},{"id":"category","name":"分类","url":"/categories"},{"id":"archive","name":"归档","url":"/archives"},{"id":"lab","name":"实验室","url":"/labs"},{"id":"about","name":"关于我","url":"/about"}]}},"markdownRemark":{"id":"9859446f-1ab1-59c5-9ac8-3b78ae64ff3c","html":"<p class=\"para\">在这几天的工作中，我需要调用同事编写的兼容jQuery和React的通用组件。他为了兼容jQuery风格的调用和React的组件化，分别export了一个default和几个方法函数。在调用的过程中，出现了一些小插曲：React代码和老的jQuery老代码调用时应该怎么正确的import？虽然是很低级的问题，但是引发了我一些思考：<strong>export 和 import 与 module.exports 和 exports 之间的关系</strong>以及<strong>JavaScript模块系统的发展历程</strong>。</p>\n<!--more-->\n<p class=\"para\">JavScript这门语言，在设计之初是没有自己的模块系统的。但是在 ES6 正式发布之前，社区已经中已经出现了一些库，实现了简单的模块风格，并且这种风格在 ES6 中也是适用的：</p>\n<ul>\n<li>每个模块都是一段代码，加载之后只会解析过程只会执行一次；</li>\n<li>在模块中可以声明变量，函数，类等；\n<ul>\n<li>默认情况下，这些声明都是这个模块的局部声明；</li>\n<li>可以将一些声明导出，让其他模块引用；</li>\n</ul>\n</li>\n<li>一个模块可以通过模块标识符或者文件路径引入其他模块；</li>\n<li>模块都是单例的，即使多次引用，也只有一个实例;</li>\n</ul>\n<p class=\"para\">有一点要注意，避免通过<code>global</code>作为来引用自己的模块，因为<code>global</code>本身也是一个模块。</p>\n<h3 class=\"heading\" id=\"ES5中的模块系统\" style=\"position:relative;\"><a href=\"#ES5%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F\" aria-label=\"ES5中的模块系统 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ES5中的模块系统</h3>\n<p class=\"para\">前面说到的，在 ES6 之前，JavaScript 是没有模块系统这一说的。在社区的模块风格出现之前，编写 JavaScript常常会遇到这种情况：</p>\n<ul>\n<li>所有的代码写在一个文件里面，按照依赖顺序，被依赖的方法必须写在前面。 简单粗暴，但是问题很多\n<ul>\n<li>通用的代码无法重复利用。</li>\n<li>单个文件会越来越大，后期的命名也会越来越艰难。</li>\n</ul>\n</li>\n<li>按照功能将代码拆分成不同文件，按照依赖顺序加载，被依赖的方法必须先加载。通用代码可以复用，但是问题还是很多\n<ul>\n<li>过多全局变量，容易冲突。</li>\n<li>过多 JavaScript 脚本加载导致页面阻塞（虽然 HTML5中的 defer和 async可以适当的减轻这个问题）。</li>\n<li>过多依赖不方便管理和开发。</li>\n</ul>\n</li>\n</ul>\n<p class=\"para\">随着 JavaScript 的地位慢慢提高，为了满足日常开发的需要，社区中慢慢出现了相对比较同意的模块标准，主要有两种：</p>\n<ul>\n<li><strong>CommonJS Modules:</strong> 这个标准主要在 Node.js 中实现（Node.js的模块比 CommonJS 好稍微多一些特性）。其特点是：</li>\n</ul>\n<ul>\n<li>简单的语法</li>\n<li>为同步加载和服务端而设计</li>\n</ul>\n<ul>\n<li><strong>Asynchronous Module Definition (AMD):</strong> 这个标准最受欢迎的实现实在 RequireJS 中。其特点是：</li>\n</ul>\n<ul>\n<li>稍微复杂一点点的语法，使得AMD的运行不需要编译</li>\n<li>为异步加载和浏览器而设计</li>\n</ul>\n<p class=\"para\">上述只是 ES5 模块系统的简单介绍，如果有兴趣可以去看看<a href=\"https://addyosmani.com/writing-modular-js/\" class=\"link-underline\">Writing Modular JavaScript With AMD, CommonJS &#x26; ES Harmony</a>。</p>\n<h4 class=\"heading\" id=\"CommonJS-Modules-在-Nodejs-中的实现\" style=\"position:relative;\"><a href=\"#CommonJS-Modules-%E5%9C%A8-Nodejs-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0\" aria-label=\"CommonJS Modules 在 Nodejs 中的实现 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CommonJS Modules 在 Node.js 中的实现</h4>\n<p class=\"para\">根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性，或者将属性暴露出来。在 Nodejs就是如此。</p>\n<p class=\"para\">比如：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const circle = require(&#39;./circle.js&#39;); // 使用 require 加载模块 circle\nconsole.log(`The area of a circle of radius 4 is ${circle.area(4)}`);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">在 circle.js 中:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const PI = Math.PI;\nexports.area = (r) =&gt; PI * r * r;\nexports.circumference = (r) =&gt; 2 * PI * r;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">circle.js 模块导出了 area()和 circumffference()两个方法，变量 PI是这个模块的私有变量。如果想为自定义的模块添加属性或者方法，将它们添加到 exports 这个特殊的对象上就可以达到目的。\n如果希望模块提供的接口是一个构造函数，或者输出的是一个完整的对象而不是一个属性，那么可以使用 module.exports 代替 exports。但是注意，exports 是 module.exports 的一个引用，只是为了用起来方便，只要没有重写 module.exports对象，那么<code>module.exports.xxx</code>就等价于<code>exports.xxx</code>。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const square = require(&#39;./square.js&#39;);\nvar mySquare = square(2);\nconsole.log(`The area of my square is ${mySquare.area()}`);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">square.js:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">module.exports = (width) =&gt; {\n  return {\n    area: () =&gt; width * width\n  };\n}</code>\n        </deckgo-highlight-code>\n<h4 class=\"heading\" id=\"AMD规范\" style=\"position:relative;\"><a href=\"#AMD%E8%A7%84%E8%8C%83\" aria-label=\"AMD规范 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AMD规范</h4>\n<p class=\"para\">AMD是“Asynchronous Module Definition”的缩写。通过异步方式加载模块，模块的加载不影响后续语句的执行，所有依赖加载中的模块的语句，都会放在一个回调函数中，等到该模块加载完成后，这个回调函数才运行。注意，在 AMD 中模块名是全局作用域，可以在全局引用。</p>\n<p class=\"para\">AMD规范的API非常简单：</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">define(id?, dependencies?, factory);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">规范定义了一个define函数，它用来定义一个模块。它包含三个参数，前两个参数都是可选的。</p>\n<ul>\n<li>id：是一个string字符串，它表示模块的标识。通常用来定义这个模块的名字，一般不用</li>\n<li>dependencies：是一个数组，依赖的模块的标识。也是可选的参数，每个依赖的模块的输出将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]。</li>\n<li>factory：一个函数或者对象。如果是函数，在依赖的模块加载成功后，会执行这个回调函数，它的返回值就是模块的输出接口或值。它的参数是所有依赖模块的引用。</li>\n</ul>\n<p class=\"para\">定义一个名为 myModule 的模块，它依赖 jQuery 模块：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">define(&#39;myModule&#39;, [&#39;jquery&#39;], function($) {\n    // $ 是 jquery 模块的输出\n    $(&#39;body&#39;).text(&#39;hello world&#39;);\n});\n// 使用\ndefine([&#39;myModule&#39;], function(myModule) {});</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"ES6中的模块系统\" style=\"position:relative;\"><a href=\"#ES6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F\" aria-label=\"ES6中的模块系统 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ES6中的模块系统</h3>\n<p class=\"para\">ES6 模块系统的目标就是创建一个统一的模块格式，让 CommonJS 和 AMD的使用者都满意：</p>\n<ul>\n<li>和CommonJS类似，但是更加简洁的语法，循环引用的支持更好。</li>\n<li>和AMD类似，直接支持异步加载和可配置的模块加载。</li>\n</ul>\n<p class=\"para\">模块标准主要有两部分：</p>\n<ol>\n<li>声明语法：import 和 export</li>\n<li>可编程的加载 API：配置模块如何以及有条件地加载模块</li>\n</ol>\n<h4 class=\"heading\" id=\"ES6模块的基础\" style=\"position:relative;\"><a href=\"#ES6%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E7%A1%80\" aria-label=\"ES6模块的基础 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ES6模块的基础</h4>\n<p class=\"para\">在 ES6的模块系统中，有两种 export：命名的 export 和默认的 export。在一个文件中，命名的 export 可以有多个，而默认的 default export 只能有一个。可以同时使用，但最好还是分开使用。</p>\n<h5 class=\"heading\" id=\"命名的export\" style=\"position:relative;\"><a href=\"#%E5%91%BD%E5%90%8D%E7%9A%84export\" aria-label=\"命名的export permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>命名的export</h5>\n<p class=\"para\">也可以在声明表达式前面加上 export 关键字可以直接导出将声明的对象导出：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ lib.js ------\nexport const sqrt = Math.sqrt;\nexport function square(x) {\n    return x * x;\n}\nexport function diag(x, y) {\n    return sqrt(square(x) + square(y));\n}\n\n//------ main.js ------\nimport { square, diag } from &#39;lib&#39;;\nconsole.log(square(11)); // 121\nconsole.log(diag(4, 3)); // 5</code>\n        </deckgo-highlight-code>\n<p class=\"para\">如果要导出一个已经存在的变量，需要加上<code>{}</code>:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const random = Math.random;\nexport random;  // SyntaxError: Unexpected token, expected {\nexport { random };</code>\n        </deckgo-highlight-code>\n<p class=\"para\">使用 CommonJS 语法实现相同目的：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ lib.js ------\nvar sqrt = Math.sqrt;\nfunction square(x) {\n    return x * x;\n}\nfunction diag(x, y) {\n    return sqrt(square(x) + square(y));\n}\nmodule.exports = {\n    sqrt: sqrt,\n    square: square,\n    diag: diag,\n};\n\n//------ main.js ------\nvar square = require(&#39;lib&#39;).square;\nvar diag = require(&#39;lib&#39;).diag;\nconsole.log(square(11)); // 121\nconsole.log(diag(4, 3)); // 5</code>\n        </deckgo-highlight-code>\n<p class=\"para\">下面是来自 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export\" class=\"link-underline\">MDN</a> 的更加完整的export 语法：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export { name1, name2, …, nameN };\nexport { variable1 as name1, variable2 as name2, …, nameN };\nexport let name1, name2, …, nameN; // also var\nexport let name1 = …, name2 = …, …, nameN; // also var, const\n\nexport expression;\nexport default expression;\nexport default function (…) { … } // also class, function*\nexport default function name1(…) { … } // also class, function*\nexport { name1 as default, … };\n\nexport * from …;\nexport { name1, name2, …, nameN } from …;\nexport { import1 as name1, import2 as name2, …, nameN } from …;</code>\n        </deckgo-highlight-code>\n<h5 class=\"heading\" id=\"默认导出\" style=\"position:relative;\"><a href=\"#%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%87%BA\" aria-label=\"默认导出 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>默认导出</h5>\n<p class=\"para\">每个模块只有一个默认导出的值， default export 可以是一个函数，一个类，一个对象或者其他任意值。有两种形式的 default export:</p>\n<ol>\n<li>被标记的声明。导出一个函数或者类</li>\n<li>直接导出值。导出表达式的运行结果</li>\n</ol>\n<p class=\"para\">导出一个函数：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ myFunc.js ------\nexport default function () {} // 没有分号 函数名可有可无\n\n//------ main1.js ------\nimport myFunc from &#39;myFunc&#39;;\nmyFunc();</code>\n        </deckgo-highlight-code>\n<p class=\"para\">导出一个类：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ MyClass.js ------\nexport default class {} // 没有分号 类名可有可无\n\n//------ main2.js ------\nimport MyClass from &#39;MyClass&#39;;\nconst inst = new MyClass();</code>\n        </deckgo-highlight-code>\n<p class=\"para\">导出表达式运行结果：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export default &#39;abc&#39;;\nexport default foo();\nexport default /^xyz$/;\nexport default 5 * 7;\nexport default { no: false, yes: true };</code>\n        </deckgo-highlight-code>\n<p class=\"para\">前面说的到的导出匿名函数和类，可以将其视为导出表达式的运行结果：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export default (function () {});\nexport default (class {});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">每一个 default export 都是这种结构：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export default &lt;&lt;expression&gt;&gt;</code>\n        </deckgo-highlight-code>\n<p class=\"para\">相当于：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">const __default__  = &lt;&lt;expression&gt;&gt;;\nexport { __default__ as default }; // (A)</code>\n        </deckgo-highlight-code>\n<p class=\"para\">export后面是不能接变量声明的，因为一个变量声明表达式中可以一次生命多个变量。考虑下面这种情况：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">export default const foo = 1, bar = 2, baz = 3; // not legal JavaScript!</code>\n        </deckgo-highlight-code>\n<p class=\"para\">应该导出 foo，bar，还是 baz 呢？</p>\n<h5 class=\"heading\" id=\"必须在模块的最顶层使用import和export\" style=\"position:relative;\"><a href=\"#%E5%BF%85%E9%A1%BB%E5%9C%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E9%A1%B6%E5%B1%82%E4%BD%BF%E7%94%A8import%E5%92%8Cexport\" aria-label=\"必须在模块的最顶层使用import和export permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>必须在模块的最顶层使用import和export</h5>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">if (Math.random()) {\n    import &#39;foo&#39;; // SyntaxError\n}\n\n// You can’t even nest `import` and `export`\n// inside a simple block:\n{\n    import &#39;foo&#39;; // SyntaxError\n}</code>\n        </deckgo-highlight-code>\n<h5 class=\"heading\" id=\"import-会被提升到当前作用域的顶部\" style=\"position:relative;\"><a href=\"#import-%E4%BC%9A%E8%A2%AB%E6%8F%90%E5%8D%87%E5%88%B0%E5%BD%93%E5%89%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%A1%B6%E9%83%A8\" aria-label=\"import 会被提升到当前作用域的顶部 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>import 会被提升到当前作用域的顶部</h5>\n<p class=\"para\">模块的 import 会被提升到当前作用域的顶部。所以下面这种情况是可行的：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">foo();\n\nimport { foo } from &#39;my_module&#39;;</code>\n        </deckgo-highlight-code>\n<h5 class=\"heading\" id=\"import-的一些细节\" style=\"position:relative;\"><a href=\"#import-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82\" aria-label=\"import 的一些细节 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>import 的一些细节</h5>\n<p class=\"para\">import的基本语法：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">import defaultMember from &quot;module-name&quot;;\nimport * as name from &quot;module-name&quot;;\nimport { member } from &quot;module-name&quot;;\nimport { member as alias } from &quot;module-name&quot;;\nimport { member1 , member2 } from &quot;module-name&quot;;\nimport { member1 , member2 as alias2 , [...] } from &quot;module-name&quot;;\nimport defaultMember, { member [ , [...] ] } from &quot;module-name&quot;;\nimport defaultMember, * as name from &quot;module-name&quot;;\nimport &quot;module-name&quot;;</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"对循环引用的支持\" style=\"position:relative;\"><a href=\"#%E5%AF%B9%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81\" aria-label=\"对循环引用的支持 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>对循环引用的支持</h3>\n<p class=\"para\">什么是循环引用？模块A 引用了模块 B，模块 B 又引用了模块 A。如果可能的话，应该避免这种情况出现，这会使得模块之间过度的耦合。但是这种有时候又是无法避免的。</p>\n<h4 class=\"heading\" id=\"CommonJS-中的循环引用\" style=\"position:relative;\"><a href=\"#CommonJS-%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\" aria-label=\"CommonJS 中的循环引用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CommonJS 中的循环引用</h4>\n<p class=\"para\">a.js 中的内容：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">console.log(&#39;模块 a 开始了！&#39;);\nexports.done = false;\nvar b = require(&#39;./b.js&#39;);\nconsole.log(&#39;在 a 中, b.done = %j&#39;, b.done);\nexports.done = true;\nconsole.log(&#39;模块 a 结束了！&#39;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">b.js 中的内容：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">console.log(&#39;模块 b 开始了！&#39;);\nexports.done = false;\nvar a = require(&#39;./a.js&#39;);\nconsole.log(&#39;在 b 中, a.done = %j&#39;, a.done);\nexports.done = true;\nconsole.log(&#39;模块 b 结束了！&#39;);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">main.js 中的内容：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">console.log(&#39;main 开始了！&#39;);\nvar a = require(&#39;./a.js&#39;);\nvar b = require(&#39;./b.js&#39;);\nconsole.log(&#39;在 main 中, a.done=%j, b.done=%j&#39;, a.done, b.done);</code>\n        </deckgo-highlight-code>\n<p class=\"para\">当 main.js 加载 a.js 时，a.js 又加载 b.js。这个时候，b.js 又会尝试去加载 a.js 。为了防止出现无限循环的加载，a.js 中的 exports 对象会返回一个 unfinished copy 给 b.js 模块。然后模块 b 完成加载，同时将提供模块 a 的接口。当 main.js 加载完 a，b 两个模块之后，输出如下：</p>\n<deckgo-highlight-code language=\"bash\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">main 开始了！\n模块 a 开始了！\n模块 b 开始了！\n在 b 中, a.done = false\n模块 b 结束了！\n在 a 中, b.done = true\n模块 a 结束了！\n在 main 中, a.done=true, b.done=true</code>\n        </deckgo-highlight-code>\n<p class=\"para\">这种方式有其局限性：</p>\n<ul>\n<li>\n<p class=\"para\">Nodejs风格的单个值的导出无法工作。当a使用 module.exports 导出一个值时，那么 b 模块中引用的变量 a 在声明之后就不会再更新</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">  module.exports = function(){};</code>\n        </deckgo-highlight-code>\n</li>\n<li>\n<p class=\"para\">无法直接命名你的引用</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">var foo = require(&#39;a&#39;).foo; // foo  is undefined</code>\n        </deckgo-highlight-code>\n</li>\n</ul>\n<h4 class=\"heading\" id=\"ES6中的循环引用\" style=\"position:relative;\"><a href=\"#ES6%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\" aria-label=\"ES6中的循环引用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ES6中的循环引用</h4>\n<p class=\"para\">ES6中，imports 是 exprts 的只读视图，直白一点就是，imports 都指向 exports 原本的数据，比如：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ lib.js ------\nexport let counter = 3;\nexport function incCounter() {\n    counter++;\n}\n\n//------ main.js ------\nimport { counter, incCounter } from &#39;./lib&#39;;\n\n// The imported value `counter` is live\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n// The imported value can’t be changed\ncounter++; // TypeError</code>\n        </deckgo-highlight-code>\n<p class=\"para\">因此在 ES6中处理循环引用特别简单，看下面这段代码：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ a.js ------\nimport {bar} from &#39;b&#39;; // (i)\nexport function foo() {\n  bar(); // (ii)\n}\n\n//------ b.js ------\nimport {foo} from &#39;a&#39;; // (iii)\nexport function bar() {\n  if (Math.random()) {\n    foo(); // (iv)\n  }\n}</code>\n        </deckgo-highlight-code>\n<p class=\"para\">假设先加载模块 a，在模块 a 加载完成之后，bar 间接性地指向的是模块 b 中的 bar。无论是加载命令的 imports 还是未完成的 imports，imports 和 exports 之间都有一个间接的联系，所以总是可以正常工作。</p>\n<h3 class=\"heading\" id=\"ES6-模块加载器-API\" style=\"position:relative;\"><a href=\"#ES6-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8-API\" aria-label=\"ES6 模块加载器 API permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ES6 模块加载器 API</h3>\n<p class=\"para\">除了声明式加载模块，ES6还提供了一个可编程的 API：</p>\n<ul>\n<li>以编程的方式使用模块</li>\n<li>配置模块的加载</li>\n</ul>\n<p class=\"para\">要注意，这个 API 并不是ES6标准中的一部分，在“JavaScript Loader Standrad”中，并且具体的标准还在制定中，所以下面讲到的内容都是试验性的。</p>\n<h4 class=\"heading\" id=\"Loaders-的简单使用\" style=\"position:relative;\"><a href=\"#Loaders-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8\" aria-label=\"Loaders 的简单使用 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Loaders 的简单使用</h4>\n<p class=\"para\">Loader 用于处理模块标识符和加载模块等。它的 construct 是<code>Reflect.Loader</code>。每个平台在全局作用域中都有一个全局变量<code>System</code>的实例来实现 loader 的一些特性。</p>\n<p class=\"para\">你可以通过 API 提供的 Promise，以编码的方式 import 一个模块：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">System.import(&#39;some_module&#39;)\n.then(some_module =&gt; {\n    // Use some_module\n})\n.catch(error =&gt; {\n    ···\n});</code>\n        </deckgo-highlight-code>\n<p class=\"para\">System.import() 可以：</p>\n<ul>\n<li>可以在 script 标签中使用模块</li>\n<li>有条件地加载模块</li>\n</ul>\n<p class=\"para\">System.import() 返回一个模块, 可以用 Promise.all() 来导入多个模块:</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">Promise.all(\n    [&#39;module1&#39;, &#39;module2&#39;, &#39;module3&#39;]\n    .map(x =&gt; System.import(x)))\n.then(([module1, module2, module3]) =&gt; {\n    // Use module1, module2, module3\n});</code>\n        </deckgo-highlight-code>\n<h5 class=\"heading\" id=\"Loader的其他方法\" style=\"position:relative;\"><a href=\"#Loader%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95\" aria-label=\"Loader的其他方法 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Loader的其他方法</h5>\n<p class=\"para\">Loader 还有一些其他方法，最重要的三个是：</p>\n<ul>\n<li>System.module(source, [options])\n将 source 中的 JavaScript 代码当做一个模块执行，返回一个 Promise</li>\n<li>System.set(name, modules)\n注册一个模块，比如用 System.module 创建的模块</li>\n<li>System.define(name, source, [options])\n执行 source 中的代码，将返回的结果注册为一个模块</li>\n</ul>\n<p class=\"para\">目前 Loader API 还处于试验阶段，更多的细节不想在深入。有兴趣的话可以去看看</p>\n<h3 class=\"heading\" id=\"模块导入的细节\" style=\"position:relative;\"><a href=\"#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E7%9A%84%E7%BB%86%E8%8A%82\" aria-label=\"模块导入的细节 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>模块导入的细节</h3>\n<p class=\"para\">在 CommonJS 和 ES6中，两种模块导入方式有一些不同：</p>\n<ul>\n<li>在 CommonJS 中，导入的内容是模块导出的内容的拷贝。</li>\n<li>在 ES6 中，导出值得实时只读视图，类似于引用。</li>\n</ul>\n<p class=\"para\">在 CommonJS 中，如果你将一个导入的值保存到一个变量中，这个值会被复制两次：第一次是这个值所属模块导出时（行 A），第二次是这个值被引用时（行 B）。</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ lib.js ------\nvar counter = 3;\nfunction incCounter() {\n    counter++;\n}\nmodule.exports = {\n    counter: counter, // (A)\n    incCounter: incCounter,\n};\n\n//------ main1.js ------\nvar counter = require(&#39;./lib&#39;).counter; // (B)\nvar incCounter = require(&#39;./lib&#39;).incCounter;\n\n// The imported value is a (disconnected) copy of a copy\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 3\n\n// The imported value can be changed\ncounter++;\nconsole.log(counter); // 4</code>\n        </deckgo-highlight-code>\n<p class=\"para\">如果通过 exports对象来访问这个值，这个值还是会再复制一次：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ main2.js ------\nvar lib = require(&#39;./lib&#39;);\n\n// The imported value is a (disconnected) copy\nconsole.log(lib.counter); // 3\nlib.incCounter();\nconsole.log(lib.counter); // 3\n\n// The imported value can be changed\nlib.counter++;\nconsole.log(lib.counter); // 4</code>\n        </deckgo-highlight-code>\n<p class=\"para\">和 CommonJS 不同的是，在 ES6中，所有的导入的数据都是导出值的视图，每一个导入的数据都和原始的数据有一个实时连接（并不是 JS 中Object引用的那种概念，因为导出的值可以是一个原始类型，primitive type，而且导入的数据是只读的）。</p>\n<ul>\n<li>无条件的引入 (import x from ‘foo’) 就是用 const 声明的变量</li>\n<li>模块的属性foo (import * as foo from ‘foo’) 则是创建一个 frozen object.</li>\n</ul>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ lib.js ------\nexport let counter = 3;\nexport function incCounter() {\n    counter++;\n}\n\n//------ main1.js ------\nimport { counter, incCounter } from &#39;./lib&#39;;\n\n// The imported value `counter` is live\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n\n// The imported value can’t be changed\ncounter++; // TypeError</code>\n        </deckgo-highlight-code>\n<p class=\"para\">如果使用*引入模块，会得到相同的结果：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ main2.js ------\nimport * as lib from &#39;./lib&#39;;\n\n// 导入的值 counter 是活动的\nconsole.log(lib.counter); // 3\nlib.incCounter();\nconsole.log(lib.counter); // 4\n\n// 导入的值是只读的不能被修改\nlib.counter++; // TypeError</code>\n        </deckgo-highlight-code>\n<p class=\"para\">虽然不能修改导入的值，但是可以修改对象指向的内容，这个 const 常量的处理是一致的。例如：</p>\n<deckgo-highlight-code language=\"js\" theme=\"one-dark\" line-numbers=\"true\"  >\n          <code slot=\"code\">//------ lib.js ------\nexport let obj = {};\n\n//------ main.js ------\nimport { obj } from &#39;./lib&#39;;\n\nobj.prop = 123; // OK\nobj = {}; // TypeError</code>\n        </deckgo-highlight-code>\n<h3 class=\"heading\" id=\"结束\" style=\"position:relative;\"><a href=\"#%E7%BB%93%E6%9D%9F\" aria-label=\"结束 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>结束</h3>\n<p class=\"para\">关于更多 ES6 模块相关的内容，有兴趣的朋友可以去下面这些地方看看：</p>\n<ul>\n<li><a href=\"http://exploringjs.com/es6/ch_modules.html\" class=\"link-underline\">http://exploringjs.com/es6/ch_modules.html</a></li>\n<li><a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-modules\" class=\"link-underline\">http://www.ecma-international.org/ecma-262/6.0/#sec-modules</a></li>\n</ul>\n<p class=\"para\">参考资料：</p>\n<ol>\n<li><a href=\"http://stackoverflow.com/a/40295288\" class=\"link-underline\">http://stackoverflow.com/a/40295288</a></li>\n<li><a href=\"http://exploringjs.com/es6/ch_modules.html\" class=\"link-underline\">http://exploringjs.com/es6/ch_modules.html</a></li>\n<li><a href=\"http://zhaoda.net/webpack-handbook/amd.html\" class=\"link-underline\">http://zhaoda.net/webpack-handbook/amd.html</a></li>\n<li>[<a href=\"https://nodejs.org/api/modules.html%5D)(\" class=\"link-underline\">https://nodejs.org/api/modules.html])(</a><a href=\"https://nodejs.org/api/modules.html\" class=\"link-underline\">https://nodejs.org/api/modules.html</a>)</li>\n<li><a href=\"http://speakingjs.com/es5/ch17.html#freezing_objects\" class=\"link-underline\">http://speakingjs.com/es5/ch17.html#freezing_objects</a></li>\n</ol>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#es5%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F\">ES5中的模块系统</a></p>\n<ul>\n<li><a href=\"#commonjs-modules-%E5%9C%A8-nodejs-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0\">CommonJS Modules 在 Node.js 中的实现</a></li>\n<li><a href=\"#amd%E8%A7%84%E8%8C%83\">AMD规范</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#es6%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F\">ES6中的模块系统</a></p>\n<ul>\n<li>\n<p><a href=\"#es6%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E7%A1%80\">ES6模块的基础</a></p>\n<ul>\n<li><a href=\"#%E5%91%BD%E5%90%8D%E7%9A%84export\">命名的export</a></li>\n<li><a href=\"#%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%87%BA\">默认导出</a></li>\n<li><a href=\"#%E5%BF%85%E9%A1%BB%E5%9C%A8%E6%A8%A1%E5%9D%97%E7%9A%84%E6%9C%80%E9%A1%B6%E5%B1%82%E4%BD%BF%E7%94%A8import%E5%92%8Cexport\">必须在模块的最顶层使用import和export</a></li>\n<li><a href=\"#import-%E4%BC%9A%E8%A2%AB%E6%8F%90%E5%8D%87%E5%88%B0%E5%BD%93%E5%89%8D%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%A1%B6%E9%83%A8\">import 会被提升到当前作用域的顶部</a></li>\n<li><a href=\"#import-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82\">import 的一些细节</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E5%AF%B9%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81\">对循环引用的支持</a></p>\n<ul>\n<li><a href=\"#commonjs-%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\">CommonJS 中的循环引用</a></li>\n<li><a href=\"#es6%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\">ES6中的循环引用</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#es6-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%99%A8-api\">ES6 模块加载器 API</a></p>\n<ul>\n<li>\n<p><a href=\"#loaders-%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8\">Loaders 的简单使用</a></p>\n<ul>\n<li><a href=\"#loader%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95\">Loader的其他方法</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E7%9A%84%E7%BB%86%E8%8A%82\">模块导入的细节</a></p>\n</li>\n<li>\n<p><a href=\"#%E7%BB%93%E6%9D%9F\">结束</a></p>\n</li>\n</ul>","headings":[{"id":"ES5中的模块系统","depth":3,"value":"ES5中的模块系统"},{"id":"CommonJS-Modules-在-Nodejs-中的实现","depth":4,"value":"CommonJS Modules 在 Node.js 中的实现"},{"id":"AMD规范","depth":4,"value":"AMD规范"},{"id":"ES6中的模块系统","depth":3,"value":"ES6中的模块系统"},{"id":"ES6模块的基础","depth":4,"value":"ES6模块的基础"},{"id":"命名的export","depth":5,"value":"命名的export"},{"id":"默认导出","depth":5,"value":"默认导出"},{"id":"必须在模块的最顶层使用import和export","depth":5,"value":"必须在模块的最顶层使用import和export"},{"id":"import-会被提升到当前作用域的顶部","depth":5,"value":"import 会被提升到当前作用域的顶部"},{"id":"import-的一些细节","depth":5,"value":"import 的一些细节"},{"id":"对循环引用的支持","depth":3,"value":"对循环引用的支持"},{"id":"CommonJS-中的循环引用","depth":4,"value":"CommonJS 中的循环引用"},{"id":"ES6中的循环引用","depth":4,"value":"ES6中的循环引用"},{"id":"ES6-模块加载器-API","depth":3,"value":"ES6 模块加载器 API"},{"id":"Loaders-的简单使用","depth":4,"value":"Loaders 的简单使用"},{"id":"Loader的其他方法","depth":5,"value":"Loader的其他方法"},{"id":"模块导入的细节","depth":3,"value":"模块导入的细节"},{"id":"结束","depth":3,"value":"结束"}],"frontmatter":{"title":"JavaScrip模块系统详解","date":"2017-01-11","cover":null,"description":null,"categories":["前端"],"tags":["JavaScript"]}},"previous":{"fields":{"slug":"/blogs/2017-01-19-整理Object的一些方法/"},"frontmatter":{"title":"整理Object的一些方法"}},"next":{"fields":{"slug":"/blogs/2017-01-05-深入理解 ES6 的解构赋值/"},"frontmatter":{"title":"深入理解 ES6 的解构赋值","tags":["JavaScript"],"categories":["前端"],"status":null}}},"pageContext":{"id":"9859446f-1ab1-59c5-9ac8-3b78ae64ff3c","previousPostId":"b6062132-dfe5-546f-ada7-2301582a1586","nextPostId":"627b6ae4-4ca2-55c5-b370-1a259bee3f28"}},
    "staticQueryHashes": ["2841359383"]}